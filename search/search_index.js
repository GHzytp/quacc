var __index = {"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"quacc \u2014 the Quantum Accelerator","text":"<p>Quacc (pronounced \"quack\") is a flexible and extensible platform for high-throughput computational materials science and quantum chemistry.</p> <p>Note</p> <p>Quacc is currently in active development. It is fully functional and ready to use, but note that the API is subject to change depending on user feedback.</p> <p></p>"},{"location":"about/changelog.html","title":"Changelog","text":"CHANGELOG.md<pre><code># Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/), and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [UNRELEASED]\n\n## [0.1.1]\n\n### Added\n\n- Added this `CHANGELOG.md` file.\n- Added the `quacc.recipes.emt.parsl` module.\n- Added a CLI for `quacc` along with a `quacc config` option to configure Covalent appropriately upon install.\n- Added generic type hints for schemas.\n- Added a `CREATE_UNIQUE_WORKDIR` global setting to have quacc automatically make a unique working directory for each calculation.\n\n### Changed\n\n- The `quacc` directory is now found in a `src` basefolder.\n- All recipes now support the `Atoms` object being passed in as an `AtomsSchema`.\n- The `slab_relax_job` kwarg in `recipes.emt.slabs` and `recipes.vasp.slabs` workflows can no longer be set to `None`, as there are few situations where this would be desired.\n- Class-based recipes have been converted to functions since they don't save state or have inheritance.\n\n### Docs\n\n- Switched the docs from Furo to Material for MkDocs.\n- Expanded upon Parsl documentation.\n- Modified tutorials and added example configs for Slurm.\n\n### Fixed\n\n- Fixed a bug where parallel, multithreaded Python jobs could cause file I/O issues.\n- Temporary directories are cleaned up after the run is completed.\n\n### Removed\n\n- Removed `quacc.recipes.vasp.jobflow` module to prioritize Covalent and Parsl.\n\n## [0.1.0]\n\nSee https://github.com/quantum-accelerators/quacc/releases/tag/v0.1.0 for more details.\n\n## [0.0.6]\n\nSee https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.6 for more details.\n\n## [0.0.5]\n\nSee https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.5 for more details.\n\n## [0.0.4]\n\nSee https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.4 for more details.\n\n## [0.0.3]\n\nSee https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.3 for more details.\n\n## [0.0.2]\n\nSee https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.2 for more details.\n\n## [0.0.1]\n\nSee https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.1 for more details.\n</code></pre>"},{"location":"about/conduct.html","title":"Code of Conduct","text":""},{"location":"about/conduct.html#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"about/conduct.html#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"about/conduct.html#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"about/conduct.html#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"about/conduct.html#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"about/conduct.html#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"about/conduct.html#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"about/conduct.html#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"about/conduct.html#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"about/conduct.html#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"about/conduct.html#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"about/contributors.html","title":"People","text":""},{"location":"about/contributors.html#developers","title":"Developers","text":"<p>Quacc was designed and developed by:</p> <ul> <li>Andrew S. Rosen, GitHub: arosen93, ORCID: 0000-0002-0141-7006.</li> </ul>"},{"location":"about/contributors.html#contributors","title":"Contributors","text":"<p>Additional contributions were made by the individuals listed here.</p>"},{"location":"about/contributors.html#inspiration","title":"Inspiration","text":"<p>Quacc was originally inspired by Atomate2, developed by Alex Ganose.</p>"},{"location":"about/faq.html","title":"FAQ","text":"<p>Q: Which workflow management system should I use?</p> <p>A: Good question! Check out the Workflow Engines Overview Guide for a comparison of several common options to see which might be best for you.</p> <p>Q: Why is quacc better than <code>InsertMyFavoriteCode</code>?</p> <p>A: Better is all in the eye of the beholder. If you are happy with the tools you are using, my goal is not to convince you to switch. That said, if you find that writing high-throughput computational workflows has a huge learning curve or simply takes too much time away from your science, then quacc may be for you.</p> <p>Q: Do you have any tips for writing new workflows?</p> <p>A: When developing new workflows, I strongly recommend writing an initial draft based on a low-cost ASE calculator like <code>EMT</code> or <code>LJ</code>, which will allow you to test on your local machine with fast turnaround. Also try to keep things modular. Trying to do too much in one function can make it difficult to debug.</p> <p>Q: How is quacc different than just using the Atomic Simulation Environment (ASE)</p> <p>A: quacc is designed to supercharge ASE for the efficient design of high-throughput workflows. Quacc makes it possible to easily design complex ASE workflows that can be run on heterogeneous compute environments with modern workflow managers, such as Covalent and Jobflow. Quacc also makes it possible to combine ASE with the powerful Materials Project software stack, such as Custodian for on-the-fly error handling. For the database enthusiasts, quacc is interoperable with Maggma to store calculation results in a readily queryable format like MongoDB.</p> <p>Q: How is quacc different than Atomate2?</p> <p>A: Atomate2 is a fantastic code that can be used to run libraries of computational materials science workflows. Quacc was originally inspired by Atomate2 and can be thought of as a \"sister code\" to it. That said, there are some important differences.</p> <p>In Atomate2, workflows are built around the Materials Project software stack and are fundamentally incompatible with much of the Atomic Simulation Environment (ASE). In contrast, quacc was built around ASE from the ground up while still making it possible to leverage much of the software underlying the Materials Project, such as Custodian for automated error correction. Since quacc is built around ASE, it is also trivial to add new recipes based on any code that has an existing ASE Calculator even if it is not in quacc yet.</p> <p>Atomate2 is built around Jobflow. Quacc is predominantly built around Covalent first but also supports Jobflow.</p> <p>Atomate2 is a database-first approach to materials science workflows. Quacc is fully compatible with the use of databases but does not require them, with the goal of reducing the barrier to getting started.</p> <p>Atomate2 is developed and supported by the Materials Project team at Lawrence Berkeley National Laboratory. Quacc is developed and maintained by the Rosen Research Group at Princeton University.</p> <p>Despite these differences, quacc and Atomate2 are largely interoperable! Feel free to stitch together workflows from both codes as you see fit using Jobflow!</p> <p>Q: I see <code>@ct.electron</code> across the code. What if I don't want to use Covalent?</p> <p>A: The beauty is that you don't have to use Covalent if you don't want to! By default, the <code>@ct.electron</code> wrapper is entirely ignored if you use quacc without a workflow manager or if you use another workflow manager, such as Jobflow. For this reason, you can use most of the functions within quacc regardless of your choice of workflow manager.</p> <p>Q: I want to contribute a new recipe to quacc, but it will require additional dependencies. Is that a problem?</p> <p>A: Absolutely not a problem! Simply make your dependencies optional in the <code>pyproject.toml</code> file and use a <code>monty.dev.requires</code> decorator to ensure your recipes and tests only run if your necessary dependencies are installed. Refer to <code>quacc.recipes.tblite.core</code> and the <code>[tblite]</code> extras in the <code>pyproject.toml</code> file for an example.</p>"},{"location":"about/license.html","title":"License","text":"LICENSE.md<pre><code>BSD 3-Clause License\n\nCopyright (c) 2023, Andrew S. Rosen.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n- Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n- Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n- Neither the name of the copyright holder nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n</code></pre>"},{"location":"dev/contributing.html","title":"Contributing","text":""},{"location":"dev/contributing.html#general-tips","title":"General Tips","text":"<p>When developing new recipes, it is often helpful to start from an existing example. In general, we recommend referring to <code>quacc.recipes.emt</code> or <code>quacc.recipes.tblite</code>. Some advanced use cases can also be found in the VASP recipes.</p>"},{"location":"dev/contributing.html#steps-to-contribute","title":"Steps to Contribute","text":"<p>To contribute to quacc, we recommend doing the following:</p> <ul> <li> <p>Fork the repository to your personal GitHub account.</p> </li> <li> <p>Clone this forked repository to your local machine, e.g. via <code>git clone &lt;repo url&gt;.git</code>.</p> </li> <li> <p>In the newly downloaded <code>quacc</code> base directory, run <code>pip install -e .[dev]</code> to install quacc in editable mode and with the development dependencies.</p> </li> <li> <p>Commit your changes and push them to your personal forked repository.</p> </li> <li> <p>Create a pull request (PR) to merge your changes into the main quacc repository.</p> </li> </ul> <p>For reproducibility purposes, we strongly recommend installing quacc in a fresh virtual environment.</p>"},{"location":"dev/contributing.html#guidelines","title":"Guidelines","text":"<p>Please abide by the following guidelines when contributing code to quacc:</p> <ul> <li> <p>All changes should have associated unit tests that pass. Code coverage should be maintained.</p> </li> <li> <p>All code should include type hints and have internally consistent documentation for the inputs and outputs.</p> </li> <li> <p>The first positional argument to most compute jobs should be of type <code>Atoms | AtomsSchema</code>. The output of most compute tasks should be a schema from one of the module/functions within <code>quacc.schemas</code>.</p> </li> <li> <p>All inputs and outputs to recipes must be JSON (de)serializable (or have an <code>.as_dict()</code> and <code>.from_dict()</code> method, such that they are <code>MSONable</code>). This can be confirmed by running the following code snippet, where where <code>test_item</code> is the object you wish to test.</p> </li> </ul> <pre><code>from monty.json import MontyDecoder, jsanitize\nd = jsanitize(test_item, strict=True, enum_values=True)\nMontyDecoder().process_decoded(d)\n</code></pre> <ul> <li> <p>Only define multi-step workflows if they go beyond simply stitching together existing functions or if they are widely used in other recipes. Otherwise, just define the individual functions.</p> </li> <li> <p>Ensure that the code remains flexible for the user whenever possible.</p> </li> <li> <p>Where appropriate, you should use the \"internal\" geometry optimizers for a given code rather than the ASE optimizers.</p> </li> <li> <p><code>gzip</code> large test files to save space.</p> </li> <li> <p>Update the <code>CHANGELOG.md</code> file.</p> </li> <li> <p>Try to be cognizant of how many arguments your functions take.</p> </li> </ul>"},{"location":"dev/contributing.html#changelog","title":"Changelog","text":"<p>We keep a <code>CHANGELOG.md</code> file in the base directory of the quacc code. Before submitting your PR, be sure to update the <code>CHANGELOG.md</code> file under the \"Unreleased\" section with a brief description of your changes. The <code>CHANGELOG.md</code> file follows the Keep a Changelog format.</p>"},{"location":"dev/contributing.html#style-guidelines","title":"Style Guidelines","text":"<p>In general, please try to keep the code style consistent when possible. There are two main things to consider:</p> <ol> <li> <p>All Python code should be formatted with isort and then black, although this will be corrected automatically when merged.</p> </li> <li> <p>Use NumPy-style Docstrings.</p> </li> <li> <p>Address any relevant style issues raised by the \"Deepsource: Python\" and \"Sourcery\" GitHub actions, if present.</p> </li> <li> <p>Functions should be lowercase and with underscores. Classes should be in PascalCase and constructed using a <code>@dataclass</code> decorator where possible.</p> </li> </ol>"},{"location":"dev/contributing.html#unit-tests","title":"Unit Tests","text":"<p>All changes you make to quacc should be accompanied by unit tests and should not break existing tests. To run the full test suite, run <code>pytest .</code> from the the <code>quacc/tests</code> directory. Each PR will report the coverage once your tests pass, but if you'd like to generate a coverage report locally, you can use pytest-cov, such as by doing <code>pytest --cov=quacc .</code> in the <code>tests</code> directory.</p> <p>If you are adding recipes based on a code that can be readily installed via <code>pip</code> or <code>conda</code> (e.g. tblite, xtb-python, DFTB+, Psi4), then you can run these codes directly in the test suite. Preferably, you should use a small molecule or solid and cheap method so the unit tests run quickly. If the recipes you're adding are proprietary or not available via <code>pip</code> or <code>conda</code> (e.g. Gaussian, GULP), then you will need to monkeypatch certain functions to change their behavior during testing. For instance, we do not want to run VASP directly during unit tests and have mocked the <code>atoms.get_potential_energy()</code> function to always return a dummy value of -1.0 during unit tests. Any mocked functions can be found in the <code>conftest.py</code> files of the testing directory.</p>"},{"location":"dev/contributing.html#workflow-engines","title":"Workflow Engines","text":"<p>All individual compute tasks should be defined as simple functions decorated with <code>@ct.electron</code> even if you don't use Covalent, as the decorator will be ignored in such scenarios.</p> <p>For multi-step workflows, we prefer to have a corresponding Covalent-based definition in all cases, but in general, we will accept workflow recipes defined using any of the supported workflow engines described in the documentation since it is relatively trivial to interconvert between them. In short, please feel free to submit a PR for a recipe in whatever supported format you feel most comfortable with, and we will try to convert it to the default Covalent format if necessary.</p>"},{"location":"dev/docs.html","title":"Documentation","text":"<p>To install the dependencies to build the documentation, install the <code>[docs]</code> extras listed in <code>pyproject.toml</code>.</p> <p>The quacc documentation is built using Material for MkDocs. To build the documentation locally (e.g. to evaluate changes), run <code>mkdocs serve</code> in the base directory and open the URL shown in the terminal.</p>"},{"location":"install/codes.html","title":"Calculator Setup","text":"<p>Hint</p> <p>Just getting started? Try using the EMT or LJ recipes before worrying about setting up one of the calculators below.</p> <p>Here, we outline how to ensure that quacc can run the quantum chemistry package of your choosing. You only need to follow the instructions for the code(s) you intend to use.</p>"},{"location":"install/codes.html#dftb","title":"DFTB+","text":"<p>Note</p> <p>DFTB+ is especially useful for periodic GFN-xTB calculations and the DFTB+ method based on Slater-Koster parameters.</p> <p>If you plan to use DFTB+ with quacc, you will need to install the code via <code>conda install -c conda-forge dftbplus</code>.</p>"},{"location":"install/codes.html#emt","title":"EMT","text":"<p>Note</p> <p>Effective medium theory (EMT) is a semi-empirical method for modeling solids that is predominantly used for prototyping workflows. Because it is solely for demonstration purposes, it only supports the following metals: Al, Ni, Cu, Pd, Ag, Pt, and Au.</p> <p>No setup needed!</p>"},{"location":"install/codes.html#gaussian","title":"Gaussian","text":"<p>Note</p> <p>Gaussian is an extremely popular molecular DFT code that is quite robust and easy to use.</p> <p>As noted in the ASE documentation, you will need to define an environment variable named <code>ASE_GAUSSIAN_COMMAND</code>. It should be of the form <code>ASE_GAUSSIAN_COMMAND=\"/path/to/my/gaussian_executable Gaussian.com &gt; Gaussian.log\"</code>.</p>"},{"location":"install/codes.html#gulp","title":"GULP","text":"<p>Note</p> <p>GULP is especially useful for periodic GFN-FF calculations and force field methods. GULP can be downloaded and installed here.</p> <p>As noted in the ASE documentation, you must set the environment variables <code>GULP_LIB=\"/path/to/my/gulp-#.#.#/Libraries\"</code> and <code>ASE_GULP_COMMAND=\"/path/to/my/gulp-#.#.#/Src/gulp &lt; gulp.gin &gt; gulp.got\"</code> based on where you installed GULP.</p>"},{"location":"install/codes.html#lennard-jones","title":"Lennard Jones","text":"<p>Note</p> <p>Lennard Jones (LJ) is an empirical potential that is predominantly used for prototyping workflows for molecules.</p> <p>No setup needed!</p>"},{"location":"install/codes.html#orca","title":"ORCA","text":"<p>Note</p> <p>ORCA is a free code that is especially useful for molecular DFT calculations with recently developed methods. ORCA can be downloaded and installed here.</p> <p>To use quacc with ORCA, you will need to define the <code>ORCA_CMD</code> setting to be the full, absolute path to your ORCA executable. This can be done as described in the section on \"Modifying Quacc Settings\", such as by defining an environment variable <code>QUACC_ORCA_CMD=/path/to/my/orca/orca</code>.</p>"},{"location":"install/codes.html#psi4","title":"Psi4","text":"<p>Note</p> <p>Psi4 is an open-source quantum chemistry electronic structure package.</p> <p>If you plan to use Psi4 with quacc, you will need to install it prior to use. This can be done via <code>conda install -c psi4 psi4</code>.</p>"},{"location":"install/codes.html#tblite","title":"tblite","text":"<p>Note</p> <p>tblite is a code that interfaces with the xtb package for running GFN-xTB calculations.</p> <p>If you plan to use tblite with quacc, you will need to install the tblite interface with ASE support. This can be done via <code>pip install tblite[ase]</code> (available on Linux only).</p>"},{"location":"install/codes.html#vasp","title":"VASP","text":"<p>Note</p> <p>VASP is a very widely used code for plane-wave, periodic DFT calculations. Quacc has built-in support for automatically fixing failed VASP jobs via Custodian.</p> <p>To use VASP with quacc, you will need to do the following, as described in greater detail in the ASE documentation:</p> <ul> <li>Define the <code>VASP_PP_PATH</code> environment variable that points to your pseudopotential library. We recommend including this in your <code>~/.bashrc</code> file since this rarely changes.</li> <li>If you wish to use vdW functionals, define the <code>ASE_VASP_VDW</code> environment variable to point to the <code>vdw_kernel.bindat</code> file distributed with VASP. We recommend including this in your <code>~/.bashrc</code> file since this rarely changes.</li> </ul> <p>To run VASP with Custodian (the default behavior in quacc), you will also need to:</p> <ul> <li>Define a <code>QUACC_VASP_PARALLEL_CMD</code> environment variable that tells Custodian how to parallelize VASP. For instance, this might look something like <code>export QUACC_VASP_PARALLEL_CMD=\"srun -N 2 --ntasks-per-node 24\"</code>. Note, the VASP executables are not included in this environment variable. For convenience, we recommend specifying this environment variable at runtime so you can easily modify it.</li> <li>By default, Custodian will assume that the VASP executables can be run with <code>vasp_std</code> or <code>vasp_gam</code> for standard or gamma-point calculations. If you need to use different executable names or wish to change any other VASP-related settings from the selected defaults, refer to the section on \"Modifying Quacc Settings\".</li> </ul>"},{"location":"install/codes.html#other-codes","title":"Other Codes","text":"<p>For any other code, make sure to follow the instructions in ASE's documentation for setting up your desired calculator.</p>"},{"location":"install/config_db.html","title":"Database Setup","text":""},{"location":"install/config_db.html#introduction","title":"Introduction","text":"<p>Some users may wish to use quacc in way that ensures all calculation inputs and outputs are stored in an easily queryable database. While not a requirement, this can be readily achieved through the use of the maggma package. Maggma has many options for data stores.</p>"},{"location":"install/config_db.html#montydb","title":"MontyDB","text":"<p>The easiest option is to use the MontyDB store, which is an on-disk Mongo-style database. The best part is that all you have to do for setup is run <code>pip install montydb</code>.</p>"},{"location":"install/config_db.html#mongodb","title":"MongoDB","text":"<p>Note</p> <p>Users of NERSC HPC machines can instead request a database directly from NERSC staff.</p> <p>For the database enthusiasts, MongoDB is often preferred over a solution like MontyDB. The easiest route to create a Mongo database is via a cloud storage solution called MongoDB Atlas, which has a free tier. To set up your MongoDB with MongoDB Atlas, follow the instructions below:</p> <ol> <li>Sign up for a free account on MongoDB Atlas.</li> <li>Once logged in, select the \"Build a Database\" option under the \"Database Deployments\" section and choose the \"Shared\" free option.</li> <li>Select \"Create Cluster\" and enter your desired login credentials that will use to access your database. After waiting a minute or two, your cluster will be created, which is essentially a mini computer in the cloud.</li> <li>Go to the \"Collections\" tab of your cluster and create a new database. Give the database a unique name (e.g. \"LastName_db\") and create a collection where your quacc data will be stored (e.g. \"quacc\").</li> <li>Retrieve your MongoDB URI, which is the address of your MongoDB cluster. You can find your database's URI by clicking the \"Database\" section in the sidebar and then selecting \"Connect &gt; Connect Your Application &gt; Driver &gt; Python &gt; 3.11 or later\" and copying the link that appears. It will be of the form <code>mongodb+srv://&lt;username&gt;:&lt;password&gt;@&lt;host&gt;/&lt;database_name&gt;</code>. Don't forget to include the  at the end, which you selected in Step 4."},{"location":"install/install.html","title":"Installation","text":""},{"location":"install/install.html#pre-requisites","title":"Pre-Requisites","text":"<p>Note</p> <p>If you are on a Windows machine, you will need to install and use the Windows Subsystem for Linux (WSL).</p> <ol> <li>Install Python, preferably in conjunction with an environment manager. For instance, download and run the Miniconda installer</li> <li>When asked to add Miniconda to your <code>PATH</code>, select yes</li> <li>Create a fresh Python environment by running <code>conda create -n quacc python=3.10</code></li> <li>Activate this environment via <code>conda activate quacc</code></li> </ol>"},{"location":"install/install.html#installing-quacc","title":"Installing quacc","text":"<p>In your newly activated conda environment, run the following commands to install quacc. Note that you will need to install quacc on all machines where you plan to run calculations.</p> <pre><code># Install development version of quacc\npip install git+https://github.com/quantum-accelerators/quacc.git\n\n# Set default configuration parameters\nquacc config\n</code></pre> <p>Tip</p> <p>Everything beyond this point in the installation guide is to add on useful features to quacc. So, if you are just getting started, check out the Quacc Basics page. Then come back to installing additional features as you need them.</p>"},{"location":"install/install.html#optional-dependencies","title":"Optional Dependencies","text":"<p>Quacc can be installed with several \"extras,\" as outlined in the <code>pyproject.toml</code> file. These are described below.</p>"},{"location":"install/install.html#calculators","title":"Calculators","text":"<ul> <li><code>quacc[tblite]</code>: Installs dependencies to enable the use of tblite.</li> </ul>"},{"location":"install/install.html#workflow-managers","title":"Workflow Managers","text":"<ul> <li><code>quacc[fireworks]</code>: Installs dependencies to enable the use of FireWorks.</li> <li><code>quacc[parsl]</code>: Installs dependencies to enable the use of Parsl.</li> </ul>"},{"location":"install/install.html#miscellaneous","title":"Miscellaneous","text":"<ul> <li><code>quacc[optimizers]</code>: Installs additional ASE-based optimizers, such as Sella.</li> </ul>"},{"location":"install/install.html#development","title":"Development","text":"<ul> <li><code>quacc[dev]</code>: Installs dependencies to enable local development of quacc.</li> <li><code>quacc[docs]</code>: Installs dependencies to build the documentation.</li> <li><code>quacc[strict]</code>: Installs dependencies that match the test suite on GitHub.</li> </ul>"},{"location":"install/wflow_engines.html","title":"Workflow Engine Setup","text":"<p>Using a workflow engine is a crucial component for scaling up quacc calculations in a high-throughput setting. We describe the necessary installation steps here.</p> <p>Tip</p> <p>If you are just getting started with workflow engines, we recommend trying Covalent. For a comparison of the different compatible workflow engines, refer to the Workflow Engines Overview section.</p> CovalentParslJobflowFireWorks <p>Starting the Server</p> <p>Covalent uses a server to dispatch and store calculation details and results. To start the server, simply run <code>covalent start</code> in your terminal. It will return a URL that you can use to access the Covalent dashboard, which is shown below.</p> <p></p> <p>Tip</p> <p>Once you start scaling up your calculations, we recommend hosting the Covalent server on a dedicated machine or using Covalent Cloud. Refer to the Covalent Deployment Guide for details.</p> <p>Plugin Installation</p> <p>Depending on where you wish to run your quacc calculations, you may need to install the corresponding Covalent plugin, as described in the Covalent plugin documentation. For production-quality calculations, we anticipate that most users will rely on the <code>SlurmExecutor</code>, which can be installed via <code>pip install covalent-slurm-plugin</code>.</p> <p>Optional Configuration</p> <p>Covalent has several configuration options that can be modified. Running <code>quacc config</code> automatically takes care of setting the ones that are critical for quacc to run properly. If you ever delete your Covalent configuration (e.g. via <code>covalent purge</code>), you will need to re-run <code>quacc config</code>.</p> <p>Tip</p> <p>If you are using Perlmutter at NERSC, you will need to set <code>export COVALENT_CONFIG_DIR=\"$SCRATCH/.config/covalent\"</code> in your <code>~/.bashrc</code> because the home directory does not support file locking.</p> <p>Installation</p> <p>In your activated Python environment, install Parsl via <code>pip install parsl</code>. Parsl has many configuration options, which we will cover later in the documentation.</p> <p>MongoDB Setup</p> <p>Jobflow and FireWorks both require the use of a database to store calculation results. If you haven't done so already, first create a Mongo database as described in the \"MongoDB Setup\" section.</p> <p>Note</p> <p>If it is not possible to use MongoDB, you can use a variety of other data store options available within the maggma package, including a <code>MontyStore</code> that solely relies on the local filesystem.</p> <p>Jobflow DB Setup</p> <p>If you plan to use Jobflow to write your workflows, you will need to make a <code>jobflow.yaml</code> file. This file will generally be formatted like the example below. Fill in the fields with the appropriate values for your MongoDB cluster, which is where all your calculation inputs and outputs will be stored.</p> jobflow.yaml<pre><code>JOB_STORE:\ndocs_store:\ntype: MongoStore\nhost: &lt;host name&gt;\nport: 27017\nusername: &lt;username&gt;\npassword: &lt;password&gt;\ndatabase: &lt;database name&gt;\ncollection_name: &lt;collection name&gt;\n</code></pre> <p>Note</p> <p>If you are using a URI (as is common with MongoDB Atlas), then you will instead have a <code>jobflow.yaml</code> file that looks like the example below. Here, you will put the full URI in the <code>host</code> field. The <code>username</code> and <code>password</code> are part of the URI and so should not be included elsewhere in the YAML file.</p> jobflow.yaml<pre><code>JOB_STORE:\ndocs_store:\ntype: MongoStore\nhost: &lt;URI&gt;\nport: 27017\ndatabase: &lt;database name&gt;\ncollection_name: &lt;collection name&gt;\n</code></pre> <p>You will then need to define a <code>JOBFLOW_CONFIG_FILE</code> environment variable pointing to the file you made. For instance, in your <code>~/.bashrc</code> file, add the following line: <code>export JOBFLOW_CONFIG_FILE=\"/path/to/my/jobflow.yaml\"</code>.</p> <p>Installation</p> <p>To install quacc with support for FireWorks, run <code>pip install fireworks</code>.</p> <p>FireWorks DB Setup</p> <p>If you plan to use FireWorks to dispatch your Jobflow workflows, you will also need to make a few configuration files: <code>FW_config.yaml</code>, <code>my_fworker.yaml</code>, <code>my_launchpad.yaml</code>, and <code>my_qadapter.yaml</code>. To begin, make a directory called <code>fw_config</code> where you will store the four files described in greater detail below. The directory structure will look like the following:</p> <pre><code>fw_config\n\u251c\u2500\u2500 FW_config.yaml\n\u251c\u2500\u2500 my_fworker.yaml\n\u251c\u2500\u2500 my_launchpad.yaml\n\u2514\u2500\u2500 my_qadapter.yaml\n</code></pre> <p>FW Config File</p> <p>For the <code>FW_config.yaml</code>, you can use the following template. Make sure to update the path to the <code>fw_config</code> folder where the file resides.</p> FW_config.yaml<pre><code>CONFIG_FILE_DIR: &lt;/path/to/fw_config&gt;\nQUEUE_UPDATE_INTERVAL: 2\n</code></pre> <p>You will also need to define a <code>FW_CONFIG_FILE</code> environment variable pointing to the <code>FW_config.yaml</code> file you made. For instance, in your <code>~/.bashrc</code> file, add the following line: <code>export FW_CONFIG_FILE=\"/path/to/config/fw_config/FW_config.yaml\"</code>.</p> <p>FWorker</p> <p>For the <code>my_fworker.yaml</code>, you can use the following template. You do not need to make any modifications.</p> my_fworker.yaml<pre><code>name: quacc_fworker\ncategory: \"\"\nquery: \"{}\"\n</code></pre> <p>Launchpad</p> <p>For the <code>my_launchpad.yaml</code>, you can use the following template. Replace the entries in <code>&lt;&gt;</code> with the appropriate values for your Mongo database.</p> my_launchpad.yaml<pre><code>host: &lt;host name&gt;\nport: 27017\nname: &lt;database name&gt;\nusername: &lt;username&gt;\npassword: &lt;password&gt;\nlogdir: null\nIstrm_lvl: DEBUG\nuser_indices: []\nwf_user_indices: []\n</code></pre> <p>Note</p> <p>If you are accessing your MongoDB via a URI (e.g. as with MongoDB Atlas), then you will use the following <code>my_launchpad.yaml</code> template instead.</p> my_launchpad.yaml<pre><code>host: &lt;URI&gt;\nport: 27017\nname: &lt;database name&gt;\nuri_store: true\nlogdir: null\nIstrm_lvl: DEBUG\nuser_indices: []\nwf_user_indices: []\n</code></pre> <p>QAdapter</p> <p>Assuming you plan to use a queuing system for your compute jobs, you will need to make a <code>my_qadapter.yaml</code> file. For this, you will need to follow the instructions in the FireWorks documentation for your specific job scheduling system. An example <code>my_qadapter.yaml</code> file is shown below for Slurm.</p> my_qadapter.yaml<pre><code>_fw_name: CommonAdapter\n_fw_q_type: SLURM\nrocket_launch: rlaunch -w /path/to/fw_config/my_fworker.yaml singleshot\nnodes: 2\nwalltime: 00:30:00\naccount: &lt;account&gt;\njob_name: quacc_firework\nqos: regular\npre_rocket: |\nmodule load vasp\nexport QUACC_VASP_PARALLEL_CMD=\"srun -N 2 --ntasks-per-node=24 --cpu_bind=cores\"\n</code></pre> <p>In the above example, you would need to change the path in the <code>rocket_launch</code> field to the correct path to your <code>my_fworker.yaml</code>. The nodes, walltime, account, and qos are the corresponding parameters for your queuing system. Finally, anything in the <code>pre_rocket</code> field will be executed before the job begins running. It is a good place to load modules and set environment variables. A representative example has been provided above.</p> <p>Database Initialization</p> <p>Warning</p> <p>Running <code>lpad reset</code> will clear your FireWorks launchpad, so only use this command if you are a new user.</p> <p>To check that everything is working right with FireWorks, run <code>lpad reset</code> to ensure there is a connection to the database.</p>"},{"location":"reference/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>quacc<ul> <li>calculators<ul> <li>vasp</li> </ul> </li> <li>custodian<ul> <li>vasp</li> </ul> </li> <li>recipes<ul> <li>dftb<ul> <li>core</li> </ul> </li> <li>emt<ul> <li>core</li> <li>jobflow<ul> <li>slabs</li> </ul> </li> <li>parsl<ul> <li>slabs</li> </ul> </li> <li>slabs</li> </ul> </li> <li>gaussian<ul> <li>core</li> </ul> </li> <li>gulp<ul> <li>core</li> </ul> </li> <li>lj<ul> <li>core</li> </ul> </li> <li>orca<ul> <li>core</li> </ul> </li> <li>psi4<ul> <li>core</li> </ul> </li> <li>tblite<ul> <li>core</li> </ul> </li> <li>vasp<ul> <li>core</li> <li>mp</li> <li>qmof</li> <li>slabs</li> </ul> </li> </ul> </li> <li>schemas<ul> <li>ase</li> <li>atoms</li> <li>cclib</li> <li>vasp</li> </ul> </li> <li>settings</li> <li>util<ul> <li>atoms</li> <li>calc</li> <li>db</li> <li>dicts</li> <li>files</li> <li>pop_analysis</li> <li>slabs</li> <li>thermo</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/quacc/settings.html","title":"settings","text":"<p>Settings for quacc</p>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings","title":"QuaccSettings","text":"<p>         Bases: <code>BaseSettings</code></p> <p>Settings for quacc.</p> <p>The default way to modify these is to make a ~/.quacc.yaml file. Alternatively, the environment variable QUACC_CONFIG_FILE can be set to point to a yaml file with quacc settings.</p> <p>The variables can also be modified individually though environment variables by using the \"QUACC\" prefix. e.g. QUACC_SCRATCH_DIR=/path/to/scratch.</p>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.Config","title":"Config","text":"<p>Pydantic config settings.</p>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.load_default_settings","title":"load_default_settings","text":"<pre><code>load_default_settings(values)\n</code></pre> <p>Loads settings from a root file if available and uses that as defaults in place of built in defaults.</p> <p>Parameters:</p> <ul> <li> values             (<code>dict</code>)         \u2013          <p>Settings to load.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Loaded settings.</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/settings.py</code> <pre><code>@root_validator(pre=True)\ndef load_default_settings(cls, values: dict) -&gt; dict:\n\"\"\"\n    Loads settings from a root file if available and uses that as defaults in\n    place of built in defaults.\n    Parameters\n    ----------\n    values\n        Settings to load.\n    Returns\n    -------\n    dict\n        Loaded settings.\n    \"\"\"\nfrom pathlib import Path\nfrom monty.serialization import loadfn\nconfig_file_path = values.get(\"CONFIG_FILE\", _DEFAULT_CONFIG_FILE_PATH)\nnew_values = {}\nif Path(config_file_path).expanduser().exists():\nnew_values |= loadfn(Path(config_file_path).expanduser())\nnew_values.update(values)\nreturn new_values\n</code></pre>"},{"location":"reference/quacc/calculators/vasp.html","title":"vasp","text":"<p>A wrapper around ASE's Vasp calculator that makes it better suited for high-throughput DFT.</p>"},{"location":"reference/quacc/calculators/vasp.html#quacc.calculators.vasp.Vasp","title":"Vasp","text":"<pre><code>Vasp(input_atoms, preset=None, use_custodian=None, incar_copilot=None, copy_magmoms=None, preset_mag_default=None, mag_cutoff=None, verbose=None, **kwargs)\n</code></pre> <p>         Bases: <code>Vasp_</code></p> <p>This is a wrapper around the ASE Vasp calculator that adjusts INCAR parameters on-the-fly, allows for ASE to run VASP via Custodian, and supports several automatic k-point generation schemes from Pymatgen.</p> <p>Parameters:</p> <ul> <li> input_atoms             (<code>Atoms</code>)         \u2013          <p>The input Atoms object to be used for the calculation.</p> </li> <li> preset             (<code>None | str</code>)         \u2013          <p>The name of a YAML file containing a list of INCAR parameters to use as a \"preset\" for the calculator. quacc will automatically look in the <code>VASP_PRESET_DIR</code> (default: quacc/presets/vasp) for the file, such that preset=\"BulkSet\" is supported, for instance. The .yaml extension is not necessary. Any user-suppplied calculator **kwargs will override any corresponding preset values.</p> </li> <li> use_custodian             (<code>bool | None</code>)         \u2013          <p>Whether to use Custodian to run VASP. Default is True in settings.</p> </li> <li> incar_copilot             (<code>bool | None</code>)         \u2013          <p>If True, the INCAR parameters will be adjusted if they go against the VASP manual. Default is True in settings.</p> </li> <li> copy_magmoms             (<code>bool | None</code>)         \u2013          <p>If True, any pre-existing <code>atoms.get_magnetic_moments()</code> will be set in <code>atoms.set_initial_magnetic_moments()</code>. Set this to False if you want to use a preset's magnetic moments every time.</p> </li> <li> preset_mag_default             (<code>float | None</code>)         \u2013          <p>Default magmom value for sites without one explicitly specified in the preset. Only used if a preset is specified with an elemental_mags_dict key-value pair. Default is 1.0 in settings.</p> </li> <li> mag_cutoff             (<code>None | float</code>)         \u2013          <p>Set all initial magmoms to 0 if all have a magnitude below this value. Default is 0.05 in settings.</p> </li> <li> verbose             (<code>bool | None</code>)         \u2013          <p>If True, warnings will be raised when INCAR parameters are automatically changed. Default is True in settings.</p> </li> <li> **kwargs         \u2013          <p>Additional arguments to be passed to the VASP calculator, e.g. <code>xc='PBE'</code>, <code>encut=520</code>. Takes all valid ASE calculator arguments, in addition to those custom to quacc.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>         \u2013          <p>The ASE Atoms object with attached VASP calculator.</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/calculators/vasp.py</code> <pre><code>def __init__(\nself,\ninput_atoms: Atoms,\npreset: None | str = None,\nuse_custodian: bool | None = None,\nincar_copilot: bool | None = None,\ncopy_magmoms: bool | None = None,\npreset_mag_default: float | None = None,\nmag_cutoff: None | float = None,\nverbose: bool | None = None,\n**kwargs,\n):\n# Set defaults\nuse_custodian = (\nSETTINGS.VASP_USE_CUSTODIAN if use_custodian is None else use_custodian\n)\nincar_copilot = (\nSETTINGS.VASP_INCAR_COPILOT if incar_copilot is None else incar_copilot\n)\ncopy_magmoms = (\nSETTINGS.VASP_COPY_MAGMOMS if copy_magmoms is None else copy_magmoms\n)\npreset_mag_default = (\nSETTINGS.VASP_PRESET_MAG_DEFAULT\nif preset_mag_default is None\nelse preset_mag_default\n)\nmag_cutoff = SETTINGS.VASP_MAG_CUTOFF if mag_cutoff is None else mag_cutoff\nverbose = SETTINGS.VASP_VERBOSE if verbose is None else verbose\n# Assign variables to self\nself.input_atoms = input_atoms\nself.preset = preset\nself.use_custodian = use_custodian\nself.incar_copilot = incar_copilot\nself.copy_magmoms = copy_magmoms\nself.preset_mag_default = preset_mag_default\nself.mag_cutoff = mag_cutoff\nself.verbose = verbose\nself.kwargs = kwargs\n# Check constraints\nif (\nuse_custodian\nand input_atoms.constraints\nand not all(isinstance(c, FixAtoms) for c in input_atoms.constraints)\n):\nraise ValueError(\n\"Atoms object has a constraint that is not compatible with Custodian. Set use_custodian = False.\"\n)\n# Get VASP executable command, if necessary, and specify child environment\n# variables\ncommand = self._manage_environment()\n# Get user-defined preset parameters for the calculator\nif preset:\ncalc_preset = load_yaml_calc(\nos.path.join(SETTINGS.VASP_PRESET_DIR, preset)\n)[\"inputs\"]\nelse:\ncalc_preset = {}\n# Collect all the calculator parameters and prioritize the kwargs\n# in the case of duplicates.\nself.user_calc_params = calc_preset | kwargs\nnone_keys = [k for k, v in self.user_calc_params.items() if v is None]\nfor none_key in none_keys:\ndel self.user_calc_params[none_key]\n# Allow the user to use setups='mysetups.yaml' to load in a custom setups\n# from a YAML file\nif (\nisinstance(self.user_calc_params.get(\"setups\"), str)\nand self.user_calc_params[\"setups\"] not in ase_setups.setups_defaults\n):\nself.user_calc_params[\"setups\"] = load_yaml_calc(\nos.path.join(SETTINGS.VASP_PRESET_DIR, self.user_calc_params[\"setups\"])\n)[\"inputs\"][\"setups\"]\n# If the preset has auto_kpts but the user explicitly requests kpts, then\n# we should honor that.\nif kwargs.get(\"kpts\") and calc_preset.get(\"auto_kpts\"):\ndel self.user_calc_params[\"auto_kpts\"]\n# Handle special arguments in the user calc parameters that\n# ASE does not natively support\nif self.user_calc_params.get(\"elemental_magmoms\"):\nelemental_mags_dict = self.user_calc_params[\"elemental_magmoms\"]\nelse:\nelemental_mags_dict = None\nif self.user_calc_params.get(\"auto_kpts\"):\nauto_kpts = self.user_calc_params[\"auto_kpts\"]\nelse:\nauto_kpts = None\nif self.user_calc_params.get(\"auto_dipole\"):\nauto_dipole = self.user_calc_params[\"auto_dipole\"]\nelse:\nauto_dipole = None\nself.user_calc_params.pop(\"elemental_magmoms\", None)\nself.user_calc_params.pop(\"auto_kpts\", None)\nself.user_calc_params.pop(\"auto_dipole\", None)\n# Make automatic k-point mesh\nif auto_kpts:\nkpts, gamma, reciprocal = self._convert_auto_kpts(auto_kpts)\nself.user_calc_params[\"kpts\"] = kpts\nif reciprocal and self.user_calc_params.get(\"reciprocal\") is None:\nself.user_calc_params[\"reciprocal\"] = reciprocal\nif self.user_calc_params.get(\"gamma\") is None:\nself.user_calc_params[\"gamma\"] = gamma\n# Add dipole corrections if requested\nif auto_dipole:\ncom = input_atoms.get_center_of_mass(scaled=True)\nif \"dipol\" not in self.user_calc_params:\nself.user_calc_params[\"dipol\"] = com\nif \"idipol\" not in self.user_calc_params:\nself.user_calc_params[\"idipol\"] = 3\nif \"ldipol\" not in self.user_calc_params:\nself.user_calc_params[\"ldipol\"] = True\n# Set magnetic moments\nset_magmoms(\ninput_atoms,\nelemental_mags_dict=elemental_mags_dict,\ncopy_magmoms=copy_magmoms,\nelemental_mags_default=preset_mag_default,\nmag_cutoff=mag_cutoff,\n)\n# Handle INCAR swaps as needed\nif incar_copilot:\nself.user_calc_params = self._calc_swaps(auto_kpts=auto_kpts)\n# Remove unused INCAR flags\nself.user_calc_params = self._remove_unused_flags()\n# Instantiate the calculator!\nsuper().__init__(atoms=input_atoms, command=command, **self.user_calc_params)\n</code></pre>"},{"location":"reference/quacc/custodian/vasp.html","title":"vasp","text":"<p>Custodian handlers for VASP</p>"},{"location":"reference/quacc/custodian/vasp.html#quacc.custodian.vasp.run_custodian","title":"run_custodian","text":"<pre><code>run_custodian(vasp_parallel_cmd=None, vasp_cmd=None, vasp_gamma_cmd=None, vasp_custodian_max_errors=None, vasp_custodian_wall_time=None, vtst_fixes=None, vasp_custodian_handlers=None, vasp_custodian_validators=None, scratch_dir=None, vasp_job_kwargs=None, custodian_kwargs=None)\n</code></pre> <p>Function to run VASP Custodian</p> <p>Parameters:</p> <ul> <li> vasp_parallel_cmd             (<code>str | None</code>)         \u2013          <p>VASP parallel command, e.g. \"srun -N 2 --ntasks-per-node=24\". Defaults to the $VASP_PARALLEL_CMD environment variable in settings.</p> </li> <li> vasp_cmd             (<code>str | None</code>)         \u2013          <p>VASP command. Defaults to \"vasp_std\" in settings.</p> </li> <li> vasp_gamma_cmd             (<code>str | None</code>)         \u2013          <p>VASP gamma command. Defaults to vasp_gam in settings.</p> </li> <li> vasp_custodian_max_errors             (<code>int | None</code>)         \u2013          <p>Maximum number of errors to allow before stopping the run. Defaults to 5 in settings.</p> </li> <li> vasp_custodian_wall_time             (<code>float | None</code>)         \u2013          <p>Maximum wall time to allow before creating a STOPCAR. Defaults to infinity in settings.</p> </li> <li> vtst_fixes             (<code>bool | None</code>)         \u2013          <p>Whether to apply VTST input swaps. Defaults to False in settings.</p> </li> <li> vasp_custodian_handlers             (<code>list[str] | None</code>)         \u2013          <p>List of handlers to use in Custodian. See settings for list.</p> </li> <li> vasp_custodian_validators             (<code>list[str] | None</code>)         \u2013          <p>List of validators to use in Custodian. See settings for list.</p> </li> <li> scratch_dir             (<code>str | None</code>)         \u2013          <p>Scratch directory to use. Defaults to None.</p> </li> <li> vasp_job_kwargs             (<code>dict | None</code>)         \u2013          <p>Keyword arguments to pass to the Custodian VaspJob. Defaults to None.</p> </li> <li> custodian_kwargs             (<code>dict | None</code>)         \u2013          <p>Any remaining keyword arguments to pass to Custodian. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/custodian/vasp.py</code> <pre><code>def run_custodian(\nvasp_parallel_cmd: str | None = None,\nvasp_cmd: str | None = None,\nvasp_gamma_cmd: str | None = None,\nvasp_custodian_max_errors: int | None = None,\nvasp_custodian_wall_time: float | None = None,\nvtst_fixes: bool | None = None,\nvasp_custodian_handlers: list[str] | None = None,\nvasp_custodian_validators: list[str] | None = None,\nscratch_dir: str | None = None,\nvasp_job_kwargs: dict | None = None,\ncustodian_kwargs: dict | None = None,\n) -&gt; None:\n\"\"\"\n    Function to run VASP Custodian\n    Parameters\n    ----------\n    vasp_parallel_cmd\n        VASP parallel command, e.g. \"srun -N 2 --ntasks-per-node=24\". Defaults to the $VASP_PARALLEL_CMD\n        environment variable in settings.\n    vasp_cmd\n        VASP command. Defaults to \"vasp_std\" in settings.\n    vasp_gamma_cmd\n        VASP gamma command. Defaults to vasp_gam in settings.\n    vasp_custodian_max_errors\n        Maximum number of errors to allow before stopping the run. Defaults to 5 in settings.\n    vasp_custodian_wall_time\n        Maximum wall time to allow before creating a STOPCAR. Defaults to infinity in settings.\n    vtst_fixes\n        Whether to apply VTST input swaps. Defaults to False in settings.\n    vasp_custodian_handlers\n        List of handlers to use in Custodian. See settings for list.\n    vasp_custodian_validators\n        List of validators to use in Custodian. See settings for list.\n    scratch_dir\n        Scratch directory to use. Defaults to None.\n    vasp_job_kwargs\n        Keyword arguments to pass to the Custodian VaspJob. Defaults to None.\n    custodian_kwargs\n        Any remaining keyword arguments to pass to Custodian. Defaults to None.\n    Returns\n    -------\n    None\n    \"\"\"\n# Adapted from atomate2.vasp.run.run_vasp\n# Set defaults\nvasp_parallel_cmd = os.path.expandvars(\nSETTINGS.VASP_PARALLEL_CMD if vasp_parallel_cmd is None else vasp_parallel_cmd\n)\nvasp_cmd = SETTINGS.VASP_CMD if vasp_cmd is None else vasp_cmd\nvasp_gamma_cmd = (\nSETTINGS.VASP_GAMMA_CMD if vasp_gamma_cmd is None else vasp_gamma_cmd\n)\nvasp_custodian_max_errors = (\nSETTINGS.VASP_CUSTODIAN_MAX_ERRORS\nif vasp_custodian_max_errors is None\nelse vasp_custodian_max_errors\n)\nvasp_custodian_wall_time = (\nSETTINGS.VASP_CUSTODIAN_WALL_TIME\nif vasp_custodian_wall_time is None\nelse vasp_custodian_wall_time\n)\nvtst_fixes = SETTINGS.VASP_CUSTODIAN_VTST if vtst_fixes is None else vtst_fixes\nvasp_custodian_handlers = (\nSETTINGS.VASP_CUSTODIAN_HANDLERS\nif vasp_custodian_handlers is None\nelse vasp_custodian_handlers\n)\nvasp_custodian_validators = (\nSETTINGS.VASP_CUSTODIAN_VALIDATORS\nif vasp_custodian_validators is None\nelse vasp_custodian_validators\n)\n# Handlers for VASP\nhandlers = []\nhandlers_dict = {\n\"VaspErrorHandler\": VaspErrorHandler(vtst_fixes=vtst_fixes),\n\"FrozenJobErrorHandler\": FrozenJobErrorHandler(),\n\"IncorrectSmearingHandler\": IncorrectSmearingHandler(),\n\"LargeSigmaHandler\": LargeSigmaHandler(),\n\"MeshSymmetryErrorHandler\": MeshSymmetryErrorHandler(),\n\"NonConvergingErrorHandler\": NonConvergingErrorHandler(),\n\"PositiveEnergyErrorHandler\": PositiveEnergyErrorHandler(),\n\"PotimErrorHandler\": PotimErrorHandler(),\n\"StdErrHandler\": StdErrHandler(),\n\"UnconvergedErrorHandler\": UnconvergedErrorHandler(),\n\"WalltimeHandler\": WalltimeHandler(),\n\"ScanMetalHandler\": ScanMetalHandler(),\n}\nvalidators_dict = {\n\"VaspFilesValidator\": VaspFilesValidator(),\n\"VasprunXMLValidator\": VasprunXMLValidator(),\n}\nhandlers = []\nfor handler_flag in vasp_custodian_handlers:\nif handler_flag not in handlers_dict:\nraise ValueError(f\"Unknown VASP error handler: {handler_flag}\")\nhandlers.append(handlers_dict[handler_flag])\nvalidators = []\nfor validator_flag in vasp_custodian_validators:\nif validator_flag not in validators_dict:\nraise ValueError(f\"Unknown VASP validator: {validator_flag}\")\nvalidators.append(validators_dict[validator_flag])\n# Populate settings\nvasp_cmd = f\"{vasp_parallel_cmd} {vasp_cmd}\"\nvasp_gamma_cmd = f\"{vasp_parallel_cmd} {vasp_gamma_cmd}\"\n# Run VASP\nvasp_job_kwargs = {} if vasp_job_kwargs is None else vasp_job_kwargs\ncustodian_kwargs = {} if custodian_kwargs is None else custodian_kwargs\nsplit_vasp_cmd = shlex.split(vasp_cmd)\nsplit_vasp_gamma_cmd = shlex.split(vasp_gamma_cmd)\nvasp_job_kwargs[\"gamma_vasp_cmd\"] = split_vasp_gamma_cmd\n# Run with Custodian\njobs = [VaspJob(split_vasp_cmd, **vasp_job_kwargs)]\nif vasp_custodian_wall_time:\nhandlers = list(handlers) + [\nWalltimeHandler(wall_time=vasp_custodian_wall_time)\n]\nc = Custodian(\nhandlers,\njobs,\nvalidators=validators,\nmax_errors=vasp_custodian_max_errors,\nscratch_dir=scratch_dir,\n**custodian_kwargs,\n)\nc.run()\n</code></pre>"},{"location":"reference/quacc/recipes/dftb/core.html","title":"core","text":"<p>Core recipes for DFTB+</p>"},{"location":"reference/quacc/recipes/dftb/core.html#quacc.recipes.dftb.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(atoms, method='GFN2-xTB', kpts=None, lattice_opt=False, calc_swaps=None)\n</code></pre> <p>Carry out a structure relaxation.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> method             (<code>Literal['GFN1-xTB', 'GFN2-xTB', 'DFTB']</code>)         \u2013          <p>Method to use.</p> </li> <li> kpts             (<code>tuple | list[tuple] | dict | None</code>)         \u2013          <p>k-point grid to use. Defaults to None for molecules and (1, 1, 1) for solids.</p> </li> <li> lattice_opt             (<code>bool</code>)         \u2013          <p>Whether to relax the unit cell shape/volume in addition to the positions.</p> </li> <li> calc_swaps             (<code>dict | None</code>)         \u2013          <p>Dictionary of custom kwargs for the calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from <code>quacc.schemas.ase.summarize_run</code></p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/dftb/core.py</code> <pre><code>@ct.electron\ndef relax_job(\natoms: Atoms | dict,\nmethod: Literal[\"GFN1-xTB\", \"GFN2-xTB\", \"DFTB\"] = \"GFN2-xTB\",\nkpts: tuple | list[tuple] | dict | None = None,\nlattice_opt: bool = False,\ncalc_swaps: dict | None = None,\n) -&gt; RunSchema:\n\"\"\"\n    Carry out a structure relaxation.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    method\n        Method to use.\n    kpts\n        k-point grid to use. Defaults to None for molecules and\n        (1, 1, 1) for solids.\n    lattice_opt\n        Whether to relax the unit cell shape/volume in addition to\n        the positions.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator.\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from `quacc.schemas.ase.summarize_run`\n    \"\"\"\natoms = atoms if isinstance(atoms, Atoms) else atoms[\"atoms\"]\ncalc_swaps = calc_swaps or {}\ndefaults = {\n\"Hamiltonian_\": \"xTB\" if \"xtb\" in method.lower() else \"DFTB\",\n\"Hamiltonian_Method\": method if \"xtb\" in method.lower() else None,\n\"kpts\": kpts or ((1, 1, 1) if atoms.pbc.any() else None),\n\"Driver_\": \"GeometryOptimization\",\n\"Driver_LatticeOpt\": \"Yes\" if lattice_opt else \"No\",\n\"Driver_AppendGeometries\": \"Yes\",\n\"Driver_MaxSteps\": 2000,\n}\nflags = remove_dict_empties(defaults | calc_swaps)\natoms.calc = Dftb(**flags)\nfinal_atoms = run_calc(atoms, geom_file=GEOM_FILE)\nif not check_logfile(LOG_FILE, \"Geometry converged\"):\nraise ValueError(\"Geometry did not converge\")\nreturn summarize_run(\nfinal_atoms,\ninput_atoms=atoms,\nadditional_fields={\"name\": \"DFTB+ Relax\"},\n)\n</code></pre>"},{"location":"reference/quacc/recipes/dftb/core.html#quacc.recipes.dftb.core.static_job","title":"static_job","text":"<pre><code>static_job(atoms, method='GFN2-xTB', kpts=None, calc_swaps=None)\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> method             (<code>Literal['GFN1-xTB', 'GFN2-xTB', 'DFTB']</code>)         \u2013          <p>Method to use.</p> </li> <li> kpts             (<code>tuple | list[tuple] | dict | None</code>)         \u2013          <p>k-point grid to use. Defaults to None for molecules and (1, 1, 1) for solids.</p> </li> <li> calc_swaps             (<code>dict | None</code>)         \u2013          <p>Dictionary of custom kwargs for the calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from <code>quacc.schemas.ase.summarize_run</code></p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/dftb/core.py</code> <pre><code>@ct.electron\ndef static_job(\natoms: Atoms | dict,\nmethod: Literal[\"GFN1-xTB\", \"GFN2-xTB\", \"DFTB\"] = \"GFN2-xTB\",\nkpts: tuple | list[tuple] | dict | None = None,\ncalc_swaps: dict | None = None,\n) -&gt; RunSchema:\n\"\"\"\n    Carry out a single-point calculation.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    method\n        Method to use.\n    kpts\n        k-point grid to use. Defaults to None for molecules and\n        (1, 1, 1) for solids.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator.\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from `quacc.schemas.ase.summarize_run`\n    \"\"\"\natoms = atoms if isinstance(atoms, Atoms) else atoms[\"atoms\"]\ncalc_swaps = calc_swaps or {}\ndefaults = {\n\"Hamiltonian_\": \"xTB\" if \"xtb\" in method.lower() else \"DFTB\",\n\"Hamiltonian_Method\": method if \"xtb\" in method.lower() else None,\n\"kpts\": kpts or ((1, 1, 1) if atoms.pbc.any() else None),\n}\nflags = remove_dict_empties(defaults | calc_swaps)\natoms.calc = Dftb(**flags)\nfinal_atoms = run_calc(atoms, geom_file=GEOM_FILE)\nif check_logfile(LOG_FILE, \"SCC is NOT converged\"):\nraise ValueError(\"SCC is not converged\")\nreturn summarize_run(\nfinal_atoms,\ninput_atoms=atoms,\nadditional_fields={\"name\": \"DFTB+ Static\"},\n)\n</code></pre>"},{"location":"reference/quacc/recipes/emt/core.html","title":"core","text":"<p>Core recipes for EMT</p> <p>NOTE: This set of minimal recipes is mainly for demonstration purposes.</p>"},{"location":"reference/quacc/recipes/emt/core.html#quacc.recipes.emt.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(atoms, relax_cell=True, calc_kwargs=None, opt_swaps=None)\n</code></pre> <p>Carry out a geometry optimization.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> relax_cell             (<code>bool</code>)         \u2013          <p>Whether to relax the cell</p> </li> <li> calc_kwargs             (<code>dict | None</code>)         \u2013          <p>Dictionary of custom kwargs for the EMT calculator</p> </li> <li> opt_swaps             (<code>dict | None</code>)         \u2013          <p>Dictionary of swaps for <code>run_ase_opt</code></p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_opt_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/emt/core.py</code> <pre><code>@ct.electron\ndef relax_job(\natoms: Atoms | dict,\nrelax_cell: bool = True,\ncalc_kwargs: dict | None = None,\nopt_swaps: dict | None = None,\n) -&gt; OptSchema:\n\"\"\"\n    Carry out a geometry optimization.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    relax_cell\n        Whether to relax the cell\n    calc_kwargs\n        Dictionary of custom kwargs for the EMT calculator\n    opt_swaps\n        Dictionary of swaps for `run_ase_opt`\n    Returns\n    -------\n    OptSchema\n        Dictionary of results from quacc.schemas.ase.summarize_opt_run\n    \"\"\"\natoms = atoms if isinstance(atoms, Atoms) else atoms[\"atoms\"]\ncalc_kwargs = calc_kwargs or {}\nopt_swaps = opt_swaps or {}\nopt_defaults = {\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": FIRE}\nopt_flags = opt_defaults | opt_swaps\nif relax_cell and not atoms.pbc.any():\nwarnings.warn(\n\"Volume relaxation requested but no PBCs found. Ignoring.\", UserWarning\n)\nrelax_cell = False\natoms.calc = EMT(**calc_kwargs)\nif relax_cell:\natoms = ExpCellFilter(atoms)\ndyn = run_ase_opt(atoms, **opt_flags)\nreturn summarize_opt_run(dyn, additional_fields={\"name\": \"EMT Relax\"})\n</code></pre>"},{"location":"reference/quacc/recipes/emt/core.html#quacc.recipes.emt.core.static_job","title":"static_job","text":"<pre><code>static_job(atoms, calc_kwargs=None)\n</code></pre> <p>Carry out a static calculation.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> calc_kwargs             (<code>dict | None</code>)         \u2013          <p>Dictionary of custom kwargs for the EMT calculator</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from <code>quacc.schemas.ase.summarize_run</code></p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/emt/core.py</code> <pre><code>@ct.electron\ndef static_job(atoms: Atoms | dict, calc_kwargs: dict | None = None) -&gt; RunSchema:\n\"\"\"\n    Carry out a static calculation.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    calc_kwargs\n        Dictionary of custom kwargs for the EMT calculator\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from `quacc.schemas.ase.summarize_run`\n    \"\"\"\natoms = atoms if isinstance(atoms, Atoms) else atoms[\"atoms\"]\ncalc_kwargs = calc_kwargs or {}\natoms.calc = EMT(**calc_kwargs)\nfinal_atoms = run_calc(atoms)\nreturn summarize_run(\nfinal_atoms,\ninput_atoms=atoms,\nadditional_fields={\"name\": \"EMT Static\"},\n)\n</code></pre>"},{"location":"reference/quacc/recipes/emt/slabs.html","title":"slabs","text":"<p>Slab recipes for EMT</p>"},{"location":"reference/quacc/recipes/emt/slabs.html#quacc.recipes.emt.slabs.bulk_to_slabs_flow","title":"bulk_to_slabs_flow","text":"<pre><code>bulk_to_slabs_flow(atoms, slabgen_kwargs=None, slab_relax_electron=relax_job, slab_static_electron=static_job, slab_relax_kwargs=None, slab_static_kwargs=None)\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>Slab generation</p> </li> <li> <p>Slab relaxations</p> </li> <li> <p>Slab statics (optional)</p> </li> </ol> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> slabgen_kwargs             (<code>dict | None</code>)         \u2013          <p>Additional keyword arguments to pass to make_max_slabs_from_bulk()</p> </li> <li> slab_relax_electron             (<code>ct.electron</code>)         \u2013          <p>Default Electron to use for the relaxation of the slab structures.</p> </li> <li> slab_static_electron             (<code>ct.electron | None</code>)         \u2013          <p>Default Electron to use for the static calculation of the slab structures.</p> </li> <li> slab_relax_kwargs             (<code>dict | None</code>)         \u2013          <p>Additional keyword arguments to pass to the relaxation calculation.</p> </li> <li> slab_static_kwargs             (<code>dict | None</code>)         \u2013          <p>Additional keyword arguments to pass to the static calculation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>         \u2013          <p>List of dictionary of results from quacc.schemas.ase.summarize_run or quacc.schemas.ase.summarize_opt_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/emt/slabs.py</code> <pre><code>def bulk_to_slabs_flow(\natoms: Atoms | dict,\nslabgen_kwargs: dict | None = None,\nslab_relax_electron: ct.electron = relax_job,\nslab_static_electron: ct.electron | None = static_job,\nslab_relax_kwargs: dict | None = None,\nslab_static_kwargs: dict | None = None,\n) -&gt; list[RunSchema | OptSchema]:\n\"\"\"\n    Workflow consisting of:\n    1. Slab generation\n    2. Slab relaxations\n    3. Slab statics (optional)\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    slabgen_kwargs\n        Additional keyword arguments to pass to make_max_slabs_from_bulk()\n    slab_relax_electron\n        Default Electron to use for the relaxation of the slab structures.\n    slab_static_electron\n        Default Electron to use for the static calculation of the slab structures.\n    slab_relax_kwargs\n        Additional keyword arguments to pass to the relaxation calculation.\n    slab_static_kwargs\n        Additional keyword arguments to pass to the static calculation.\n    Returns\n    -------\n    list[dict]\n        List of dictionary of results from quacc.schemas.ase.summarize_run or quacc.schemas.ase.summarize_opt_run\n    \"\"\"\natoms = atoms if isinstance(atoms, Atoms) else atoms[\"atoms\"]\nslab_relax_kwargs = slab_relax_kwargs or {}\nslab_static_kwargs = slab_static_kwargs or {}\nslabgen_kwargs = slabgen_kwargs or {}\nif \"relax_cell\" not in slab_relax_kwargs:\nslab_relax_kwargs[\"relax_cell\"] = False\n@ct.electron\n@ct.lattice\ndef _relax_distributed(slabs):\nreturn [slab_relax_electron(slab, **slab_relax_kwargs) for slab in slabs]\n@ct.electron\n@ct.lattice\ndef _relax_and_static_distributed(slabs):\nreturn [\nslab_static_electron(\nslab_relax_electron(slab, **slab_relax_kwargs),\n**slab_static_kwargs,\n)\nfor slab in slabs\n]\nslabs = ct.electron(make_max_slabs_from_bulk)(atoms, **slabgen_kwargs)\nif slab_static_electron is None:\nreturn _relax_distributed(slabs)\nreturn _relax_and_static_distributed(slabs)\n</code></pre>"},{"location":"reference/quacc/recipes/emt/jobflow/slabs.html","title":"slabs","text":"<p>Slab recipes for EMT based on Jobflow</p>"},{"location":"reference/quacc/recipes/emt/jobflow/slabs.html#quacc.recipes.emt.jobflow.slabs.bulk_to_slabs_flow","title":"bulk_to_slabs_flow","text":"<pre><code>bulk_to_slabs_flow(atoms, slabgen_kwargs=None, slab_relax_job=job(relax_job), slab_static_job=job(static_job), slab_relax_kwargs=None, slab_static_kwargs=None)\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>Slab generation</p> </li> <li> <p>Slab relaxations</p> </li> <li> <p>Slab statics (optional)</p> </li> </ol> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> slabgen_kwargs             (<code>dict | None</code>)         \u2013          <p>Additional keyword arguments to pass to <code>make_max_slabs_from_bulk()</code></p> </li> <li> slab_relax_job             (<code>Job</code>)         \u2013          <p>Maker to use for the relaxation of the slab.</p> </li> <li> slab_static_job             (<code>Job | None</code>)         \u2013          <p>Maker to use for the static calculation of the slab.</p> </li> <li> slab_relax_kwargs             (<code>dict | None</code>)         \u2013          <p>Additional keyword arguments to pass to the relaxation calculation.</p> </li> <li> slab_static_kwargs             (<code>dict | None</code>)         \u2013          <p>Additional keyword arguments to pass to the static calculation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Response</code>         \u2013          <p>A Response containing Flow of relaxation and static jobs for the generated slabs.</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/emt/jobflow/slabs.py</code> <pre><code>def bulk_to_slabs_flow(\natoms: Atoms | dict,\nslabgen_kwargs: dict | None = None,\nslab_relax_job: Job = job(relax_job),\nslab_static_job: Job | None = job(static_job),\nslab_relax_kwargs: dict | None = None,\nslab_static_kwargs: dict | None = None,\n) -&gt; Response:\n\"\"\"\n    Workflow consisting of:\n    1. Slab generation\n    2. Slab relaxations\n    3. Slab statics (optional)\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    slabgen_kwargs\n        Additional keyword arguments to pass to `make_max_slabs_from_bulk()`\n    slab_relax_job\n        Maker to use for the relaxation of the slab.\n    slab_static_job\n        Maker to use for the static calculation of the slab.\n    slab_relax_kwargs\n        Additional keyword arguments to pass to the relaxation calculation.\n    slab_static_kwargs\n        Additional keyword arguments to pass to the static calculation.\n    Returns\n    -------\n    Response\n        A Response containing Flow of relaxation and static jobs for the generated slabs.\n    \"\"\"\natoms = atoms if isinstance(atoms, Atoms) else atoms[\"atoms\"]\nslab_relax_kwargs = slab_relax_kwargs or {}\nslab_static_kwargs = slab_static_kwargs or {}\nslabgen_kwargs = slabgen_kwargs or {}\nif \"relax_cell\" not in slab_relax_kwargs:\nslab_relax_kwargs[\"relax_cell\"] = False\n# Generate all the slab\nslabs = make_max_slabs_from_bulk(atoms, **slabgen_kwargs)\n# Generate the jobs for each slab\njobs = []\noutputs = []\nfor slab in slabs:\nif slab_static_job is None:\njob1 = slab_relax_job(slab, **slab_relax_kwargs)\njobs += [job1]\noutputs.append(job1.output)\nelse:\njob1 = slab_relax_job(slab, **slab_relax_kwargs)\njob2 = slab_static_job(job1.output, **slab_static_kwargs)\njobs += [job1, job2]\noutputs.append(job2.output)\nreturn Response(\noutput={\"input_bulk\": atoms, \"generated_slabs\": slabs},\nreplace=Flow(jobs, output=outputs),\n)\n</code></pre>"},{"location":"reference/quacc/recipes/emt/parsl/slabs.html","title":"slabs","text":"<p>Slab recipes for EMT</p>"},{"location":"reference/quacc/recipes/emt/parsl/slabs.html#quacc.recipes.emt.parsl.slabs.bulk_to_slabs_flow","title":"bulk_to_slabs_flow","text":"<pre><code>bulk_to_slabs_flow(atoms, slabgen_kwargs=None, slab_relax_app=python_app(relax_job.electron_object.function), slab_static_app=python_app(static_job.electron_object.function), slab_relax_kwargs=None, slab_static_kwargs=None)\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>Slab generation</p> </li> <li> <p>Slab relaxations</p> </li> <li> <p>Slab statics (optional)</p> </li> </ol> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> slabgen_kwargs             (<code>dict | None</code>)         \u2013          <p>Additional keyword arguments to pass to make_max_slabs_from_bulk()</p> </li> <li> slab_relax_app             (<code>PythonApp</code>)         \u2013          <p>Default PythonApp to use for the relaxation of the slab structures.</p> </li> <li> slab_static_app             (<code>PythonApp | None</code>)         \u2013          <p>Default PythonApp to use for the static calculation of the slab structures.</p> </li> <li> slab_relax_kwargs             (<code>dict | None</code>)         \u2013          <p>Additional keyword arguments to pass to the relaxation calculation.</p> </li> <li> slab_static_kwargs             (<code>dict | None</code>)         \u2013          <p>Additional keyword arguments to pass to the static calculation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AppFuture</code>         \u2013          <p>An AppFuture whose .result() is a list[dict]</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/emt/parsl/slabs.py</code> <pre><code>def bulk_to_slabs_flow(\natoms: Atoms | dict,\nslabgen_kwargs: dict | None = None,\nslab_relax_app: PythonApp = python_app(relax_job.electron_object.function),\nslab_static_app: PythonApp | None = python_app(static_job.electron_object.function),\nslab_relax_kwargs: dict | None = None,\nslab_static_kwargs: dict | None = None,\n) -&gt; AppFuture:\n\"\"\"\n    Workflow consisting of:\n    1. Slab generation\n    2. Slab relaxations\n    3. Slab statics (optional)\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    slabgen_kwargs\n        Additional keyword arguments to pass to make_max_slabs_from_bulk()\n    slab_relax_app\n        Default PythonApp to use for the relaxation of the slab structures.\n    slab_static_app\n        Default PythonApp to use for the static calculation of the slab structures.\n    slab_relax_kwargs\n        Additional keyword arguments to pass to the relaxation calculation.\n    slab_static_kwargs\n        Additional keyword arguments to pass to the static calculation.\n    Returns\n    -------\n    AppFuture\n        An AppFuture whose .result() is a list[dict]\n    \"\"\"\natoms = atoms if isinstance(atoms, Atoms) else atoms[\"atoms\"]\nslab_relax_kwargs = slab_relax_kwargs or {}\nslab_static_kwargs = slab_static_kwargs or {}\nslabgen_kwargs = slabgen_kwargs or {}\nif \"relax_cell\" not in slab_relax_kwargs:\nslab_relax_kwargs[\"relax_cell\"] = False\n@join_app\ndef _relax_distributed(slabs):\nreturn [slab_relax_app(slab, **slab_relax_kwargs) for slab in slabs]\n@join_app\ndef _relax_and_static_distributed(slabs):\nreturn [\nslab_static_app(\nslab_relax_app(slab, **slab_relax_kwargs),\n**slab_static_kwargs,\n)\nfor slab in slabs\n]\nslabs = make_max_slabs_from_bulk(atoms, **slabgen_kwargs)\nif slab_static_app is None:\nreturn _relax_distributed(slabs)\nreturn _relax_and_static_distributed(slabs)\n</code></pre>"},{"location":"reference/quacc/recipes/gaussian/core.html","title":"core","text":"<p>Core recipes for Gaussian</p>"},{"location":"reference/quacc/recipes/gaussian/core.html#quacc.recipes.gaussian.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(atoms, charge=None, multiplicity=None, xc='wb97x-d', basis='def2-tzvp', freq=False, calc_swaps=None)\n</code></pre> <p>Carry out a geometry optimization.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> charge             (<code>int | None</code>)         \u2013          <p>Charge of the system. If None, this is determined from the sum of <code>atoms.get_initial_charges()</code>.</p> </li> <li> multiplicity             (<code>int | None</code>)         \u2013          <p>Multiplicity of the system. If None, this is determined from 1+ the sum of <code>atoms.get_initial_magnetic_moments()</code>.</p> </li> <li> xc             (<code>str</code>)         \u2013          <p>Exchange-correlation functional</p> </li> <li> basis             (<code>str</code>)         \u2013          <p>Basis set</p> </li> <li> freq             (<code>bool</code>)         \u2013          <p>If a frequency calculation should be carried out.</p> </li> <li> calc_swaps             (<code>dict | None</code>)         \u2013          <p>Dictionary of custom kwargs for the calculator. defaults = { \"mem\": \"16GB\", \"chk\": \"Gaussian.chk\", \"nprocshared\": multiprocessing.cpu_count(), \"xc\": xc, \"basis\": basis, \"charge\": charge or int(sum(atoms.get_initial_charges())), \"mult\": multiplicity or int(1 + sum(atoms.get_initial_magnetic_moments())), \"opt\": \"\", \"pop\": \"CM5\", \"scf\": [\"maxcycle=250\", \"xqc\"], \"integral\": \"ultrafine\", \"nosymmetry\": \"\", \"freq\": \"\" if freq else None, \"ioplist\": [\"2/9=2000\"],  # ASE issue #660 }</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from <code>quacc.schemas.cclib.summarize_run</code></p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/gaussian/core.py</code> <pre><code>@ct.electron\ndef relax_job(\natoms: Atoms,\ncharge: int | None = None,\nmultiplicity: int | None = None,\nxc: str = \"wb97x-d\",\nbasis: str = \"def2-tzvp\",\nfreq: bool = False,\ncalc_swaps: dict | None = None,\n) -&gt; cclibSchema:\n\"\"\"\n    Carry out a geometry optimization.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    charge\n        Charge of the system. If None, this is determined from the sum of\n        `atoms.get_initial_charges()`.\n    multiplicity\n        Multiplicity of the system. If None, this is determined from 1+ the sum\n        of `atoms.get_initial_magnetic_moments()`.\n    xc\n        Exchange-correlation functional\n    basis\n        Basis set\n    freq\n        If a frequency calculation should be carried out.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator.\n            defaults = {\n                \"mem\": \"16GB\",\n                \"chk\": \"Gaussian.chk\",\n                \"nprocshared\": multiprocessing.cpu_count(),\n                \"xc\": xc,\n                \"basis\": basis,\n                \"charge\": charge or int(sum(atoms.get_initial_charges())),\n                \"mult\": multiplicity or int(1 + sum(atoms.get_initial_magnetic_moments())),\n                \"opt\": \"\",\n                \"pop\": \"CM5\",\n                \"scf\": [\"maxcycle=250\", \"xqc\"],\n                \"integral\": \"ultrafine\",\n                \"nosymmetry\": \"\",\n                \"freq\": \"\" if freq else None,\n                \"ioplist\": [\"2/9=2000\"],  # ASE issue #660\n            }\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from `quacc.schemas.cclib.summarize_run`\n    \"\"\"\natoms = atoms if isinstance(atoms, Atoms) else atoms[\"atoms\"]\ncalc_swaps = calc_swaps or {}\ncharge = int(atoms.get_initial_charges().sum()) if charge is None else charge\nmultiplicity = (\nint(1 + atoms.get_initial_magnetic_moments().sum())\nif multiplicity is None\nelse multiplicity\n)\ndefaults = {\n\"mem\": \"16GB\",\n\"chk\": \"Gaussian.chk\",\n\"nprocshared\": multiprocessing.cpu_count(),\n\"xc\": xc,\n\"basis\": basis,\n\"charge\": charge,\n\"mult\": multiplicity,\n\"opt\": \"\",\n\"pop\": \"CM5\",\n\"scf\": [\"maxcycle=250\", \"xqc\"],\n\"integral\": \"ultrafine\",\n\"nosymmetry\": \"\",\n\"freq\": \"\" if freq else None,\n\"ioplist\": [\"2/9=2000\"],  # ASE issue #660\n}\nflags = remove_dict_empties(defaults | calc_swaps)\natoms.calc = Gaussian(**flags)\natoms = run_calc(atoms, geom_file=GEOM_FILE)\nreturn summarize_run(\natoms,\nLOG_FILE,\nadditional_fields={\"name\": \"Gaussian Relax\"},\n)\n</code></pre>"},{"location":"reference/quacc/recipes/gaussian/core.html#quacc.recipes.gaussian.core.static_job","title":"static_job","text":"<pre><code>static_job(atoms, charge=None, multiplicity=None, xc='wb97x-d', basis='def2-tzvp', calc_swaps=None)\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> charge             (<code>int | None</code>)         \u2013          <p>Charge of the system. If None, this is determined from the sum of <code>atoms.get_initial_charges().</code></p> </li> <li> multiplicity             (<code>int | None</code>)         \u2013          <p>Multiplicity of the system. If None, this is determined from 1+ the sum of <code>atoms.get_initial_magnetic_moments()</code>.</p> </li> <li> xc             (<code>str</code>)         \u2013          <p>Exchange-correlation functional</p> </li> <li> basis             (<code>str</code>)         \u2013          <p>Basis set</p> </li> <li> calc_swaps             (<code>dict | None</code>)         \u2013          <p>Dictionary of custom kwargs for the calculator. defaults = { \"mem\": \"16GB\", \"chk\": \"Gaussian.chk\", \"nprocshared\": multiprocessing.cpu_count(), \"xc\": xc, \"basis\": basis, \"charge\": charge or int(sum(atoms.get_initial_charges())), \"mult\": multiplicity or int(1 + sum(atoms.get_initial_magnetic_moments())), \"sp\": \"\", \"scf\": [\"maxcycle=250\", \"xqc\"], \"integral\": \"ultrafine\", \"nosymmetry\": \"\", \"pop\": \"CM5\", \"gfinput\": \"\", \"ioplist\": [\"6/7=3\", \"2/9=2000\"] }</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from <code>quacc.schemas.cclib.summarize_run</code></p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/gaussian/core.py</code> <pre><code>@ct.electron\ndef static_job(\natoms: Atoms | dict,\ncharge: int | None = None,\nmultiplicity: int | None = None,\nxc: str = \"wb97x-d\",\nbasis: str = \"def2-tzvp\",\ncalc_swaps: dict | None = None,\n) -&gt; cclibSchema:\n\"\"\"\n    Carry out a single-point calculation.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    charge\n        Charge of the system. If None, this is determined from the sum of\n        `atoms.get_initial_charges().`\n    multiplicity\n        Multiplicity of the system. If None, this is determined from 1+ the sum\n        of `atoms.get_initial_magnetic_moments()`.\n    xc\n        Exchange-correlation functional\n    basis\n        Basis set\n    calc_swaps\n        Dictionary of custom kwargs for the calculator.\n            defaults = {\n                \"mem\": \"16GB\",\n                \"chk\": \"Gaussian.chk\",\n                \"nprocshared\": multiprocessing.cpu_count(),\n                \"xc\": xc,\n                \"basis\": basis,\n                \"charge\": charge or int(sum(atoms.get_initial_charges())),\n                \"mult\": multiplicity or int(1 + sum(atoms.get_initial_magnetic_moments())),\n                \"sp\": \"\",\n                \"scf\": [\"maxcycle=250\", \"xqc\"],\n                \"integral\": \"ultrafine\",\n                \"nosymmetry\": \"\",\n                \"pop\": \"CM5\",\n                \"gfinput\": \"\",\n                \"ioplist\": [\"6/7=3\", \"2/9=2000\"]\n            }\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from `quacc.schemas.cclib.summarize_run`\n    \"\"\"\natoms = atoms if isinstance(atoms, Atoms) else atoms[\"atoms\"]\ncalc_swaps = calc_swaps or {}\ncharge = int(atoms.get_initial_charges().sum()) if charge is None else charge\nmultiplicity = (\nint(1 + atoms.get_initial_magnetic_moments().sum())\nif multiplicity is None\nelse multiplicity\n)\ndefaults = {\n\"mem\": \"16GB\",\n\"chk\": \"Gaussian.chk\",\n\"nprocshared\": multiprocessing.cpu_count(),\n\"xc\": xc,\n\"basis\": basis,\n\"charge\": charge,\n\"mult\": multiplicity,\n\"sp\": \"\",\n\"scf\": [\"maxcycle=250\", \"xqc\"],\n\"integral\": \"ultrafine\",\n\"nosymmetry\": \"\",\n\"pop\": \"CM5\",\n\"gfinput\": \"\",\n\"ioplist\": [\"6/7=3\", \"2/9=2000\"],  # see ASE issue #660\n}\nflags = remove_dict_empties(defaults | calc_swaps)\natoms.calc = Gaussian(**flags)\natoms = run_calc(atoms, geom_file=GEOM_FILE)\nreturn summarize_run(\natoms,\nLOG_FILE,\nadditional_fields={\"name\": \"Gaussian Static\"},\n)\n</code></pre>"},{"location":"reference/quacc/recipes/gulp/core.html","title":"core","text":"<p>Core recipes for GULP</p>"},{"location":"reference/quacc/recipes/gulp/core.html#quacc.recipes.gulp.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(atoms, use_gfnff=True, library=None, relax_cell=True, keyword_swaps=None, option_swaps=None)\n</code></pre> <p>Carry out a single-point calculation. Note: 'Conditions' are not yet natively supported.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> use_gfnff             (<code>bool</code>)         \u2013          <p>True if (p)GFN-FF should be used; False if not.</p> </li> <li> library             (<code>str | None</code>)         \u2013          <p>Filename of the potential library file, if required.</p> </li> <li> relax_cell             (<code>bool</code>)         \u2013          <p>True if the volume should be relaxed; False if not.</p> </li> <li> keyword_swaps             (<code>dict | None</code>)         \u2013          <p>Dictionary of custom keyword swap kwargs for the calculator.</p> </li> <li> option_swaps             (<code>dict | None</code>)         \u2013          <p>Dictionary of custom option swap kwargs for the calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary of results from <code>quacc.schemas.ase.summarize_run</code></p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/gulp/core.py</code> <pre><code>@ct.electron\ndef relax_job(\natoms: Atoms | dict,\nuse_gfnff: bool = True,\nlibrary: str | None = None,\nrelax_cell: bool = True,\nkeyword_swaps: dict | None = None,\noption_swaps: dict | None = None,\n) -&gt; RunSchema:\n\"\"\"\n    Carry out a single-point calculation.\n    Note: 'Conditions' are not yet natively supported.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    use_gfnff\n        True if (p)GFN-FF should be used; False if not.\n    library\n        Filename of the potential library file, if required.\n    relax_cell\n        True if the volume should be relaxed; False if not.\n    keyword_swaps\n        Dictionary of custom keyword swap kwargs for the calculator.\n    option_swaps\n        Dictionary of custom option swap kwargs for the calculator.\n    Returns\n    -------\n    dict\n        Dictionary of results from `quacc.schemas.ase.summarize_run`\n    \"\"\"\natoms = atoms if isinstance(atoms, Atoms) else atoms[\"atoms\"]\nkeyword_swaps = keyword_swaps or {}\noption_swaps = option_swaps or {}\nif relax_cell and not atoms.pbc.any():\nwarnings.warn(\n\"Volume relaxation requested but no PBCs found. Ignoring.\", UserWarning\n)\nrelax_cell = False\ndefault_keywords = {\n\"opti\": True,\n\"gfnff\": True if use_gfnff else None,\n\"gwolf\": True if use_gfnff and atoms.pbc.any() else None,\n\"conp\": True if relax_cell and atoms.pbc.any() else None,\n\"conv\": None if relax_cell and atoms.pbc.any() else True,\n}\ndefault_options = {\n\"dump every gulp.res\": True,\nf\"output cif {GEOM_FILE_PBC}\": True if atoms.pbc.any() else None,\nf\"output xyz {GEOM_FILE_NOPBC}\": None if atoms.pbc.any() else True,\n}\nkeywords = remove_dict_empties(default_keywords | keyword_swaps)\noptions = remove_dict_empties(default_options | option_swaps)\ngulp_keywords = \" \".join(list(keywords.keys()))\ngulp_options = list(options.keys())\natoms.calc = GULP(keywords=gulp_keywords, options=gulp_options, library=library)\nfinal_atoms = run_calc(\natoms, geom_file=GEOM_FILE_PBC if atoms.pbc.any() else GEOM_FILE_NOPBC\n)\nif not final_atoms.calc.get_opt_state():\nraise ValueError(\"Optimization did not converge!\")\nreturn summarize_run(\nfinal_atoms,\ninput_atoms=atoms,\nadditional_fields={\"name\": \"GULP Relax\"},\n)\n</code></pre>"},{"location":"reference/quacc/recipes/gulp/core.html#quacc.recipes.gulp.core.static_job","title":"static_job","text":"<pre><code>static_job(atoms, use_gfnff=True, library=None, keyword_swaps=None, option_swaps=None)\n</code></pre> <p>Carry out a single-point calculation. Note: 'Conditions' are not yet natively supported.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> use_gfnff             (<code>bool</code>)         \u2013          <p>True if (p)GFN-FF should be used; False if not.</p> </li> <li> library             (<code>str | None</code>)         \u2013          <p>Filename of the potential library file, if required.</p> </li> <li> keyword_swaps             (<code>dict | None</code>)         \u2013          <p>dictionary of custom keyword swap kwargs for the calculator. default_keywords = { \"gfnff\": True if use_gfnff else None, \"gwolf\": True if use_gfnff and atoms.pbc.any() else None, }</p> </li> <li> option_swaps             (<code>dict | None</code>)         \u2013          <p>dictionary of custom option swap kwargs for the calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from <code>quacc.schemas.ase.summarize_run</code></p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/gulp/core.py</code> <pre><code>@ct.electron\ndef static_job(\natoms: Atoms | dict,\nuse_gfnff: bool = True,\nlibrary: str | None = None,\nkeyword_swaps: dict | None = None,\noption_swaps: dict | None = None,\n) -&gt; RunSchema:\n\"\"\"\n    Carry out a single-point calculation.\n    Note: 'Conditions' are not yet natively supported.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    use_gfnff\n        True if (p)GFN-FF should be used; False if not.\n    library\n        Filename of the potential library file, if required.\n    keyword_swaps\n        dictionary of custom keyword swap kwargs for the calculator.\n            default_keywords = {\n                \"gfnff\": True if use_gfnff else None,\n                \"gwolf\": True if use_gfnff and atoms.pbc.any() else None,\n            }\n    option_swaps\n        dictionary of custom option swap kwargs for the calculator.\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from `quacc.schemas.ase.summarize_run`\n    \"\"\"\natoms = atoms if isinstance(atoms, Atoms) else atoms[\"atoms\"]\nkeyword_swaps = keyword_swaps or {}\noption_swaps = option_swaps or {}\ndefault_keywords = {\n\"gfnff\": True if use_gfnff else None,\n\"gwolf\": True if use_gfnff and atoms.pbc.any() else None,\n}\ndefault_options = {\n\"dump every gulp.res\": True,\nf\"output cif {GEOM_FILE_PBC}\": True if atoms.pbc.any() else None,\nf\"output xyz {GEOM_FILE_NOPBC}\": None if atoms.pbc.any() else True,\n}\nkeywords = remove_dict_empties(default_keywords | keyword_swaps)\noptions = remove_dict_empties(default_options | option_swaps)\ngulp_keywords = \" \".join(list(keywords.keys()))\ngulp_options = list(options.keys())\natoms.calc = GULP(keywords=gulp_keywords, options=gulp_options, library=library)\nfinal_atoms = run_calc(\natoms, geom_file=GEOM_FILE_PBC if atoms.pbc.any() else GEOM_FILE_NOPBC\n)\nreturn summarize_run(\nfinal_atoms,\ninput_atoms=atoms,\nadditional_fields={\"name\": \"GULP Static\"},\n)\n</code></pre>"},{"location":"reference/quacc/recipes/lj/core.html","title":"core","text":"<p>Core recipes for Lennard-Jones Potential</p> <p>NOTE: This set of minimal recipes is mainly for demonstration purposes</p>"},{"location":"reference/quacc/recipes/lj/core.html#quacc.recipes.lj.core.freq_job","title":"freq_job","text":"<pre><code>freq_job(atoms, energy=0.0, temperature=298.15, pressure=1.0, calc_kwargs=None, vib_kwargs=None)\n</code></pre> <p>Run a frequency job and calculate thermochemistry.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> energy             (<code>float</code>)         \u2013          <p>Potential energy in eV. If 0, then the output is just the correction.</p> </li> <li> temperature             (<code>float</code>)         \u2013          <p>Temperature in Kelvins.</p> </li> <li> pressure             (<code>float</code>)         \u2013          <p>Pressure in bar.</p> </li> <li> calc_kwargs             (<code>dict | None</code>)         \u2013          <p>dictionary of custom kwargs for the LJ calculator.</p> </li> <li> vib_kwargs             (<code>dict | None</code>)         \u2013          <p>dictionary of custom kwargs for the Vibrations object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_vib_run and quacc.schemas.ase.summarize_thermo_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/lj/core.py</code> <pre><code>@ct.electron\ndef freq_job(\natoms: Atoms | dict,\nenergy: float = 0.0,\ntemperature: float = 298.15,\npressure: float = 1.0,\ncalc_kwargs: dict | None = None,\nvib_kwargs: dict | None = None,\n) -&gt; dict[Literal[\"vib\", \"thermo\"], VibSchema | ThermoSchema]:\n\"\"\"\n    Run a frequency job and calculate thermochemistry.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    energy\n        Potential energy in eV. If 0, then the output is just the correction.\n    temperature\n        Temperature in Kelvins.\n    pressure\n        Pressure in bar.\n    calc_kwargs\n        dictionary of custom kwargs for the LJ calculator.\n    vib_kwargs\n        dictionary of custom kwargs for the Vibrations object\n    Returns\n    -------\n    dict\n        Dictionary of results from quacc.schemas.ase.summarize_vib_run and\n        quacc.schemas.ase.summarize_thermo_run\n    \"\"\"\natoms = atoms if isinstance(atoms, Atoms) else atoms[\"atoms\"]\ncalc_kwargs = calc_kwargs or {}\nvib_kwargs = vib_kwargs or {}\natoms.calc = LennardJones(**calc_kwargs)\nvibrations = run_ase_vib(atoms, vib_kwargs=vib_kwargs)\nigt = ideal_gas(atoms, vibrations.get_frequencies(), energy=energy)\nreturn {\n\"vib\": summarize_vib_run(\nvibrations, additional_fields={\"name\": \"LJ Vibrations\"}\n),\n\"thermo\": summarize_thermo_run(\nigt,\ntemperature=temperature,\npressure=pressure,\nadditional_fields={\"name\": \"LJ Thermo\"},\n),\n}\n</code></pre>"},{"location":"reference/quacc/recipes/lj/core.html#quacc.recipes.lj.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(atoms, calc_kwargs=None, opt_swaps=None)\n</code></pre> <p>Function to carry out a geometry optimization</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object</p> </li> <li> calc_kwargs             (<code>dict | None</code>)         \u2013          <p>Dictionary of custom kwargs for the LJ calculator.</p> </li> <li> opt_swaps             (<code>dict | None</code>)         \u2013          <p>Dictionary of swaps for run_ase_opt</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary of results from <code>quacc.schemas.ase.summarize_opt_run</code></p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/lj/core.py</code> <pre><code>@ct.electron\ndef relax_job(\natoms: Atoms | dict,\ncalc_kwargs: dict | None = None,\nopt_swaps: dict | None = None,\n) -&gt; OptSchema:\n\"\"\"\n    Function to carry out a geometry optimization\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    calc_kwargs\n        Dictionary of custom kwargs for the LJ calculator.\n    opt_swaps\n        Dictionary of swaps for run_ase_opt\n    Returns\n    -------\n    OptSchema\n        Dictionary of results from `quacc.schemas.ase.summarize_opt_run`\n    \"\"\"\natoms = atoms if isinstance(atoms, Atoms) else atoms[\"atoms\"]\ncalc_kwargs = calc_kwargs or {}\nopt_swaps = opt_swaps or {}\nopt_defaults = {\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": FIRE}\nopt_flags = opt_defaults | opt_swaps\natoms.calc = LennardJones(**calc_kwargs)\ndyn = run_ase_opt(atoms, **opt_flags)\nreturn summarize_opt_run(dyn, additional_fields={\"name\": \"LJ Relax\"})\n</code></pre>"},{"location":"reference/quacc/recipes/lj/core.html#quacc.recipes.lj.core.static_job","title":"static_job","text":"<pre><code>static_job(atoms, calc_kwargs=None)\n</code></pre> <p>Function to carry out a static calculation.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> calc_kwargs             (<code>dict | None</code>)         \u2013          <p>Dictionary of custom kwargs for the LJ calculator</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from <code>quacc.schemas.ase.summarize_run</code></p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/lj/core.py</code> <pre><code>@ct.electron\ndef static_job(\natoms: Atoms | dict,\ncalc_kwargs: dict | None = None,\n) -&gt; RunSchema:\n\"\"\"\n    Function to carry out a static calculation.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    calc_kwargs\n        Dictionary of custom kwargs for the LJ calculator\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from `quacc.schemas.ase.summarize_run`\n    \"\"\"\natoms = atoms if isinstance(atoms, Atoms) else atoms[\"atoms\"]\ncalc_kwargs = calc_kwargs or {}\natoms.calc = LennardJones(**calc_kwargs)\nfinal_atoms = run_calc(atoms)\nreturn summarize_run(\nfinal_atoms, input_atoms=atoms, additional_fields={\"name\": \"LJ Static\"}\n)\n</code></pre>"},{"location":"reference/quacc/recipes/orca/core.html","title":"core","text":"<p>Core recipes for ORCA</p>"},{"location":"reference/quacc/recipes/orca/core.html#quacc.recipes.orca.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(atoms, charge=None, multiplicity=None, xc='wb97x-d3bj', basis='def2-tzvp', run_freq=False, input_swaps=None, block_swaps=None)\n</code></pre> <p>Carry out a geometry optimization.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object</p> </li> <li> charge             (<code>int | None</code>)         \u2013          <p>Charge of the system. If None, this is determined from the sum of atoms.get_initial_charges().</p> </li> <li> multiplicity             (<code>int | None</code>)         \u2013          <p>Multiplicity of the system. If None, this is determined from 1+ the sum of atoms.get_initial_magnetic_moments().</p> </li> <li> xc             (<code>str</code>)         \u2013          <p>Exchange-correlation functional</p> </li> <li> basis             (<code>str</code>)         \u2013          <p>Basis set</p> </li> <li> run_freq             (<code>bool</code>)         \u2013          <p>If a requency calculation should be carried out.</p> </li> <li> input_swaps             (<code>dict | None</code>)         \u2013          <p>Dictionary of orcasimpleinput swaps for the calculator. To enable new entries, set the value as True. To remove entries from the defaults, set the value as None.</p> </li> <li> block_swaps             (<code>dict | None</code>)         \u2013          <p>Dictionary of orcablock swaps for the calculator. To enable new entries, set the value as True. To remove entries from the defaults, set the value as None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>cclibSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.cclib.summarize_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/orca/core.py</code> <pre><code>@ct.electron\ndef relax_job(\natoms: Atoms | dict,\ncharge: int | None = None,\nmultiplicity: int | None = None,\nxc: str = \"wb97x-d3bj\",\nbasis: str = \"def2-tzvp\",\nrun_freq: bool = False,\ninput_swaps: dict | None = None,\nblock_swaps: dict | None = None,\n) -&gt; cclibSchema:\n\"\"\"\n    Carry out a geometry optimization.\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system. If None, this is determined from the sum of\n        atoms.get_initial_charges().\n    multiplicity\n        Multiplicity of the system. If None, this is determined from 1+ the sum\n        of atoms.get_initial_magnetic_moments().\n    xc\n        Exchange-correlation functional\n    basis\n        Basis set\n    run_freq\n        If a requency calculation should be carried out.\n    input_swaps\n        Dictionary of orcasimpleinput swaps for the calculator.\n        To enable new entries, set the value as True.\n        To remove entries from the defaults, set the value as None.\n    block_swaps\n        Dictionary of orcablock swaps for the calculator.\n        To enable new entries, set the value as True.\n        To remove entries from the defaults, set the value as None.\n    Returns\n    -------\n    cclibSchema\n        Dictionary of results from quacc.schemas.cclib.summarize_run\n    \"\"\"\natoms = atoms if isinstance(atoms, Atoms) else atoms[\"atoms\"]\ninput_swaps = input_swaps or {}\nblock_swaps = block_swaps or {}\nif not any(k for k in block_swaps if \"nprocs\" in k.lower()) and os.environ.get(\n\"mpirun\"\n):\nnprocs = multiprocessing.cpu_count()\nblock_swaps[f\"%pal nprocs {nprocs} end\"] = True\ndefault_inputs = {\nxc: True,\nbasis: True,\n\"opt\": True,\n\"slowconv\": True,\n\"normalprint\": True,\n\"freq\": True if run_freq else None,\n\"xyzfile\": True,\n}\ndefault_blocks = {}\ninputs = remove_dict_empties(default_inputs | input_swaps)\nblocks = remove_dict_empties(default_blocks | block_swaps)\norcasimpleinput = \" \".join(list(inputs.keys()))\norcablocks = \" \".join(list(blocks.keys()))\ncharge = int(atoms.get_initial_charges().sum()) if charge is None else charge\nmultiplicity = (\nint(1 + atoms.get_initial_magnetic_moments().sum())\nif multiplicity is None\nelse multiplicity\n)\natoms.calc = ORCA(\nprofile=OrcaProfile([SETTINGS.ORCA_CMD]),\ncharge=charge,\nmult=multiplicity,\norcasimpleinput=orcasimpleinput,\norcablocks=orcablocks,\n)\natoms = run_calc(atoms, geom_file=GEOM_FILE)\nreturn summarize_run(\natoms,\nLOG_FILE,\nadditional_fields={\"name\": \"ORCA Relax\"},\n)\n</code></pre>"},{"location":"reference/quacc/recipes/orca/core.html#quacc.recipes.orca.core.static_job","title":"static_job","text":"<pre><code>static_job(atoms, charge=None, multiplicity=None, xc='wb97x-d3bj', basis='def2-tzvp', input_swaps=None, block_swaps=None)\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> charge             (<code>int | None</code>)         \u2013          <p>Charge of the system. If None, this is determined from the sum of <code>atoms.get_initial_charges()</code>.</p> </li> <li> multiplicity             (<code>int | None</code>)         \u2013          <p>Multiplicity of the system. If None, this is determined from 1+ the sum of <code>atoms.get_initial_magnetic_moments()</code>.</p> </li> <li> xc             (<code>str</code>)         \u2013          <p>Exchange-correlation functional</p> </li> <li> basis             (<code>str</code>)         \u2013          <p>Basis set</p> </li> <li> input_swaps             (<code>dict | None</code>)         \u2013          <p>Dictionary of orcasimpleinput swaps for the calculator. To enable new entries, set the value as True. To remove entries from the defaults, set the value as None.</p> </li> <li> block_swaps             (<code>dict | None</code>)         \u2013          <p>Dictionary of orcablock swaps for the calculator. To enable new entries, set the value as True. To remove entries from the defaults, set the value as None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>cclibSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.cclib.summarize_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/orca/core.py</code> <pre><code>@ct.electron\ndef static_job(\natoms: Atoms | dict,\ncharge: int | None = None,\nmultiplicity: int | None = None,\nxc: str = \"wb97x-d3bj\",\nbasis: str = \"def2-tzvp\",\ninput_swaps: dict | None = None,\nblock_swaps: dict | None = None,\n) -&gt; cclibSchema:\n\"\"\"\n    Carry out a single-point calculation.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    charge\n        Charge of the system. If None, this is determined from the sum of\n        `atoms.get_initial_charges()`.\n    multiplicity\n        Multiplicity of the system. If None, this is determined from 1+ the sum\n        of `atoms.get_initial_magnetic_moments()`.\n    xc\n        Exchange-correlation functional\n    basis\n        Basis set\n    input_swaps\n        Dictionary of orcasimpleinput swaps for the calculator.\n        To enable new entries, set the value as True.\n        To remove entries from the defaults, set the value as None.\n    block_swaps\n        Dictionary of orcablock swaps for the calculator.\n        To enable new entries, set the value as True.\n        To remove entries from the defaults, set the value as None.\n    Returns\n    -------\n    cclibSchema\n        Dictionary of results from quacc.schemas.cclib.summarize_run\n    \"\"\"\natoms = atoms if isinstance(atoms, Atoms) else atoms[\"atoms\"]\ninput_swaps = input_swaps or {}\nblock_swaps = block_swaps or {}\nif not any(k for k in block_swaps if \"nprocs\" in k.lower()) and os.environ.get(\n\"mpirun\"\n):\nnprocs = multiprocessing.cpu_count()\nblock_swaps[f\"%pal nprocs {nprocs} end\"] = True\ndefault_inputs = {\nxc: True,\nbasis: True,\n\"sp\": True,\n\"slowconv\": True,\n\"normalprint\": True,\n\"xyzfile\": True,\n}\ndefault_blocks = {}\ninputs = remove_dict_empties(default_inputs | input_swaps)\nblocks = remove_dict_empties(default_blocks | block_swaps)\norcasimpleinput = \" \".join(list(inputs.keys()))\norcablocks = \" \".join(list(blocks.keys()))\ncharge = int(atoms.get_initial_charges().sum()) if charge is None else charge\nmultiplicity = (\nint(1 + atoms.get_initial_magnetic_moments().sum())\nif multiplicity is None\nelse multiplicity\n)\natoms.calc = ORCA(\nprofile=OrcaProfile([SETTINGS.ORCA_CMD]),\ncharge=charge,\nmult=multiplicity,\norcasimpleinput=orcasimpleinput,\norcablocks=orcablocks,\n)\natoms = run_calc(atoms, geom_file=GEOM_FILE)\nreturn summarize_run(\natoms,\nLOG_FILE,\nadditional_fields={\"name\": \"ORCA Static\"},\n)\n</code></pre>"},{"location":"reference/quacc/recipes/psi4/core.html","title":"core","text":"<p>Core recipes for Psi4</p>"},{"location":"reference/quacc/recipes/psi4/core.html#quacc.recipes.psi4.core.static_job","title":"static_job","text":"<pre><code>static_job(atoms, charge=None, multiplicity=None, method='wb97x-v', basis='def2-tzvp', calc_swaps=None)\n</code></pre> <p>Function to carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> charge             (<code>int | None</code>)         \u2013          <p>Charge of the system. If None, this is determined from the sum of <code>atoms.get_initial_charges()</code>.</p> </li> <li> multiplicity             (<code>int | None</code>)         \u2013          <p>Multiplicity of the system. If None, this is determined from 1+ the sum of <code>atoms.get_initial_magnetic_moments()</code>.</p> </li> <li> method             (<code>str</code>)         \u2013          <p>The level of theory to use.</p> </li> <li> basis             (<code>str</code>)         \u2013          <p>Basis set</p> </li> <li> calc_swaps             (<code>dict | None</code>)         \u2013          <p>Dictionary of custom kwargs for the calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from <code>quacc.schemas.ase.summarize_run</code></p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/psi4/core.py</code> <pre><code>@ct.electron\n@requires(psi4, \"Psi4 not installed. Try conda install -c psi4 psi4\")\ndef static_job(\natoms: Atoms | dict,\ncharge: int | None = None,\nmultiplicity: int | None = None,\nmethod: str = \"wb97x-v\",\nbasis: str = \"def2-tzvp\",\ncalc_swaps: dict | None = None,\n) -&gt; RunSchema:\n\"\"\"\n    Function to carry out a single-point calculation.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    charge\n        Charge of the system. If None, this is determined from the sum of\n        `atoms.get_initial_charges()`.\n    multiplicity\n        Multiplicity of the system. If None, this is determined from 1+ the sum\n        of `atoms.get_initial_magnetic_moments()`.\n    method\n        The level of theory to use.\n    basis\n        Basis set\n    calc_swaps\n        Dictionary of custom kwargs for the calculator.\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from `quacc.schemas.ase.summarize_run`\n    \"\"\"\natoms = atoms if isinstance(atoms, Atoms) else atoms[\"atoms\"]\ncalc_swaps = calc_swaps or {}\ncharge = int(atoms.get_initial_charges().sum()) if charge is None else charge\nmultiplicity = (\nint(1 + atoms.get_initial_magnetic_moments().sum())\nif multiplicity is None\nelse multiplicity\n)\ndefaults = {\n\"mem\": \"16GB\",\n\"num_threads\": \"max\",\n\"method\": method,\n\"basis\": basis,\n\"charge\": charge,\n\"multiplicity\": multiplicity,\n\"reference\": \"uhf\" if multiplicity &gt; 1 else None,\n}\nflags = remove_dict_empties(defaults | calc_swaps)\natoms.calc = Psi4(**flags)\nfinal_atoms = run_calc(atoms)\nreturn summarize_run(\nfinal_atoms,\ninput_atoms=atoms,\ncharge_and_multiplicity=(charge, multiplicity),\nadditional_fields={\"name\": \"Psi4 Static\"},\n)\n</code></pre>"},{"location":"reference/quacc/recipes/tblite/core.html","title":"core","text":"<p>Core recipes for the tblite code</p>"},{"location":"reference/quacc/recipes/tblite/core.html#quacc.recipes.tblite.core.freq_job","title":"freq_job","text":"<pre><code>freq_job(atoms, method='GFN2-xTB', energy=0.0, temperature=298.15, pressure=1.0, calc_kwargs=None, vib_kwargs=None)\n</code></pre> <p>Run a frequency job and calculate thermochemistry.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> method             (<code>Literal['GFN1-xTB', 'GFN2-xTB', 'IPEA1-xTB']</code>)         \u2013          <p>GFN0-xTB, GFN1-xTB, GFN2-xTB, GFN-FF.</p> </li> <li> energy             (<code>float</code>)         \u2013          <p>Potential energy in eV. If 0, then the output is just the correction.</p> </li> <li> temperature             (<code>float</code>)         \u2013          <p>Temperature in Kelvins.</p> </li> <li> pressure             (<code>float</code>)         \u2013          <p>Pressure in bar.</p> </li> <li> calc_kwargs             (<code>dict | None</code>)         \u2013          <p>dictionary of custom kwargs for the xTB calculator.</p> </li> <li> vib_kwargs             (<code>dict | None</code>)         \u2013          <p>dictionary of custom kwargs for the Vibrations object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_vib_run and quacc.schemas.ase.summarize_thermo_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/tblite/core.py</code> <pre><code>@ct.electron\n@requires(TBLite, \"tblite must be installed. Try pip install tblite[ase]\")\ndef freq_job(\natoms: Atoms | dict,\nmethod: Literal[\"GFN1-xTB\", \"GFN2-xTB\", \"IPEA1-xTB\"] = \"GFN2-xTB\",\nenergy: float = 0.0,\ntemperature: float = 298.15,\npressure: float = 1.0,\ncalc_kwargs: dict | None = None,\nvib_kwargs: dict | None = None,\n) -&gt; dict[Literal[\"vib\", \"thermo\"], VibSchema | ThermoSchema]:\n\"\"\"\n    Run a frequency job and calculate thermochemistry.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    method\n        GFN0-xTB, GFN1-xTB, GFN2-xTB, GFN-FF.\n    energy\n        Potential energy in eV. If 0, then the output is just the correction.\n    temperature\n        Temperature in Kelvins.\n    pressure\n        Pressure in bar.\n    calc_kwargs\n        dictionary of custom kwargs for the xTB calculator.\n    vib_kwargs\n        dictionary of custom kwargs for the Vibrations object\n    Returns\n    -------\n    dict\n        Dictionary of results from quacc.schemas.ase.summarize_vib_run and\n        quacc.schemas.ase.summarize_thermo_run\n    \"\"\"\natoms = atoms if isinstance(atoms, Atoms) else atoms[\"atoms\"]\ncalc_kwargs = calc_kwargs or {}\nvib_kwargs = vib_kwargs or {}\natoms.calc = TBLite(method=method, **calc_kwargs)\nvibrations = run_ase_vib(atoms, vib_kwargs=vib_kwargs)\nigt = ideal_gas(atoms, vibrations.get_frequencies(), energy=energy)\nreturn {\n\"vib\": summarize_vib_run(\nvibrations, additional_fields={\"name\": \"TBLite Vibrations\"}\n),\n\"thermo\": summarize_thermo_run(\nigt,\ntemperature=temperature,\npressure=pressure,\nadditional_fields={\"name\": \"TBLite Thermo\"},\n),\n}\n</code></pre>"},{"location":"reference/quacc/recipes/tblite/core.html#quacc.recipes.tblite.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(atoms, method='GFN2-xTB', calc_kwargs=None, opt_swaps=None)\n</code></pre> <p>Relax a structure.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> method             (<code>Literal['GFN1-xTB', 'GFN2-xTB', 'IPEA1-xTB']</code>)         \u2013          <p>GFN0-xTB, GFN1-xTB, GFN2-xTB.</p> </li> <li> calc_kwargs             (<code>dict | None</code>)         \u2013          <p>Dictionary of custom kwargs for the tblite calculator.</p> </li> <li> opt_swaps             (<code>dict | None</code>)         \u2013          <p>Dictionary of custom kwargs for run_ase_opt</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_opt_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/tblite/core.py</code> <pre><code>@ct.electron\n@requires(TBLite, \"tblite must be installed. Try pip install tblite[ase]\")\ndef relax_job(\natoms: Atoms | dict,\nmethod: Literal[\"GFN1-xTB\", \"GFN2-xTB\", \"IPEA1-xTB\"] = \"GFN2-xTB\",\ncalc_kwargs: dict | None = None,\nopt_swaps: dict | None = None,\n) -&gt; OptSchema:\n\"\"\"\n    Relax a structure.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    method\n        GFN0-xTB, GFN1-xTB, GFN2-xTB.\n    calc_kwargs\n        Dictionary of custom kwargs for the tblite calculator.\n    opt_swaps\n        Dictionary of custom kwargs for run_ase_opt\n    Returns\n    -------\n    OptSchema\n        Dictionary of results from quacc.schemas.ase.summarize_opt_run\n    \"\"\"\natoms = atoms if isinstance(atoms, Atoms) else atoms[\"atoms\"]\ncalc_kwargs = calc_kwargs or {}\nopt_swaps = opt_swaps or {}\nopt_defaults = {\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": FIRE}\nopt_flags = opt_defaults | opt_swaps\natoms.calc = TBLite(method=method, **calc_kwargs)\ndyn = run_ase_opt(atoms, **opt_flags)\nreturn summarize_opt_run(dyn, additional_fields={\"name\": \"TBLite Relax\"})\n</code></pre>"},{"location":"reference/quacc/recipes/tblite/core.html#quacc.recipes.tblite.core.static_job","title":"static_job","text":"<pre><code>static_job(atoms, method='GFN2-xTB', calc_kwargs=None)\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> method             (<code>Literal['GFN1-xTB', 'GFN2-xTB', 'IPEA1-xTB']</code>)         \u2013          <p>GFN1-xTB, GFN2-xTB, and IPEA1-xTB.</p> </li> <li> calc_kwargs             (<code>dict | None</code>)         \u2013          <p>Dictionary of custom kwargs for the tblite calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/tblite/core.py</code> <pre><code>@ct.electron\n@requires(TBLite, \"tblite must be installed. Try pip install tblite[ase]\")\ndef static_job(\natoms: Atoms | dict,\nmethod: Literal[\"GFN1-xTB\", \"GFN2-xTB\", \"IPEA1-xTB\"] = \"GFN2-xTB\",\ncalc_kwargs: dict | None = None,\n) -&gt; RunSchema:\n\"\"\"\n    Carry out a single-point calculation.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    method\n        GFN1-xTB, GFN2-xTB, and IPEA1-xTB.\n    calc_kwargs\n        Dictionary of custom kwargs for the tblite calculator.\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from quacc.schemas.ase.summarize_run\n    \"\"\"\natoms = atoms if isinstance(atoms, Atoms) else atoms[\"atoms\"]\ncalc_kwargs = calc_kwargs or {}\natoms.calc = TBLite(method=method, **calc_kwargs)\nfinal_atoms = run_calc(atoms)\nreturn summarize_run(\nfinal_atoms,\ninput_atoms=atoms,\nadditional_fields={\"name\": \"TBLite Static\"},\n)\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/core.html","title":"core","text":"<p>Core recipes for VASP</p>"},{"location":"reference/quacc/recipes/vasp/core.html#quacc.recipes.vasp.core.double_relax_job","title":"double_relax_job","text":"<pre><code>double_relax_job(atoms, preset=None, relax_volume=True, calc_swaps1=None, calc_swaps2=None)\n</code></pre> <p>Double-relax a structure. This is particularly useful for a few reasons:</p> <ol> <li> <p>To carry out a cheaper pre-relaxation before the high-quality run.</p> </li> <li> <p>To carry out a GGA calculation before a meta-GGA or hybrid calculation that requies the GGA wavefunction.</p> </li> <li> <p>To carry out volume relaxations where large changes in volume can require a second relaxation to resolve forces.</p> </li> </ol> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> preset             (<code>str | None</code>)         \u2013          <p>Preset to use.</p> </li> <li> relax_volume             (<code>bool</code>)         \u2013          <p>True if a volume relaxation (ISIF = 3) should be performed. False if only the positions (ISIF = 2) should be updated.</p> </li> <li> calc_swaps1             (<code>dict | None</code>)         \u2013          <p>Dictionary of custom kwargs for the first relaxation.</p> </li> <li> calc_swaps2             (<code>dict | None</code>)         \u2013          <p>Dictionary of custom kwargs for the second relaxation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>{\"relax1\": VaspSchema, \"relax2\": VaspSchema}</code>         \u2013          <p>Dictionaries of the type quacc.schemas.vasp.summarize_run.</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/vasp/core.py</code> <pre><code>@ct.electron\ndef double_relax_job(\natoms: Atoms | dict,\npreset: str | None = None,\nrelax_volume: bool = True,\ncalc_swaps1: dict | None = None,\ncalc_swaps2: dict | None = None,\n) -&gt; dict[Literal[\"relax1\", \"relax2\"], VaspSchema]:\n\"\"\"\n    Double-relax a structure. This is particularly useful for a few reasons:\n    1. To carry out a cheaper pre-relaxation before the high-quality run.\n    2. To carry out a GGA calculation before a meta-GGA or hybrid calculation\n    that requies the GGA wavefunction.\n    3. To carry out volume relaxations where large changes in volume\n    can require a second relaxation to resolve forces.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    preset\n        Preset to use.\n    relax_volume\n        True if a volume relaxation (ISIF = 3) should be performed.\n        False if only the positions (ISIF = 2) should be updated.\n    calc_swaps1\n        Dictionary of custom kwargs for the first relaxation.\n    calc_swaps2\n        Dictionary of custom kwargs for the second relaxation.\n    Returns\n    -------\n    {\"relax1\": VaspSchema, \"relax2\": VaspSchema}\n        Dictionaries of the type quacc.schemas.vasp.summarize_run.\n    \"\"\"\natoms = atoms if isinstance(atoms, Atoms) else atoms[\"atoms\"]\ncalc_swaps1 = calc_swaps1 or {}\ncalc_swaps2 = calc_swaps2 or {}\ndefaults = {\n\"ediffg\": -0.02,\n\"isif\": 3 if relax_volume else 2,\n\"ibrion\": 2,\n\"isym\": 0,\n\"lcharg\": False,\n\"lwave\": True,\n\"nsw\": 200,\n}\n# Run first relaxation\nflags = defaults | calc_swaps1\ncalc = Vasp(atoms, preset=preset, **flags)\natoms.calc = calc\nkpts1 = atoms.calc.kpts\natoms = run_calc(atoms)\nsummary1 = summarize_run(atoms, additional_fields={\"name\": \"VASP DoubleRelax 1\"})\n# Run second relaxation\nflags = defaults | calc_swaps2\ncalc = Vasp(summary1[\"atoms\"], preset=preset, **flags)\natoms.calc = calc\nkpts2 = atoms.calc.kpts\n# Use ISTART = 0 if this goes from vasp_gam --&gt; vasp_std\nif kpts1 == [1, 1, 1] and kpts2 != [1, 1, 1]:\natoms.calc.set(istart=0)\natoms = run_calc(atoms, copy_files=[\"WAVECAR\"])\nsummary2 = summarize_run(atoms, additional_fields={\"name\": \"VASP DoubleRelax 2\"})\nreturn {\"relax1\": summary1, \"relax2\": summary2}\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/core.html#quacc.recipes.vasp.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(atoms, preset=None, relax_volume=True, calc_swaps=None)\n</code></pre> <p>Relax a structure.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> preset             (<code>str | None</code>)         \u2013          <p>Preset to use.</p> </li> <li> relax_volume             (<code>bool</code>)         \u2013          <p>True if a volume relaxation (ISIF = 3) should be performed. False if only the positions (ISIF = 2) should be updated.</p> </li> <li> calc_swaps             (<code>dict | None</code>)         \u2013          <p>Dictionary of custom kwargs for the calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.vasp.summarize_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/vasp/core.py</code> <pre><code>@ct.electron\ndef relax_job(\natoms: Atoms | dict,\npreset: str | None = None,\nrelax_volume: bool = True,\ncalc_swaps: dict | None = None,\n) -&gt; VaspSchema:\n\"\"\"\n    Relax a structure.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    preset\n        Preset to use.\n    relax_volume\n        True if a volume relaxation (ISIF = 3) should be performed.\n        False if only the positions (ISIF = 2) should be updated.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator.\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from quacc.schemas.vasp.summarize_run\n    \"\"\"\natoms = atoms if isinstance(atoms, Atoms) else atoms[\"atoms\"]\ncalc_swaps = calc_swaps or {}\ndefaults = {\n\"ediffg\": -0.02,\n\"isif\": 3 if relax_volume else 2,\n\"ibrion\": 2,\n\"isym\": 0,\n\"lcharg\": False,\n\"lwave\": False,\n\"nsw\": 200,\n}\nflags = defaults | calc_swaps\ncalc = Vasp(atoms, preset=preset, **flags)\natoms.calc = calc\natoms = run_calc(atoms)\nreturn summarize_run(atoms, additional_fields={\"name\": \"VASP Relax\"})\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/core.html#quacc.recipes.vasp.core.static_job","title":"static_job","text":"<pre><code>static_job(atoms, preset=None, calc_swaps=None)\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> preset             (<code>str | None</code>)         \u2013          <p>Preset to use.</p> </li> <li> calc_swaps             (<code>dict | None</code>)         \u2013          <p>Dictionary of custom kwargs for the calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.vasp.summarize_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/vasp/core.py</code> <pre><code>@ct.electron\ndef static_job(\natoms: Atoms | dict,\npreset: str | None = None,\ncalc_swaps: dict | None = None,\n) -&gt; VaspSchema:\n\"\"\"\n    Carry out a single-point calculation.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    preset\n        Preset to use.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator.\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from quacc.schemas.vasp.summarize_run\n    \"\"\"\natoms = atoms if isinstance(atoms, Atoms) else atoms[\"atoms\"]\ncalc_swaps = calc_swaps or {}\ndefaults = {\n\"ismear\": -5,\n\"laechg\": True,\n\"lcharg\": True,\n\"lwave\": True,\n\"nedos\": 5001,\n\"nsw\": 0,\n}\nflags = defaults | calc_swaps\ncalc = Vasp(atoms, preset=preset, **flags)\natoms.calc = calc\natoms = run_calc(atoms)\nreturn summarize_run(atoms, additional_fields={\"name\": \"VASP Static\"})\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mp.html","title":"mp","text":"<p>Materials Project-compatible recipes</p> <p>This set of recipes is meant to be compatible with the Materials Project Reference: https://doi.org/10.1103/PhysRevMaterials.6.013801</p>"},{"location":"reference/quacc/recipes/vasp/mp.html#quacc.recipes.vasp.mp.mp_prerelax_job","title":"mp_prerelax_job","text":"<pre><code>mp_prerelax_job(atoms, preset='MPScanSet', calc_swaps=None)\n</code></pre> <p>Function to pre-relax a structure with Materials Project settings. By default, this uses a PBEsol pre-relax step.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> preset             (<code>str | None</code>)         \u2013          <p>Preset to use.</p> </li> <li> calc_swaps             (<code>dict | None</code>)         \u2013          <p>Dictionary of custom kwargs for the calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.vasp.summarize_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/vasp/mp.py</code> <pre><code>@ct.electron\ndef mp_prerelax_job(\natoms: Atoms | dict,\npreset: str | None = \"MPScanSet\",\ncalc_swaps: dict | None = None,\n) -&gt; VaspSchema:\n\"\"\"\n    Function to pre-relax a structure with Materials Project settings.\n    By default, this uses a PBEsol pre-relax step.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    preset\n        Preset to use.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator.\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from quacc.schemas.vasp.summarize_run\n    \"\"\"\natoms = atoms if isinstance(atoms, Atoms) else atoms[\"atoms\"]\ncalc_swaps = calc_swaps or {}\ndefaults = {\"ediffg\": -0.05, \"xc\": \"pbesol\"}\nflags = defaults | calc_swaps\ncalc = Vasp(atoms, preset=preset, **flags)\natoms.calc = calc\natoms = run_calc(atoms)\nreturn summarize_run(atoms, additional_fields={\"name\": \"MP-Prerelax\"})\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mp.html#quacc.recipes.vasp.mp.mp_relax_flow","title":"mp_relax_flow","text":"<pre><code>mp_relax_flow(atoms, prerelax_electron=mp_prerelax_job, relax_electron=mp_relax_job, prerelax_kwargs=None, relax_kwargs=None)\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>MP-compatible pre-relax</p> </li> <li> <p>MP-compatible relax</p> </li> </ol> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object for the structure.</p> </li> <li> prerelax_electron             (<code>ct.electron | None</code>)         \u2013          <p>Default to use for the pre-relaxation.</p> </li> <li> relax_electron             (<code>ct.electron | None</code>)         \u2013          <p>Default to use for the relaxation.</p> </li> <li> prerelax_kwargs             (<code>dict | None</code>)         \u2013          <p>Additional keyword arguments to pass to the pre-relaxation calculation.</p> </li> <li> relax_kwargs             (<code>dict | None</code>)         \u2013          <p>Additional keyword arguments to pass to the relaxation calculation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary results from quacc.schemas.vasp.summarize_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/vasp/mp.py</code> <pre><code>def mp_relax_flow(\natoms: Atoms | dict,\nprerelax_electron: ct.electron | None = mp_prerelax_job,\nrelax_electron: ct.electron | None = mp_relax_job,\nprerelax_kwargs: dict | None = None,\nrelax_kwargs: dict | None = None,\n) -&gt; VaspSchema:\n\"\"\"\n    Workflow consisting of:\n    1. MP-compatible pre-relax\n    2. MP-compatible relax\n    Parameters\n    ----------\n    atoms\n        Atoms object for the structure.\n    prerelax_electron\n        Default to use for the pre-relaxation.\n    relax_electron\n        Default to use for the relaxation.\n    prerelax_kwargs\n        Additional keyword arguments to pass to the pre-relaxation calculation.\n    relax_kwargs\n        Additional keyword arguments to pass to the relaxation calculation.\n    Returns\n    -------\n    VaspSchema\n        Dictionary results from quacc.schemas.vasp.summarize_run\n    \"\"\"\nprerelax_kwargs = prerelax_kwargs or {}\nrelax_kwargs = relax_kwargs or {}\n# Run the prerelax\nprerelax_results = prerelax_electron(atoms, **prerelax_kwargs)\n# Update KSPACING arguments\nbandgap = prerelax_results[\"output\"][\"bandgap\"]\nif bandgap &lt; 1e-4:\nkspacing_swaps = {\"kspacing\": 0.22, \"sigma\": 0.2, \"ismear\": 2, \"kpts\": None}\nelse:\nrmin = 25.22 - 2.87 * bandgap\nkspacing = 2 * np.pi * 1.0265 / (rmin - 1.0183)\nkspacing_swaps = {\n\"kspacing\": min(kspacing, 0.44),\n\"ismear\": -5,\n\"sigma\": 0.05,\n\"kpts\": None,\n}\nrelax_kwargs[\"calc_swaps\"] = kspacing_swaps | relax_kwargs.get(\"calc_swaps\", {})\n# TODO: Also, copy the WAVECAR from the prerelaxation to the relaxation\n# Run the relax\nreturn relax_electron(prerelax_results, **relax_kwargs)\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mp.html#quacc.recipes.vasp.mp.mp_relax_job","title":"mp_relax_job","text":"<pre><code>mp_relax_job(atoms, preset='MPScanSet', calc_swaps=None)\n</code></pre> <p>Function to relax a structure with Materials Project settings. By default, this uses an r2SCAN relax step.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> preset             (<code>str | None</code>)         \u2013          <p>Preset to use.</p> </li> <li> calc_swaps             (<code>dict | None</code>)         \u2013          <p>Dictionary of custom kwargs for the calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.vasp.summarize_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/vasp/mp.py</code> <pre><code>@ct.electron\ndef mp_relax_job(\natoms: Atoms | dict,\npreset: str | None = \"MPScanSet\",\ncalc_swaps: dict | None = None,\n) -&gt; VaspSchema:\n\"\"\"\n    Function to relax a structure with Materials Project settings.\n    By default, this uses an r2SCAN relax step.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    preset\n        Preset to use.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator.\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from quacc.schemas.vasp.summarize_run\n    \"\"\"\natoms = atoms if isinstance(atoms, Atoms) else atoms[\"atoms\"]\ncalc_swaps = calc_swaps or {}\ncalc = Vasp(atoms, preset=preset, **calc_swaps)\natoms.calc = calc\natoms = run_calc(atoms)\nreturn summarize_run(atoms, additional_fields={\"name\": \"MP-Relax\"})\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/qmof.html","title":"qmof","text":"<p>QMOF-compatible recipes</p> <p>This set of recipes is meant to be compatible with the QMOF Database workflow. Reference: https://doi.org/10.1016/j.matt.2021.02.015</p>"},{"location":"reference/quacc/recipes/vasp/qmof.html#quacc.recipes.vasp.qmof.qmof_relax_job","title":"qmof_relax_job","text":"<pre><code>qmof_relax_job(atoms, preset='QMOFSet', relax_volume=True, run_prerelax=True, calc_swaps=None)\n</code></pre> <p>Relax a structure in a multi-step process for increased computational efficiency. This is all done in a single compute job. Settings are such that they are compatible with the QMOF Database.</p> <ol> <li> <p>A \"pre-relaxation\" with BFGSLineSearch to resolve very high forces.</p> </li> <li> <p>Position relaxation with default ENCUT and coarse k-point grid.</p> </li> <li> <p>Optional: volume relaxation with coarse k-point grid.</p> </li> <li> <p>Double relaxation using production-quality settings.</p> </li> <li> <p>Static calculation.</p> </li> </ol> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> preset             (<code>str | None</code>)         \u2013          <p>Preset to use. Applies for all jobs.</p> </li> <li> relax_volume             (<code>bool</code>)         \u2013          <p>True if a volume relaxation should be performed. False if only the positions should be updated.</p> </li> <li> run_prerelax             (<code>bool</code>)         \u2013          <p>If True, a pre-relax will be carried out with BFGSLineSearch. Recommended if starting from hypothetical structures or materials with very high starting forces.</p> </li> <li> calc_swaps             (<code>dict | None</code>)         \u2013          <p>Dictionary of custom kwargs for the calculator. Applies for all jobs.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary of results</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/vasp/qmof.py</code> <pre><code>@ct.electron\ndef qmof_relax_job(\natoms: Atoms | dict,\npreset: str | None = \"QMOFSet\",\nrelax_volume: bool = True,\nrun_prerelax: bool = True,\ncalc_swaps: dict | None = None,\n) -&gt; dict[\nLiteral[\n\"prerelax-lowacc\",\n\"position-relax-lowacc\",\n\"volume-relax-lowacc\",\n\"double-relax\",\n\"static\",\n],\nVaspSchema,\n]:\n\"\"\"\n    Relax a structure in a multi-step process for increased\n    computational efficiency. This is all done in a single compute job.\n    Settings are such that they are compatible with the QMOF Database.\n    1. A \"pre-relaxation\" with BFGSLineSearch to resolve very high forces.\n    2. Position relaxation with default ENCUT and coarse k-point grid.\n    3. Optional: volume relaxation with coarse k-point grid.\n    4. Double relaxation using production-quality settings.\n    5. Static calculation.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    preset\n        Preset to use. Applies for all jobs.\n    relax_volume\n        True if a volume relaxation should be performed.\n        False if only the positions should be updated.\n    run_prerelax\n        If True, a pre-relax will be carried out with BFGSLineSearch.\n        Recommended if starting from hypothetical structures or materials\n        with very high starting forces.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator. Applies for all jobs.\n    Returns\n    -------\n    dict\n        Dictionary of results\n    \"\"\"\natoms = atoms if isinstance(atoms, Atoms) else atoms[\"atoms\"]\ncalc_swaps = calc_swaps or {}\n# 1. Pre-relaxation\nif run_prerelax:\nsummary1 = _prerelax(atoms, preset, calc_swaps, fmax=5.0)\natoms = summary1[\"atoms\"]\n# 2. Position relaxation (loose)\nsummary2 = _loose_relax_positions(atoms, preset, calc_swaps)\natoms = summary2[\"atoms\"]\n# 3. Optional: Volume relaxation (loose)\nif relax_volume:\nsummary3 = _loose_relax_volume(atoms, preset, calc_swaps)\natoms = summary3[\"atoms\"]\n# 4. Double Relaxation\n# This is done for two reasons: a) because it can resolve repadding\n# issues when dV is large; b) because we can use LREAL = Auto for the\n# first relaxation and the default LREAL for the second.\nsummary4 = _double_relax(atoms, preset, calc_swaps, relax_volume=relax_volume)\natoms = summary4[1][\"atoms\"]\n# 5. Static Calculation\nsummary5 = _static(atoms, preset, calc_swaps)\nreturn {\n\"prerelax-lowacc\": summary1 if run_prerelax else None,\n\"position-relax-lowacc\": summary2,\n\"volume-relax-lowacc\": summary3 if relax_volume else None,\n\"double-relax\": summary4,\n\"static\": summary5,\n}\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/slabs.html","title":"slabs","text":"<p>Recipes for slabs</p>"},{"location":"reference/quacc/recipes/vasp/slabs.html#quacc.recipes.vasp.slabs.bulk_to_slabs_flow","title":"bulk_to_slabs_flow","text":"<pre><code>bulk_to_slabs_flow(atoms, slabgen_kwargs=None, slab_relax_electron=slab_relax_job, slab_static_electron=slab_static_job, slab_relax_kwargs=None, slab_static_kwargs=None)\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>Slab generation</p> </li> <li> <p>Slab relaxations</p> </li> <li> <p>Slab statics (optional)</p> </li> </ol> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>Atoms object for the structure.</p> </li> <li> slabgen_kwargs             (<code>dict | None</code>)         \u2013          <p>Additional keyword arguments to pass to make_max_slabs_from_bulk()</p> </li> <li> slab_relax_electron             (<code>ct.electron</code>)         \u2013          <p>Default to use for the relaxation of the slab structures.</p> </li> <li> slab_static_electron             (<code>ct.electron | None</code>)         \u2013          <p>Default to use for the static calculation of the slab structures.</p> </li> <li> slab_relax_kwargs             (<code>dict | None</code>)         \u2013          <p>Additional keyword arguments to pass to the relaxation calculation.</p> </li> <li> slab_static_kwargs             (<code>dict | None</code>)         \u2013          <p>Additional keyword arguments to pass to the static calculation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[VaspSchema]</code>         \u2013          <p>List of dictionary results from quacc.schemas.vasp.summarize_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/vasp/slabs.py</code> <pre><code>def bulk_to_slabs_flow(\natoms: Atoms,\nslabgen_kwargs: dict | None = None,\nslab_relax_electron: ct.electron = slab_relax_job,\nslab_static_electron: ct.electron | None = slab_static_job,\nslab_relax_kwargs: dict | None = None,\nslab_static_kwargs: dict | None = None,\n) -&gt; list[VaspSchema]:\n\"\"\"\n    Workflow consisting of:\n    1. Slab generation\n    2. Slab relaxations\n    3. Slab statics (optional)\n    Parameters\n    ----------\n    atoms\n        Atoms object for the structure.\n    slabgen_kwargs\n        Additional keyword arguments to pass to make_max_slabs_from_bulk()\n    slab_relax_electron\n        Default to use for the relaxation of the slab structures.\n    slab_static_electron\n        Default to use for the static calculation of the slab structures.\n    slab_relax_kwargs\n        Additional keyword arguments to pass to the relaxation calculation.\n    slab_static_kwargs\n        Additional keyword arguments to pass to the static calculation.\n    Returns\n    -------\n    list[VaspSchema]\n        List of dictionary results from quacc.schemas.vasp.summarize_run\n    \"\"\"\nslab_relax_kwargs = slab_relax_kwargs or {}\nslab_static_kwargs = slab_static_kwargs or {}\nslabgen_kwargs = slabgen_kwargs or {}\n@ct.electron\n@ct.lattice\ndef _relax_distributed(slabs):\nreturn [slab_relax_electron(slab, **slab_relax_kwargs) for slab in slabs]\n@ct.electron\n@ct.lattice\ndef _relax_and_static_distributed(slabs):\nreturn [\nslab_static_electron(\nslab_relax_electron(slab, **slab_relax_kwargs),\n**slab_static_kwargs,\n)\nfor slab in slabs\n]\nslabs = ct.electron(make_max_slabs_from_bulk)(atoms, **slabgen_kwargs)\nif slab_static_electron is None:\nreturn _relax_distributed(slabs)\nreturn _relax_and_static_distributed(slabs)\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/slabs.html#quacc.recipes.vasp.slabs.slab_relax_job","title":"slab_relax_job","text":"<pre><code>slab_relax_job(atoms, preset=None, calc_swaps=None)\n</code></pre> <p>Function to relax a slab.</p> <p>Parameters atoms     Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value preset     Preset to use. calc_swaps     Dictionary of custom kwargs for the calculator.</p> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.vasp.summarize_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/vasp/slabs.py</code> <pre><code>@ct.electron\ndef slab_relax_job(\natoms: Atoms | dict,\npreset: str | None = None,\ncalc_swaps: dict | None = None,\n) -&gt; VaspSchema:\n\"\"\"\n    Function to relax a slab.\n    Parameters\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    preset\n        Preset to use.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator.\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from quacc.schemas.vasp.summarize_run\n    \"\"\"\natoms = atoms if isinstance(atoms, Atoms) else atoms[\"atoms\"]\ncalc_swaps = calc_swaps or {}\ndefaults = {\n\"auto_dipole\": True,\n\"ediffg\": -0.02,\n\"isif\": 2,\n\"ibrion\": 2,\n\"isym\": 0,\n\"lcharg\": False,\n\"lwave\": False,\n\"nsw\": 200,\n}\nflags = defaults | calc_swaps\ncalc = Vasp(atoms, preset=preset, **flags)\natoms.calc = calc\natoms = run_calc(atoms)\nreturn summarize_run(atoms, additional_fields={\"name\": \"VASP Slab Relax\"})\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/slabs.html#quacc.recipes.vasp.slabs.slab_static_job","title":"slab_static_job","text":"<pre><code>slab_static_job(atoms, preset=None, calc_swaps=None)\n</code></pre> <p>Function to carry out a single-point calculation on a slab.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> preset             (<code>str | None</code>)         \u2013          <p>Preset to use.</p> </li> <li> calc_swaps             (<code>dict | None</code>)         \u2013          <p>dictionary of custom kwargs for the calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.vasp.summarize_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/vasp/slabs.py</code> <pre><code>@ct.electron\ndef slab_static_job(\natoms: Atoms | dict,\npreset: str | None = None,\ncalc_swaps: dict | None = None,\n) -&gt; VaspSchema:\n\"\"\"\n    Function to carry out a single-point calculation on a slab.\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value\n    preset\n        Preset to use.\n    calc_swaps\n        dictionary of custom kwargs for the calculator.\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from quacc.schemas.vasp.summarize_run\n    \"\"\"\natoms = atoms if isinstance(atoms, Atoms) else atoms[\"atoms\"]\ncalc_swaps = calc_swaps or {}\ndefaults = {\n\"auto_dipole\": True,\n\"ismear\": -5,\n\"laechg\": True,\n\"lcharg\": True,\n\"lvhar\": True,\n\"lwave\": True,\n\"nedos\": 5001,\n\"nsw\": 0,\n}\nflags = defaults | calc_swaps\ncalc = Vasp(atoms, preset=preset, **flags)\natoms.calc = calc\natoms = run_calc(atoms)\nreturn summarize_run(atoms, additional_fields={\"name\": \"VASP Slab Static\"})\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/slabs.html#quacc.recipes.vasp.slabs.slab_to_ads_flow","title":"slab_to_ads_flow","text":"<pre><code>slab_to_ads_flow(slab, adsorbate, make_ads_kwargs=None, slab_relax_electron=ct.electron(slab_relax_job), slab_static_electron=ct.electron(slab_static_job), slab_relax_kwargs=None, slab_static_kwargs=None)\n</code></pre> <p>Workflow consisting of: 1. Slab-adsorbate generation 2. Slab-adsorbate relaxations 3. Slab-adsorbate statics (optional)</p> <p>Parameters:</p> <ul> <li> slab             (<code>Atoms</code>)         \u2013          <p>Atoms object for the slab structure.</p> </li> <li> adsorbate             (<code>Atoms</code>)         \u2013          <p>Atoms object for the adsorbate.</p> </li> <li> make_ads_kwargs             (<code>dict | None</code>)         \u2013          <p>Additional keyword arguments to pass to make_adsorbate_structures()</p> </li> <li> slab_relax_electron             (<code>ct.electron</code>)         \u2013          <p>Default to use for the relaxation of the slab structure.</p> </li> <li> slab_static_electron             (<code>ct.electron | None</code>)         \u2013          <p>Default to use for the static calculation of the slab structures.</p> </li> <li> slab_relax_kwargs             (<code>dict | None</code>)         \u2013          <p>Additional keyword arguments to pass to the relaxation calculation.</p> </li> <li> slab_static_kwargs             (<code>dict | None</code>)         \u2013          <p>Additional keyword arguments to pass to the static calculation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[VaspSchema]</code>         \u2013          <p>List of dictionaries of results from quacc.schemas.vasp.summarize_run</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/recipes/vasp/slabs.py</code> <pre><code>def slab_to_ads_flow(\nslab: Atoms,\nadsorbate: Atoms,\nmake_ads_kwargs: dict | None = None,\nslab_relax_electron: ct.electron = ct.electron(slab_relax_job),\nslab_static_electron: ct.electron | None = ct.electron(slab_static_job),\nslab_relax_kwargs: dict | None = None,\nslab_static_kwargs: dict | None = None,\n) -&gt; list[VaspSchema]:\n\"\"\"\n    Workflow consisting of:\n    1. Slab-adsorbate generation\n    2. Slab-adsorbate relaxations\n    3. Slab-adsorbate statics (optional)\n    Parameters\n    ----------\n    slab\n        Atoms object for the slab structure.\n    adsorbate\n        Atoms object for the adsorbate.\n    make_ads_kwargs\n        Additional keyword arguments to pass to make_adsorbate_structures()\n    slab_relax_electron\n        Default to use for the relaxation of the slab structure.\n    slab_static_electron\n        Default to use for the static calculation of the slab structures.\n    slab_relax_kwargs\n        Additional keyword arguments to pass to the relaxation calculation.\n    slab_static_kwargs\n        Additional keyword arguments to pass to the static calculation.\n    Returns\n    -------\n    list[VaspSchema]\n        List of dictionaries of results from quacc.schemas.vasp.summarize_run\n    \"\"\"\nslab_relax_kwargs = slab_relax_kwargs or {}\nslab_static_kwargs = slab_static_kwargs or {}\nmake_ads_kwargs = make_ads_kwargs or {}\n@ct.electron\n@ct.lattice\ndef _relax_distributed(slabs):\nreturn [slab_relax_electron(slab, **slab_relax_kwargs) for slab in slabs]\n@ct.electron\n@ct.lattice\ndef _relax_and_static_distributed(slabs):\nreturn [\nslab_static_electron(\nslab_relax_electron(slab, **slab_relax_kwargs),\n**slab_static_kwargs,\n)\nfor slab in slabs\n]\nads_slabs = ct.electron(make_adsorbate_structures)(\nslab, adsorbate, **make_ads_kwargs\n)\nif slab_static_electron is None:\nreturn _relax_distributed(ads_slabs)\nreturn _relax_and_static_distributed(ads_slabs)\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html","title":"ase","text":"<p>Schemas for storing ASE-based data</p>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.summarize_opt_run","title":"summarize_opt_run","text":"<pre><code>summarize_opt_run(dyn, trajectory=None, check_convergence=True, charge_and_multiplicity=None, prep_next_run=True, remove_empties=False, additional_fields=None)\n</code></pre> <p>Get tabulated results from an ASE Atoms trajectory and store them in a database-friendly format. This is meant to be compatible with all calculator types.</p> <p>Parameters:</p> <ul> <li> dyn             (<code>Optimizer</code>)         \u2013          <p>ASE Optimizer object.</p> </li> <li> trajectory             (<code>Trajectory | list[Atoms]</code>)         \u2013          <p>ASE Trajectory object or list[Atoms] from reading a trajectory file. If None, the trajectory must be found in dyn.traj_atoms.</p> </li> <li> check_convergence             (<code>bool</code>)         \u2013          <p>Whether to check the convergence of the calculation.</p> </li> <li> charge_and_multiplicity             (<code>tuple[int, int] | None</code>)         \u2013          <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> <li> prep_next_run             (<code>bool</code>)         \u2013          <p>Whether the Atoms object stored in {\"atoms\": atoms} should be prepared for the next run This clears out any attached calculator and moves the final magmoms to the initial magmoms.</p> </li> <li> remove_empties             (<code>bool</code>)         \u2013          <p>Whether to remove None values and empty lists/dicts from the task document.</p> </li> <li> additional_fields             (<code>dict | None</code>)         \u2013          <p>Additional fields to add to the task document.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary representation of the task document with the following fields:</p> <ul> <li>atoms: Atoms = Field(None, title = \"The Atoms object from the calculation result.\")</li> <li>atoms_info: dict = Field(None, title = \"The Atoms object info obtained from atoms.info.\")</li> <li>builder_meta: EmmetMeta = Field(default_factory=EmmetMeta, description=\"Builder metadata.\"):</li> <li>builder_meta.build_date: str = Field(default_factory=datetime.utcnow, description=\"The build date for this document.\")</li> <li>builder_meta.database_version: str = Field(None, description=\"The database version for the built data.\")</li> <li>builder_meta.emmet_version: str = Field(version, description=\"The version of emmet this document was built with.\")</li> <li>builder_meta.pymatgen_version: str = Field(pmg_version, description=\"The version of pymatgen this document was built with.\")</li> <li>builder_meta.pull_request: int = Field(None, description=\"The pull request number associated with this data build.\")</li> <li>dir_name: str = Field(None, description=\"Directory where the output is parsed\")</li> <li>input_structure: Molecule | Structure = Field(None, title = \"The Pymatgen Structure or Molecule object from the input Atoms object if input_atoms is not None.\")</li> <li>nid: str = Field(None, title = \"The node ID representing the machine where the calculation was run.\")</li> <li>parameters: dict = Field(None, title = \"the parameters used to run the calculation.\")</li> <li>opt_parameters: dict = Field(None, title = \"the parameters used to run the optimization.\")</li> <li>results: dict = Field(None, title = \"The results from the calculation.\")</li> <li>trajectory: List[Atoms] = Trajectory of Atoms objects</li> <li>trajectory_results: List[dict] = List of ase.calc.results from the trajectory</li> </ul> <p>For periodic structures, the task document also has the following fields:</p> <ul> <li>chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the material.\")</li> <li>composition: Composition = Field(None, description=\"Full composition for the material.\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition.\")</li> <li>density: float = Field(None, title=\"Density\", description=\"Density in grams per cm^3.\")</li> <li>density_atomic: float = Field(None, title=\"Packing Density\", description=\"The atomic packing density in atoms per cm^3.\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in the material.\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula.\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")</li> <li>nelements: int = Field(None, description=\"Number of elements.\")</li> <li>nsites: int = Field(None, description=\"Total number of sites in the structure.\")</li> <li>structure: Structure = Field(None, title = \"The Pymatgen Structure object from the Atoms object, if periodic and store_pmg is True.\")</li> <li>symmetry: SymmetryData = Field(None, description=\"Symmetry data for this material.\")</li> <li>symmetry.crystal_system: CrystalSystem = Field(None, title=\"Crystal System\", description=\"The crystal system for this lattice.\")</li> <li>symmetry.number: int = Field(None, title=\"Space Group Number\", description=\"The spacegroup number for the lattice.\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice.\")</li> <li>symmetry.symbol: str = Field(None, title=\"Space Group Symbol\", description=\"The spacegroup symbol for the lattice.\")</li> <li>symmetry.symprec: float = Field(None, title=\"Symmetry Finding Precision\", description=\"The precision given to spglib to determine the symmetry of this lattice.\")</li> <li>volume: float = Field(None, title=\"Volume\", description=\"Total volume for this structure in Angstroms^3.\")</li> </ul> <p>For molecules that lack periodicity, the task document also has the following fields:</p> <ul> <li>charge: int = Field(None, description=\"Charge of the molecule\")</li> <li>chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the molecule\")</li> <li>composition: Composition = Field(None, description=\"Full composition for the molecule\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in the molecule\")</li> <li>formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\", description=\"Alphabetical molecular formula\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")</li> <li>molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object from the Atoms object, if not periodic and store_pmg is True.\")</li> <li>natoms: int = Field(None, description=\"Total number of atoms in the molecule\")</li> <li>nelectrons: int = Field(None, title=\"Number of electrons\", description=\"The total number of electrons for the molecule\")</li> <li>nelements: int = Field(None, title=\"Number of Elements\")</li> <li>spin_multiplicity: int = Field(None, description=\"Spin multiplicity of the molecule\")</li> <li>symmetry: PointGroupData = Field(None, description=\"Symmetry data for this molecule\")</li> <li>symmetry.eigen_tolerance: float = Field(None, title=\"Interia Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare eigen values of the inertia tensor.\")</li> <li>symmetry.linear: bool = Field(None, title=\"Molecule Linearity\", description=\"Is the molecule linear?\")</li> <li>symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry Operation Matrix Element Tolerance\" description=\"Tolerance used to generate the full set of symmetry operations of the point group.\")</li> <li>symmetry.rotation_number: float = Field(None, title=\"Rotational Symmetry Number\", description=\"Rotational symmetry number for the molecule\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice\")</li> <li>symmetry.tolerance: float = Field(None, title=\"Point Group Analyzer Tolerance\", description=\"Distance tolerance to consider sites as symmetrically equivalent.\")</li> </ul> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/schemas/ase.py</code> <pre><code>def summarize_opt_run(\ndyn: Optimizer,\ntrajectory: Trajectory | list[Atoms] = None,\ncheck_convergence: bool = True,\ncharge_and_multiplicity: tuple[int, int] | None = None,\nprep_next_run: bool = True,\nremove_empties: bool = False,\nadditional_fields: dict | None = None,\n) -&gt; OptSchema:\n\"\"\"\n    Get tabulated results from an ASE Atoms trajectory and store them in a database-friendly format.\n    This is meant to be compatible with all calculator types.\n    Parameters\n    ----------\n    dyn\n        ASE Optimizer object.\n    trajectory\n        ASE Trajectory object or list[Atoms] from reading a trajectory file.\n        If None, the trajectory must be found in dyn.traj_atoms.\n    check_convergence\n        Whether to check the convergence of the calculation.\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.\n    prep_next_run\n        Whether the Atoms object stored in {\"atoms\": atoms} should be prepared for the next run\n        This clears out any attached calculator and moves the final magmoms to the initial magmoms.\n    remove_empties\n        Whether to remove None values and empty lists/dicts from the task document.\n    additional_fields\n        Additional fields to add to the task document.\n    Returns\n    -------\n    dict\n        Dictionary representation of the task document with the following fields:\n        - atoms: Atoms = Field(None, title = \"The Atoms object from the calculation result.\")\n        - atoms_info: dict = Field(None, title = \"The Atoms object info obtained from atoms.info.\")\n        - builder_meta: EmmetMeta = Field(default_factory=EmmetMeta, description=\"Builder metadata.\"):\n            - builder_meta.build_date: str = Field(default_factory=datetime.utcnow, description=\"The build date for this document.\")\n            - builder_meta.database_version: str = Field(None, description=\"The database version for the built data.\")\n            - builder_meta.emmet_version: str = Field(__version__, description=\"The version of emmet this document was built with.\")\n            - builder_meta.pymatgen_version: str = Field(pmg_version, description=\"The version of pymatgen this document was built with.\")\n            - builder_meta.pull_request: int = Field(None, description=\"The pull request number associated with this data build.\")\n        - dir_name: str = Field(None, description=\"Directory where the output is parsed\")\n        - input_structure: Molecule | Structure = Field(None, title = \"The Pymatgen Structure or Molecule object from the input Atoms object if input_atoms is not None.\")\n        - nid: str = Field(None, title = \"The node ID representing the machine where the calculation was run.\")\n        - parameters: dict = Field(None, title = \"the parameters used to run the calculation.\")\n        - opt_parameters: dict = Field(None, title = \"the parameters used to run the optimization.\")\n        - results: dict = Field(None, title = \"The results from the calculation.\")\n        - trajectory: List[Atoms] = Trajectory of Atoms objects\n        - trajectory_results: List[dict] = List of ase.calc.results from the trajectory\n        For periodic structures, the task document also has the following fields:\n        - chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the material.\")\n        - composition: Composition = Field(None, description=\"Full composition for the material.\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition.\")\n        - density: float = Field(None, title=\"Density\", description=\"Density in grams per cm^3.\")\n        - density_atomic: float = Field(None, title=\"Packing Density\", description=\"The atomic packing density in atoms per cm^3.\")\n        - elements: List[Element] = Field(None, description=\"List of elements in the material.\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula.\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")\n        - nelements: int = Field(None, description=\"Number of elements.\")\n        - nsites: int = Field(None, description=\"Total number of sites in the structure.\")\n        - structure: Structure = Field(None, title = \"The Pymatgen Structure object from the Atoms object, if periodic and store_pmg is True.\")\n        - symmetry: SymmetryData = Field(None, description=\"Symmetry data for this material.\")\n            - symmetry.crystal_system: CrystalSystem = Field(None, title=\"Crystal System\", description=\"The crystal system for this lattice.\")\n            - symmetry.number: int = Field(None, title=\"Space Group Number\", description=\"The spacegroup number for the lattice.\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice.\")\n            - symmetry.symbol: str = Field(None, title=\"Space Group Symbol\", description=\"The spacegroup symbol for the lattice.\")\n            - symmetry.symprec: float = Field(None, title=\"Symmetry Finding Precision\", description=\"The precision given to spglib to determine the symmetry of this lattice.\")\n        - volume: float = Field(None, title=\"Volume\", description=\"Total volume for this structure in Angstroms^3.\")\n        For molecules that lack periodicity, the task document also has the following fields:\n        - charge: int = Field(None, description=\"Charge of the molecule\")\n        - chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the molecule\")\n        - composition: Composition = Field(None, description=\"Full composition for the molecule\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition\")\n        - elements: List[Element] = Field(None, description=\"List of elements in the molecule\")\n        - formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\", description=\"Alphabetical molecular formula\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")\n        - molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object from the Atoms object, if not periodic and store_pmg is True.\")\n        - natoms: int = Field(None, description=\"Total number of atoms in the molecule\")\n        - nelectrons: int = Field(None, title=\"Number of electrons\", description=\"The total number of electrons for the molecule\")\n        - nelements: int = Field(None, title=\"Number of Elements\")\n        - spin_multiplicity: int = Field(None, description=\"Spin multiplicity of the molecule\")\n        - symmetry: PointGroupData = Field(None, description=\"Symmetry data for this molecule\")\n            - symmetry.eigen_tolerance: float = Field(None, title=\"Interia Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare eigen values of the inertia tensor.\")\n            - symmetry.linear: bool = Field(None, title=\"Molecule Linearity\", description=\"Is the molecule linear?\")\n            - symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry Operation Matrix Element Tolerance\" description=\"Tolerance used to generate the full set of symmetry operations of the point group.\")\n            - symmetry.rotation_number: float = Field(None, title=\"Rotational Symmetry Number\", description=\"Rotational symmetry number for the molecule\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice\")\n            - symmetry.tolerance: float = Field(None, title=\"Point Group Analyzer Tolerance\", description=\"Distance tolerance to consider sites as symmetrically equivalent.\")\n    \"\"\"\nadditional_fields = additional_fields or {}\nopt_parameters = dyn.todict() | {\"fmax\": dyn.fmax}\n# Check convergence\nis_converged = dyn.converged()\nif check_convergence and not is_converged:\nraise ValueError(\"Optimization did not converge.\")\n# Get trajectory\nif not trajectory:\ntrajectory = (\ndyn.traj_atoms\nif hasattr(dyn, \"traj_atoms\")\nelse read(dyn.trajectory.filename, index=\":\")\n)\ninitial_atoms = trajectory[0]\nfinal_atoms = dyn.atoms.atoms if isinstance(dyn.atoms, Filter) else dyn.atoms\n# Get results\ntraj_results = {\n\"trajectory_results\": [atoms.calc.results for atoms in trajectory],\n\"trajectory\": [\natoms_to_metadata(atoms, charge_and_multiplicity=charge_and_multiplicity)\nfor atoms in trajectory\n],\n}\nresults = {\n\"results\": final_atoms.calc.results\n| {\"converged\": is_converged, \"nsteps\": dyn.get_number_of_steps()}\n}\n# Get the calculator inputs\nuri = get_uri(os.getcwd())\ninputs = {\n\"parameters\": dyn.atoms.calc.parameters,\n\"parameters_opt\": opt_parameters,\n\"nid\": uri.split(\":\")[0],\n\"dir_name\": \":\".join(uri.split(\":\")[1:]),\n}\ninput_atoms_db = atoms_to_metadata(\ninitial_atoms, charge_and_multiplicity=charge_and_multiplicity\n)\ninputs[\"input_structure\"] = input_atoms_db\n# Prepares the Atoms object for the next run by moving the\n# final magmoms to initial, clearing the calculator state,\n# and assigning the resulting Atoms object a unique ID.\nif prep_next_run:\nfinal_atoms = prep_next_run_(final_atoms)\n# Get tabulated properties of the structure itself\natoms_db = atoms_to_metadata(\nfinal_atoms, charge_and_multiplicity=charge_and_multiplicity\n)\n# Create a dictionary of the inputs/outputs\ntask_doc = atoms_db | inputs | results | traj_results | additional_fields\nreturn clean_dict(task_doc, remove_empties=remove_empties)\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.summarize_run","title":"summarize_run","text":"<pre><code>summarize_run(atoms, input_atoms=None, charge_and_multiplicity=None, prep_next_run=True, remove_empties=False, additional_fields=None)\n</code></pre> <p>Get tabulated results from an Atoms object and calculator and store them in a database-friendly format. This is meant to be compatible with all calculator types.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>ASE Atoms following a calculation. A calculator must be attached.</p> </li> <li> input_atoms             (<code>Atoms | None</code>)         \u2013          <p>Input ASE Atoms object to store.</p> </li> <li> charge_and_multiplicity             (<code>tuple[int, int] | None</code>)         \u2013          <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> <li> prep_next_run             (<code>bool</code>)         \u2013          <p>Whether the Atoms object stored in {\"atoms\": atoms} should be prepared for the next run This clears out any attached calculator and moves the final magmoms to the initial magmoms.</p> </li> <li> remove_empties             (<code>bool</code>)         \u2013          <p>Whether to remove None values and empty lists/dicts from the task document.</p> </li> <li> additional_fields             (<code>dict | None</code>)         \u2013          <p>Additional fields to add to the task document.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary representation of the task document with the following fields:</p> <ul> <li>atoms: Atoms = Field(None, title = \"The Atoms object from the calculation result.\")</li> <li>atoms_info: dict = Field(None, title = \"The Atoms object info obtained from atoms.info.\")</li> <li>builder_meta: EmmetMeta = Field(default_factory=EmmetMeta, description=\"Builder metadata.\"):</li> <li>builder_meta.build_date: str = Field(default_factory=datetime.utcnow, description=\"The build date for this document.\")</li> <li>builder_meta.database_version: str = Field(None, description=\"The database version for the built data.\")</li> <li>builder_meta.emmet_version: str = Field(version, description=\"The version of emmet this document was built with.\")</li> <li>builder_meta.pymatgen_version: str = Field(pmg_version, description=\"The version of pymatgen this document was built with.\")</li> <li>builder_meta.pull_request: int = Field(None, description=\"The pull request number associated with this data build.\")</li> <li>dir_name: str = Field(None, description=\"Directory where the output is parsed\")</li> <li>input_structure: Molecule | Structure = Field(None, title = \"The Pymatgen Structure or Molecule object from the input Atoms object if input_atoms is not None.\")</li> <li>nid: str = Field(None, title = \"The node ID representing the machine where the calculation was run.\")</li> <li>parameters: dict = Field(None, title = \"the parameters used to run the calculation.\")</li> <li>results: dict = Field(None, title = \"The results from the calculation.\")</li> </ul> <p>For periodic structures, the task document also has the following fields:</p> <ul> <li>chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the material.\")</li> <li>composition: Composition = Field(None, description=\"Full composition for the material.\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition.\")</li> <li>density: float = Field(None, title=\"Density\", description=\"Density in grams per cm^3.\")</li> <li>density_atomic: float = Field(None, title=\"Packing Density\", description=\"The atomic packing density in atoms per cm^3.\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in the material.\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula.\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")</li> <li>nelements: int = Field(None, description=\"Number of elements.\")</li> <li>nsites: int = Field(None, description=\"Total number of sites in the structure.\")</li> <li>structure: Structure = Field(None, title = \"The Pymatgen Structure object from the Atoms object, if periodic and store_pmg is True.\")</li> <li>symmetry: SymmetryData = Field(None, description=\"Symmetry data for this material.\")</li> <li>symmetry.crystal_system: CrystalSystem = Field(None, title=\"Crystal System\", description=\"The crystal system for this lattice.\")</li> <li>symmetry.number: int = Field(None, title=\"Space Group Number\", description=\"The spacegroup number for the lattice.\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice.\")</li> <li>symmetry.symbol: str = Field(None, title=\"Space Group Symbol\", description=\"The spacegroup symbol for the lattice.\")</li> <li>symmetry.symprec: float = Field(None, title=\"Symmetry Finding Precision\", description=\"The precision given to spglib to determine the symmetry of this lattice.\")</li> <li>volume: float = Field(None, title=\"Volume\", description=\"Total volume for this structure in Angstroms^3.\")</li> </ul> <p>For molecules that lack periodicity, the task document also has the following fields:</p> <ul> <li>charge: int = Field(None, description=\"Charge of the molecule\")</li> <li>chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the molecule\")</li> <li>composition: Composition = Field(None, description=\"Full composition for the molecule\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in the molecule\")</li> <li>formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\", description=\"Alphabetical molecular formula\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")</li> <li>molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object from the Atoms object, if not periodic and store_pmg is True.\")</li> <li>natoms: int = Field(None, description=\"Total number of atoms in the molecule\")</li> <li>nelectrons: int = Field(None, title=\"Number of electrons\", description=\"The total number of electrons for the molecule\")</li> <li>nelements: int = Field(None, title=\"Number of Elements\")</li> <li>spin_multiplicity: int = Field(None, description=\"Spin multiplicity of the molecule\")</li> <li>symmetry: PointGroupData = Field(None, description=\"Symmetry data for this molecule\")</li> <li>symmetry.eigen_tolerance: float = Field(None, title=\"Interia Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare eigen values of the inertia tensor.\")</li> <li>symmetry.linear: bool = Field(None, title=\"Molecule Linearity\", description=\"Is the molecule linear?\")</li> <li>symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry Operation Matrix Element Tolerance\" description=\"Tolerance used to generate the full set of symmetry operations of the point group.\")</li> <li>symmetry.rotation_number: float = Field(None, title=\"Rotational Symmetry Number\", description=\"Rotational symmetry number for the molecule\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice\")</li> <li>symmetry.tolerance: float = Field(None, title=\"Point Group Analyzer Tolerance\", description=\"Distance tolerance to consider sites as symmetrically equivalent.\")</li> </ul> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/schemas/ase.py</code> <pre><code>def summarize_run(\natoms: Atoms,\ninput_atoms: Atoms | None = None,\ncharge_and_multiplicity: tuple[int, int] | None = None,\nprep_next_run: bool = True,\nremove_empties: bool = False,\nadditional_fields: dict | None = None,\n) -&gt; RunSchema:\n\"\"\"\n    Get tabulated results from an Atoms object and calculator and store them in a database-friendly format.\n    This is meant to be compatible with all calculator types.\n    Parameters\n    ----------\n    atoms\n        ASE Atoms following a calculation. A calculator must be attached.\n    input_atoms\n        Input ASE Atoms object to store.\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.\n    prep_next_run\n        Whether the Atoms object stored in {\"atoms\": atoms} should be prepared for the next run\n        This clears out any attached calculator and moves the final magmoms to the initial magmoms.\n    remove_empties\n        Whether to remove None values and empty lists/dicts from the task document.\n    additional_fields\n        Additional fields to add to the task document.\n    Returns\n    -------\n    dict\n        Dictionary representation of the task document with the following fields:\n        - atoms: Atoms = Field(None, title = \"The Atoms object from the calculation result.\")\n        - atoms_info: dict = Field(None, title = \"The Atoms object info obtained from atoms.info.\")\n        - builder_meta: EmmetMeta = Field(default_factory=EmmetMeta, description=\"Builder metadata.\"):\n            - builder_meta.build_date: str = Field(default_factory=datetime.utcnow, description=\"The build date for this document.\")\n            - builder_meta.database_version: str = Field(None, description=\"The database version for the built data.\")\n            - builder_meta.emmet_version: str = Field(__version__, description=\"The version of emmet this document was built with.\")\n            - builder_meta.pymatgen_version: str = Field(pmg_version, description=\"The version of pymatgen this document was built with.\")\n            - builder_meta.pull_request: int = Field(None, description=\"The pull request number associated with this data build.\")\n        - dir_name: str = Field(None, description=\"Directory where the output is parsed\")\n        - input_structure: Molecule | Structure = Field(None, title = \"The Pymatgen Structure or Molecule object from the input Atoms object if input_atoms is not None.\")\n        - nid: str = Field(None, title = \"The node ID representing the machine where the calculation was run.\")\n        - parameters: dict = Field(None, title = \"the parameters used to run the calculation.\")\n        - results: dict = Field(None, title = \"The results from the calculation.\")\n        For periodic structures, the task document also has the following fields:\n        - chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the material.\")\n        - composition: Composition = Field(None, description=\"Full composition for the material.\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition.\")\n        - density: float = Field(None, title=\"Density\", description=\"Density in grams per cm^3.\")\n        - density_atomic: float = Field(None, title=\"Packing Density\", description=\"The atomic packing density in atoms per cm^3.\")\n        - elements: List[Element] = Field(None, description=\"List of elements in the material.\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula.\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")\n        - nelements: int = Field(None, description=\"Number of elements.\")\n        - nsites: int = Field(None, description=\"Total number of sites in the structure.\")\n        - structure: Structure = Field(None, title = \"The Pymatgen Structure object from the Atoms object, if periodic and store_pmg is True.\")\n        - symmetry: SymmetryData = Field(None, description=\"Symmetry data for this material.\")\n            - symmetry.crystal_system: CrystalSystem = Field(None, title=\"Crystal System\", description=\"The crystal system for this lattice.\")\n            - symmetry.number: int = Field(None, title=\"Space Group Number\", description=\"The spacegroup number for the lattice.\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice.\")\n            - symmetry.symbol: str = Field(None, title=\"Space Group Symbol\", description=\"The spacegroup symbol for the lattice.\")\n            - symmetry.symprec: float = Field(None, title=\"Symmetry Finding Precision\", description=\"The precision given to spglib to determine the symmetry of this lattice.\")\n        - volume: float = Field(None, title=\"Volume\", description=\"Total volume for this structure in Angstroms^3.\")\n        For molecules that lack periodicity, the task document also has the following fields:\n        - charge: int = Field(None, description=\"Charge of the molecule\")\n        - chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the molecule\")\n        - composition: Composition = Field(None, description=\"Full composition for the molecule\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition\")\n        - elements: List[Element] = Field(None, description=\"List of elements in the molecule\")\n        - formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\", description=\"Alphabetical molecular formula\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")\n        - molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object from the Atoms object, if not periodic and store_pmg is True.\")\n        - natoms: int = Field(None, description=\"Total number of atoms in the molecule\")\n        - nelectrons: int = Field(None, title=\"Number of electrons\", description=\"The total number of electrons for the molecule\")\n        - nelements: int = Field(None, title=\"Number of Elements\")\n        - spin_multiplicity: int = Field(None, description=\"Spin multiplicity of the molecule\")\n        - symmetry: PointGroupData = Field(None, description=\"Symmetry data for this molecule\")\n            - symmetry.eigen_tolerance: float = Field(None, title=\"Interia Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare eigen values of the inertia tensor.\")\n            - symmetry.linear: bool = Field(None, title=\"Molecule Linearity\", description=\"Is the molecule linear?\")\n            - symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry Operation Matrix Element Tolerance\" description=\"Tolerance used to generate the full set of symmetry operations of the point group.\")\n            - symmetry.rotation_number: float = Field(None, title=\"Rotational Symmetry Number\", description=\"Rotational symmetry number for the molecule\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice\")\n            - symmetry.tolerance: float = Field(None, title=\"Point Group Analyzer Tolerance\", description=\"Distance tolerance to consider sites as symmetrically equivalent.\")\n    \"\"\"\n# Make sure there is a calculator with results\nif not atoms.calc:\nraise ValueError(\"ASE Atoms object has no attached calculator.\")\nif not atoms.calc.results:\nraise ValueError(\"ASE Atoms object's calculator has no results.\")\nadditional_fields = additional_fields or {}\n# Fetch all tabulated results from the attached calculator\nresults = {\"results\": atoms.calc.results}\n# Get the calculator inputs\nuri = get_uri(os.getcwd())\ninputs = {\n\"parameters\": atoms.calc.parameters,\n\"nid\": uri.split(\":\")[0],\n\"dir_name\": \":\".join(uri.split(\":\")[1:]),\n}\nif input_atoms:\ninput_atoms_db = atoms_to_metadata(\ninput_atoms, charge_and_multiplicity=charge_and_multiplicity\n)\ninputs[\"input_atoms\"] = input_atoms_db\n# Prepares the Atoms object for the next run by moving the\n# final magmoms to initial, clearing the calculator state,\n# and assigning the resulting Atoms object a unique ID.\nif prep_next_run:\natoms = prep_next_run_(atoms)\n# Get tabulated properties of the structure itself\natoms_db = atoms_to_metadata(atoms, charge_and_multiplicity=charge_and_multiplicity)\n# Create a dictionary of the inputs/outputs\ntask_doc = atoms_db | inputs | results | additional_fields\nreturn clean_dict(task_doc, remove_empties=remove_empties)\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.summarize_thermo_run","title":"summarize_thermo_run","text":"<pre><code>summarize_thermo_run(igt, temperature=298.15, pressure=1.0, charge_and_multiplicity=None, remove_empties=False, additional_fields=None)\n</code></pre> <p>Get tabulated results from an ASE IdealGasThermo object and store them in a database-friendly format.</p> <p>Parameters:</p> <ul> <li> igt             (<code>IdealGasThermo</code>)         \u2013          <p>ASE IdealGasThermo object.</p> </li> <li> temperature             (<code>float</code>)         \u2013          <p>Temperature in Kelvins.</p> </li> <li> pressure             (<code>float</code>)         \u2013          <p>Pressure in bar.</p> </li> <li> charge_and_multiplicity             (<code>tuple[int, int] | None</code>)         \u2013          <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> <li> remove_empties             (<code>bool</code>)         \u2013          <p>Whether to remove None values and empty lists/dicts from the task document.</p> </li> <li> additional_fields             (<code>dict | None</code>)         \u2013          <p>Additional fields to add to the task document.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary representation of the task document with the following fields:</p> <ul> <li>atoms: Atoms = Field(None, title = \"The Atoms object from the calculation result.\")</li> <li>atoms_info: dict = Field(None, title = \"The Atoms object info obtained from atoms.info.\")</li> <li>builder_meta: EmmetMeta = Field(default_factory=EmmetMeta, description=\"Builder metadata.\"):</li> <li>builder_meta.build_date: str = Field(default_factory=datetime.utcnow, description=\"The build date for this document.\")</li> <li>builder_meta.database_version: str = Field(None, description=\"The database version for the built data.\")</li> <li>builder_meta.emmet_version: str = Field(version, description=\"The version of emmet this document was built with.\")</li> <li>builder_meta.pymatgen_version: str = Field(pmg_version, description=\"The version of pymatgen this document was built with.\")</li> <li>builder_meta.pull_request: int = Field(None, description=\"The pull request number associated with this data build.\")</li> <li>dir_name: str = Field(None, description=\"Directory where the output is parsed\")</li> <li>nid: str = Field(None, title = \"The node ID representing the machine where the calculation was run.\")</li> <li>thermo_parameters: dict = Field(None, title = \"the parameters used to run the thermo calculation.\")</li> <li>thermo_parameters.temperature: float = Temperature in Kelvins</li> <li>thermo_parameters.pressure: float = Pressure in bar</li> <li>thermo_parameters.sigma: float = The rotational symmetry number of the molecule</li> <li>thermo_parameters.spin_multiplicity: int = The spin multiplicity of the molecule</li> <li>thermo_parameters.vib_freqs: List[float] = Vibrational frequencies in cm^-1 used for the thermo calculation</li> <li>thermo_parameters.vib_energies: List[float] = Vibrational energies in eV used for the thermo calculation</li> <li>thermo_parameters.n_imag: int = Number of imaginary vibrational frequencies ignored in the thermo calculation</li> <li>results: dict = Field(None, title = \"The results from the calculation.\")</li> <li>results.energy: float = The potential energy of the system in eV</li> <li>results.enthalpy: float = The enthalpy of the system in eV</li> <li>results.entropy: float = The entropy of the system in eV/K</li> <li>results.gibbs_energy: float = The Gibbs free energy of the system in eV</li> <li>results.zpe: float = The zero point vibrational energy of the system in eV</li> </ul> <p>The task document also has the following fields from the Molecule object:</p> <ul> <li>charge: int = Field(None, description=\"Charge of the molecule\")</li> <li>chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the molecule\")</li> <li>composition: Composition = Field(None, description=\"Full composition for the molecule\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in the molecule\")</li> <li>formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\", description=\"Alphabetical molecular formula\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")</li> <li>natoms: int = Field(None, description=\"Total number of atoms in the molecule\")</li> <li>molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object from the Atoms object, if not periodic and store_pmg is True.\")</li> <li>nelectrons: int = Field(None, title=\"Number of electrons\", description=\"The total number of electrons for the molecule\")</li> <li>nelements: int = Field(None, title=\"Number of Elements\")</li> <li>spin_multiplicity: int = Field(None, description=\"Spin multiplicity of the molecule\")</li> <li>symmetry: PointGroupData = Field(None, description=\"Symmetry data for this molecule\")</li> <li>symmetry.eigen_tolerance: float = Field(None, title=\"Interia Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare eigen values of the inertia tensor.\")</li> <li>symmetry.linear: bool = Field(None, title=\"Molecule Linearity\", description=\"Is the molecule linear?\")</li> <li>symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry Operation Matrix Element Tolerance\" description=\"Tolerance used to generate the full set of symmetry operations of the point group.\")</li> <li>symmetry.rotation_number: float = Field(None, title=\"Rotational Symmetry Number\", description=\"Rotational symmetry number for the molecule\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice\")</li> <li>symmetry.tolerance: float = Field(None, title=\"Point Group Analyzer Tolerance\", description=\"Distance tolerance to consider sites as symmetrically equivalent.\")</li> </ul> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/schemas/ase.py</code> <pre><code>def summarize_thermo_run(\nigt: IdealGasThermo,\ntemperature: float = 298.15,\npressure: float = 1.0,\ncharge_and_multiplicity: tuple[int, int] | None = None,\nremove_empties: bool = False,\nadditional_fields: dict | None = None,\n) -&gt; ThermoSchema:\n\"\"\"\n    Get tabulated results from an ASE IdealGasThermo object and store them in a database-friendly format.\n    Parameters\n    ----------\n    igt\n        ASE IdealGasThermo object.\n    temperature\n        Temperature in Kelvins.\n    pressure\n        Pressure in bar.\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.\n    remove_empties\n        Whether to remove None values and empty lists/dicts from the task document.\n    additional_fields\n        Additional fields to add to the task document.\n    Returns\n    -------\n    dict\n        Dictionary representation of the task document with the following fields:\n        - atoms: Atoms = Field(None, title = \"The Atoms object from the calculation result.\")\n        - atoms_info: dict = Field(None, title = \"The Atoms object info obtained from atoms.info.\")\n        - builder_meta: EmmetMeta = Field(default_factory=EmmetMeta, description=\"Builder metadata.\"):\n            - builder_meta.build_date: str = Field(default_factory=datetime.utcnow, description=\"The build date for this document.\")\n            - builder_meta.database_version: str = Field(None, description=\"The database version for the built data.\")\n            - builder_meta.emmet_version: str = Field(__version__, description=\"The version of emmet this document was built with.\")\n            - builder_meta.pymatgen_version: str = Field(pmg_version, description=\"The version of pymatgen this document was built with.\")\n            - builder_meta.pull_request: int = Field(None, description=\"The pull request number associated with this data build.\")\n        - dir_name: str = Field(None, description=\"Directory where the output is parsed\")\n        - nid: str = Field(None, title = \"The node ID representing the machine where the calculation was run.\")\n        - thermo_parameters: dict = Field(None, title = \"the parameters used to run the thermo calculation.\")\n            - thermo_parameters.temperature: float = Temperature in Kelvins\n            - thermo_parameters.pressure: float = Pressure in bar\n            - thermo_parameters.sigma: float = The rotational symmetry number of the molecule\n            - thermo_parameters.spin_multiplicity: int = The spin multiplicity of the molecule\n            - thermo_parameters.vib_freqs: List[float] = Vibrational frequencies in cm^-1 used for the thermo calculation\n            - thermo_parameters.vib_energies: List[float] = Vibrational energies in eV used for the thermo calculation\n            - thermo_parameters.n_imag: int = Number of imaginary vibrational frequencies ignored in the thermo calculation\n        - results: dict = Field(None, title = \"The results from the calculation.\")\n            - results.energy: float = The potential energy of the system in eV\n            - results.enthalpy: float = The enthalpy of the system in eV\n            - results.entropy: float = The entropy of the system in eV/K\n            - results.gibbs_energy: float = The Gibbs free energy of the system in eV\n            - results.zpe: float = The zero point vibrational energy of the system in eV\n        The task document also has the following fields from the Molecule object:\n        - charge: int = Field(None, description=\"Charge of the molecule\")\n        - chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the molecule\")\n        - composition: Composition = Field(None, description=\"Full composition for the molecule\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition\")\n        - elements: List[Element] = Field(None, description=\"List of elements in the molecule\")\n        - formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\", description=\"Alphabetical molecular formula\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")\n        - natoms: int = Field(None, description=\"Total number of atoms in the molecule\")\n        - molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object from the Atoms object, if not periodic and store_pmg is True.\")\n        - nelectrons: int = Field(None, title=\"Number of electrons\", description=\"The total number of electrons for the molecule\")\n        - nelements: int = Field(None, title=\"Number of Elements\")\n        - spin_multiplicity: int = Field(None, description=\"Spin multiplicity of the molecule\")\n        - symmetry: PointGroupData = Field(None, description=\"Symmetry data for this molecule\")\n            - symmetry.eigen_tolerance: float = Field(None, title=\"Interia Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare eigen values of the inertia tensor.\")\n            - symmetry.linear: bool = Field(None, title=\"Molecule Linearity\", description=\"Is the molecule linear?\")\n            - symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry Operation Matrix Element Tolerance\" description=\"Tolerance used to generate the full set of symmetry operations of the point group.\")\n            - symmetry.rotation_number: float = Field(None, title=\"Rotational Symmetry Number\", description=\"Rotational symmetry number for the molecule\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice\")\n            - symmetry.tolerance: float = Field(None, title=\"Point Group Analyzer Tolerance\", description=\"Distance tolerance to consider sites as symmetrically equivalent.\")\n    \"\"\"\nadditional_fields = additional_fields or {}\nuri = get_uri(os.getcwd())\nspin_multiplicity = int(2 * igt.spin + 1)\ninputs = {\n\"parameters_thermo\": {\n\"temperature\": temperature,\n\"pressure\": pressure,\n\"sigma\": igt.sigma,\n\"spin_multiplicity\": spin_multiplicity,\n\"vib_freqs\": [e / units.invcm for e in igt.vib_energies],\n\"vib_energies\": igt.vib_energies.tolist(),\n\"n_imag\": igt.n_imag,\n},\n\"nid\": uri.split(\":\")[0],\n\"dir_name\": \":\".join(uri.split(\":\")[1:]),\n}\nresults = {\n\"results\": {\n\"energy\": igt.potentialenergy,\n\"enthalpy\": igt.get_enthalpy(temperature, verbose=True),\n\"entropy\": igt.get_entropy(temperature, pressure * 10**5, verbose=True),\n\"gibbs_energy\": igt.get_gibbs_energy(\ntemperature, pressure * 10**5, verbose=True\n),\n\"zpe\": igt.get_ZPE_correction(),\n}\n}\nif charge_and_multiplicity and spin_multiplicity != charge_and_multiplicity[1]:\nwarnings.warn(\n\"The IdealGasThermo spin multiplicity does not match the user-specified multiplicity.\",\nUserWarning,\n)\natoms_db = atoms_to_metadata(\nigt.atoms, charge_and_multiplicity=charge_and_multiplicity\n)\ntask_doc = atoms_db | inputs | results | additional_fields\nreturn clean_dict(task_doc, remove_empties=remove_empties)\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.summarize_vib_run","title":"summarize_vib_run","text":"<pre><code>summarize_vib_run(vib, charge_and_multiplicity=None, remove_empties=False, additional_fields=None)\n</code></pre> <p>Get tabulated results from an ASE Vibrations object and store them in a database-friendly format.</p> <p>Parameters:</p> <ul> <li> vib             (<code>Vibrations</code>)         \u2013          <p>ASE Vibrations object.</p> </li> <li> charge_and_multiplicity             (<code>tuple[int, int] | None</code>)         \u2013          <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> <li> remove_empties             (<code>bool</code>)         \u2013          <p>Whether to remove None values and empty lists/dicts from the task document.</p> </li> <li> additional_fields             (<code>dict | None</code>)         \u2013          <p>Additional fields to add to the task document.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary representation of the task document with the following fields:</p> <ul> <li>atoms: Atoms = Field(None, title = \"The Atoms object from the calculation result.\")</li> <li>atoms_info: dict = Field(None, title = \"The Atoms object info obtained from atoms.info.\")</li> <li>builder_meta: EmmetMeta = Field(default_factory=EmmetMeta, description=\"Builder metadata.\"):</li> <li>builder_meta.build_date: str = Field(default_factory=datetime.utcnow, description=\"The build date for this document.\")</li> <li>builder_meta.database_version: str = Field(None, description=\"The database version for the built data.\")</li> <li>builder_meta.emmet_version: str = Field(version, description=\"The version of emmet this document was built with.\")</li> <li>builder_meta.pymatgen_version: str = Field(pmg_version, description=\"The version of pymatgen this document was built with.\")</li> <li>builder_meta.pull_request: int = Field(None, description=\"The pull request number associated with this data build.\")</li> <li>dir_name: str = Field(None, description=\"Directory where the output is parsed\")</li> <li>nid: str = Field(None, title = \"The node ID representing the machine where the calculation was run.\")</li> <li>parameters: dict = Field(None, title = \"the parameters used to run the calculation.\")</li> <li>vib_parameters: dict = Field(None, title = \"the parameters used to run the vibrations.\")</li> <li>vib_parameters.delta: float = the Vibrations delta value</li> <li>vib_parameters.direction: str = the Vibrations direction value</li> <li>vib_parameters.method: str = the Vibrations method value</li> <li>vib_parameters.ndof: int = the Vibrations ndof value</li> <li>vib_parameters.nfree: int = the Vibrations nfree value</li> <li>results: dict = Field(None, title = \"The results from the calculation.\")</li> <li>results.imag_vib_freqs: List[float] = Imaginary vibrational frequencies in cm^-1</li> <li>results.n_imag: int = Number of imaginary vibrational frequencies</li> <li>results.vib_energies: List[float] = Vibrational energies in eV. 3N-5 or 3N-6 for molecules; 3N for solids.</li> <li>results.vib_freqs: List[float] = Vibrational frequencies in cm^-1. 3N-5 or 3N-6 for molecules; 3N for solids.</li> <li>results.vib_energies_raw: List[float] = Vibrational energies in eV of length 3N.</li> <li>results.vib_freqs_raw: List[float] = Vibrational frequencies in cm^-1 of length 3N.</li> </ul> <p>For periodic structures, the task document also has the following fields:</p> <ul> <li>chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the material.\")</li> <li>composition: Composition = Field(None, description=\"Full composition for the material.\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition.\")</li> <li>density: float = Field(None, title=\"Density\", description=\"Density in grams per cm^3.\")</li> <li>density_atomic: float = Field(None, title=\"Packing Density\", description=\"The atomic packing density in atoms per cm^3.\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in the material.\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula.\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")</li> <li>nelements: int = Field(None, description=\"Number of elements.\")</li> <li>nsites: int = Field(None, description=\"Total number of sites in the structure.\")</li> <li>structure: Structure = Field(None, title = \"The Pymatgen Structure object from the Atoms object, if periodic and store_pmg is True.\")</li> <li>symmetry: SymmetryData = Field(None, description=\"Symmetry data for this material.\")</li> <li>symmetry.crystal_system: CrystalSystem = Field(None, title=\"Crystal System\", description=\"The crystal system for this lattice.\")</li> <li>symmetry.number: int = Field(None, title=\"Space Group Number\", description=\"The spacegroup number for the lattice.\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice.\")</li> <li>symmetry.symbol: str = Field(None, title=\"Space Group Symbol\", description=\"The spacegroup symbol for the lattice.\")</li> <li>symmetry.symprec: float = Field(None, title=\"Symmetry Finding Precision\", description=\"The precision given to spglib to determine the symmetry of this lattice.\")</li> <li>volume: float = Field(None, title=\"Volume\", description=\"Total volume for this structure in Angstroms^3.\")</li> </ul> <p>For molecules that lack periodicity, the task document also has the following fields:</p> <ul> <li>charge: int = Field(None, description=\"Charge of the molecule\")</li> <li>chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the molecule\")</li> <li>composition: Composition = Field(None, description=\"Full composition for the molecule\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in the molecule\")</li> <li>formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\", description=\"Alphabetical molecular formula\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")</li> <li>natoms: int = Field(None, description=\"Total number of atoms in the molecule\")</li> <li>molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object from the Atoms object, if not periodic and store_pmg is True.\")</li> <li>nelectrons: int = Field(None, title=\"Number of electrons\", description=\"The total number of electrons for the molecule\")</li> <li>nelements: int = Field(None, title=\"Number of Elements\")</li> <li>spin_multiplicity: int = Field(None, description=\"Spin multiplicity of the molecule\")</li> <li>symmetry: PointGroupData = Field(None, description=\"Symmetry data for this molecule\")</li> <li>symmetry.eigen_tolerance: float = Field(None, title=\"Interia Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare eigen values of the inertia tensor.\")</li> <li>symmetry.linear: bool = Field(None, title=\"Molecule Linearity\", description=\"Is the molecule linear?\")</li> <li>symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry Operation Matrix Element Tolerance\" description=\"Tolerance used to generate the full set of symmetry operations of the point group.\")</li> <li>symmetry.rotation_number: float = Field(None, title=\"Rotational Symmetry Number\", description=\"Rotational symmetry number for the molecule\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice\")</li> <li>symmetry.tolerance: float = Field(None, title=\"Point Group Analyzer Tolerance\", description=\"Distance tolerance to consider sites as symmetrically equivalent.\")</li> </ul> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/schemas/ase.py</code> <pre><code>def summarize_vib_run(\nvib: Vibrations,\ncharge_and_multiplicity: tuple[int, int] | None = None,\nremove_empties: bool = False,\nadditional_fields: dict | None = None,\n) -&gt; VibSchema:\n\"\"\"\n    Get tabulated results from an ASE Vibrations object and store them in a database-friendly format.\n    Parameters\n    ----------\n    vib\n        ASE Vibrations object.\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.\n    remove_empties\n        Whether to remove None values and empty lists/dicts from the task document.\n    additional_fields\n        Additional fields to add to the task document.\n    Returns\n    -------\n    dict\n        Dictionary representation of the task document with the following fields:\n        - atoms: Atoms = Field(None, title = \"The Atoms object from the calculation result.\")\n        - atoms_info: dict = Field(None, title = \"The Atoms object info obtained from atoms.info.\")\n        - builder_meta: EmmetMeta = Field(default_factory=EmmetMeta, description=\"Builder metadata.\"):\n            - builder_meta.build_date: str = Field(default_factory=datetime.utcnow, description=\"The build date for this document.\")\n            - builder_meta.database_version: str = Field(None, description=\"The database version for the built data.\")\n            - builder_meta.emmet_version: str = Field(__version__, description=\"The version of emmet this document was built with.\")\n            - builder_meta.pymatgen_version: str = Field(pmg_version, description=\"The version of pymatgen this document was built with.\")\n            - builder_meta.pull_request: int = Field(None, description=\"The pull request number associated with this data build.\")\n        - dir_name: str = Field(None, description=\"Directory where the output is parsed\")\n        - nid: str = Field(None, title = \"The node ID representing the machine where the calculation was run.\")\n        - parameters: dict = Field(None, title = \"the parameters used to run the calculation.\")\n        - vib_parameters: dict = Field(None, title = \"the parameters used to run the vibrations.\")\n            - vib_parameters.delta: float = the Vibrations delta value\n            - vib_parameters.direction: str = the Vibrations direction value\n            - vib_parameters.method: str = the Vibrations method value\n            - vib_parameters.ndof: int = the Vibrations ndof value\n            - vib_parameters.nfree: int = the Vibrations nfree value\n        - results: dict = Field(None, title = \"The results from the calculation.\")\n            - results.imag_vib_freqs: List[float] = Imaginary vibrational frequencies in cm^-1\n            - results.n_imag: int = Number of imaginary vibrational frequencies\n            - results.vib_energies: List[float] = Vibrational energies in eV. 3N-5 or 3N-6 for molecules; 3N for solids.\n            - results.vib_freqs: List[float] = Vibrational frequencies in cm^-1. 3N-5 or 3N-6 for molecules; 3N for solids.\n            - results.vib_energies_raw: List[float] = Vibrational energies in eV of length 3N.\n            - results.vib_freqs_raw: List[float] = Vibrational frequencies in cm^-1 of length 3N.\n        For periodic structures, the task document also has the following fields:\n        - chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the material.\")\n        - composition: Composition = Field(None, description=\"Full composition for the material.\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition.\")\n        - density: float = Field(None, title=\"Density\", description=\"Density in grams per cm^3.\")\n        - density_atomic: float = Field(None, title=\"Packing Density\", description=\"The atomic packing density in atoms per cm^3.\")\n        - elements: List[Element] = Field(None, description=\"List of elements in the material.\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula.\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")\n        - nelements: int = Field(None, description=\"Number of elements.\")\n        - nsites: int = Field(None, description=\"Total number of sites in the structure.\")\n        - structure: Structure = Field(None, title = \"The Pymatgen Structure object from the Atoms object, if periodic and store_pmg is True.\")\n        - symmetry: SymmetryData = Field(None, description=\"Symmetry data for this material.\")\n            - symmetry.crystal_system: CrystalSystem = Field(None, title=\"Crystal System\", description=\"The crystal system for this lattice.\")\n            - symmetry.number: int = Field(None, title=\"Space Group Number\", description=\"The spacegroup number for the lattice.\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice.\")\n            - symmetry.symbol: str = Field(None, title=\"Space Group Symbol\", description=\"The spacegroup symbol for the lattice.\")\n            - symmetry.symprec: float = Field(None, title=\"Symmetry Finding Precision\", description=\"The precision given to spglib to determine the symmetry of this lattice.\")\n        - volume: float = Field(None, title=\"Volume\", description=\"Total volume for this structure in Angstroms^3.\")\n        For molecules that lack periodicity, the task document also has the following fields:\n        - charge: int = Field(None, description=\"Charge of the molecule\")\n        - chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the molecule\")\n        - composition: Composition = Field(None, description=\"Full composition for the molecule\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition\")\n        - elements: List[Element] = Field(None, description=\"List of elements in the molecule\")\n        - formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\", description=\"Alphabetical molecular formula\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")\n        - natoms: int = Field(None, description=\"Total number of atoms in the molecule\")\n        - molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object from the Atoms object, if not periodic and store_pmg is True.\")\n        - nelectrons: int = Field(None, title=\"Number of electrons\", description=\"The total number of electrons for the molecule\")\n        - nelements: int = Field(None, title=\"Number of Elements\")\n        - spin_multiplicity: int = Field(None, description=\"Spin multiplicity of the molecule\")\n        - symmetry: PointGroupData = Field(None, description=\"Symmetry data for this molecule\")\n            - symmetry.eigen_tolerance: float = Field(None, title=\"Interia Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare eigen values of the inertia tensor.\")\n            - symmetry.linear: bool = Field(None, title=\"Molecule Linearity\", description=\"Is the molecule linear?\")\n            - symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry Operation Matrix Element Tolerance\" description=\"Tolerance used to generate the full set of symmetry operations of the point group.\")\n            - symmetry.rotation_number: float = Field(None, title=\"Rotational Symmetry Number\", description=\"Rotational symmetry number for the molecule\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice\")\n            - symmetry.tolerance: float = Field(None, title=\"Point Group Analyzer Tolerance\", description=\"Distance tolerance to consider sites as symmetrically equivalent.\")\n    \"\"\"\nadditional_fields = additional_fields or {}\nvib_freqs_raw = vib.get_frequencies().tolist()\nvib_energies_raw = vib.get_energies().tolist()\natoms = vib.atoms\n# Convert imaginary modes to negative values for DB storage\nfor i, f in enumerate(vib_freqs_raw):\nif np.imag(f) &gt; 0:\nvib_freqs_raw[i] = -np.abs(f)\nvib_energies_raw[i] = -np.abs(vib_energies_raw[i])\nelse:\nvib_freqs_raw[i] = np.abs(f)\nvib_energies_raw[i] = np.abs(vib_energies_raw[i])\nuri = get_uri(os.getcwd())\ninputs = {\n\"parameters\": atoms.calc.parameters,\n\"parameters_vib\": {\n\"delta\": vib.delta,\n\"direction\": vib.direction,\n\"method\": vib.method,\n\"ndof\": vib.ndof,\n\"nfree\": vib.nfree,\n},\n\"nid\": uri.split(\":\")[0],\n\"dir_name\": \":\".join(uri.split(\":\")[1:]),\n}\natoms_db = atoms_to_metadata(atoms, charge_and_multiplicity=charge_and_multiplicity)\n# Get the true vibrational modes\nnatoms = len(atoms)\nif natoms == 1:\nvib_freqs = []\nvib_energies = []\nelif atoms.pbc.any():\nvib_freqs = vib_freqs_raw\nvib_energies = vib_energies_raw\nelse:\n# Sort by absolute value\nvib_freqs_raw_sorted = vib_freqs_raw.copy()\nvib_energies_raw_sorted = vib_energies_raw.copy()\nvib_freqs_raw_sorted.sort(key=np.abs)\nvib_energies_raw_sorted.sort(key=np.abs)\n# Cut the 3N-5 or 3N-6 modes based on their absolute value\nn_modes = 3 * natoms - 5 if atoms_db[\"symmetry\"][\"linear\"] else 3 * natoms - 6\nvib_freqs = vib_freqs_raw_sorted[-n_modes:]\nvib_energies = vib_energies_raw_sorted[-n_modes:]\nimag_vib_freqs = [f for f in vib_freqs if f &lt; 0]\nresults = {\n\"results\": {\n\"imag_vib_freqs\": imag_vib_freqs,\n\"n_imag\": len(imag_vib_freqs),\n\"vib_energies\": vib_energies,\n\"vib_freqs\": vib_freqs,\n\"vib_energies_raw\": vib_energies_raw,\n\"vib_freqs_raw\": vib_freqs_raw,\n}\n}\ntask_doc = atoms_db | inputs | results | additional_fields\nreturn clean_dict(task_doc, remove_empties=remove_empties)\n</code></pre>"},{"location":"reference/quacc/schemas/atoms.html","title":"atoms","text":"<p>Schemas for storing metadata about Atoms objects</p>"},{"location":"reference/quacc/schemas/atoms.html#quacc.schemas.atoms.atoms_to_metadata","title":"atoms_to_metadata","text":"<pre><code>atoms_to_metadata(atoms, charge_and_multiplicity=None, get_metadata=True, strip_info=False, store_pmg=True, remove_empties=False, additional_fields=None)\n</code></pre> <p>Convert an ASE Atoms object to a dict suitable for storage in MongoDB.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>ASE Atoms object to store in {\"atoms\": atoms}</p> </li> <li> charge_and_multiplicity             (<code>tuple[int, int] | None</code>)         \u2013          <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> <li> get_metadata             (<code>bool</code>)         \u2013          <p>Whether to store atoms metadata in the returned dict.</p> </li> <li> strip_info             (<code>bool</code>)         \u2013          <p>Whether to strip the data from atoms.info in the returned {\"atoms\": atoms}. Note that this data will be stored in {\"atoms_info\": atoms.info} regardless</p> </li> <li> store_pmg             (<code>bool</code>)         \u2013          <p>Whether to store the Pymatgen Structure/Molecule object in {\"structure\": Structure} or {\"molecule\": Molecule}, respectively.</p> </li> <li> remove_empties             (<code>bool</code>)         \u2013          <p>Whether to remove None values and empty lists/dicts from the TaskDocument.</p> </li> <li> additional_fields             (<code>dict | None</code>)         \u2013          <p>Additional fields to add to the document.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary representation of the atoms object with the following fields:</p> <ul> <li>atoms: Atoms = Field(None, title = \"The Atoms object from the calculation result.\")</li> <li>atoms_info: dict = Field(None, title = \"The Atoms object info obtained from atoms.info.\")</li> <li>builder_meta: EmmetMeta = Field(default_factory=EmmetMeta, description=\"Builder metadata.\"):</li> <li>builder_meta.build_date: str = Field(default_factory=datetime.utcnow, description=\"The build date for this document.\")</li> <li>builder_meta.database_version: str = Field(None, description=\"The database version for the built data.\")</li> <li>builder_meta.emmet_version: str = Field(version, description=\"The version of emmet this document was built with.\")</li> <li>builder_meta.pymatgen_version: str = Field(pmg_version, description=\"The version of pymatgen this document was built with.\")</li> <li>builder_meta.pull_request: int = Field(None, description=\"The pull request number associated with this data build.\")</li> </ul> <p>For periodic structures, the task document also has the following fields:</p> <ul> <li>chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the material.\")</li> <li>composition: Composition = Field(None, description=\"Full composition for the material.\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition.\")</li> <li>density: float = Field(None, title=\"Density\", description=\"Density in grams per cm^3.\")</li> <li>density_atomic: float = Field(None, title=\"Packing Density\", description=\"The atomic packing density in atoms per cm^3.\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in the material.\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula.\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")</li> <li>nelements: int = Field(None, description=\"Number of elements.\")</li> <li>nsites: int = Field(None, description=\"Total number of sites in the structure.\")</li> <li>structure: Structure = Field(None, title = \"The Pymatgen Structure object from the Atoms object, if periodic and store_pmg is True.\")</li> <li>symmetry: SymmetryData = Field(None, description=\"Symmetry data for this material.\")</li> <li>symmetry.crystal_system: CrystalSystem = Field(None, title=\"Crystal System\", description=\"The crystal system for this lattice.\")</li> <li>symmetry.number: int = Field(None, title=\"Space Group Number\", description=\"The spacegroup number for the lattice.\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice.\")</li> <li>symmetry.symbol: str = Field(None, title=\"Space Group Symbol\", description=\"The spacegroup symbol for the lattice.\")</li> <li>symmetry.symprec: float = Field(None, title=\"Symmetry Finding Precision\", description=\"The precision given to spglib to determine the symmetry of this lattice.\")</li> <li>volume: float = Field(None, title=\"Volume\", description=\"Total volume for this structure in Angstroms^3.\")</li> </ul> <p>For molecules that lack periodicity, the task document also has the following fields:</p> <ul> <li>charge: int = Field(None, description=\"Charge of the molecule\")</li> <li>chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the molecule\")</li> <li>composition: Composition = Field(None, description=\"Full composition for the molecule\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in the molecule\")</li> <li>formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\", description=\"Alphabetical molecular formula\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")</li> <li>molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object from the Atoms object, if not periodic and store_pmg is True.\")</li> <li>natoms: int = Field(None, description=\"Total number of atoms in the molecule\")</li> <li>nelectrons: int = Field(None, title=\"Number of electrons\", description=\"The total number of electrons for the molecule\")</li> <li>nelements: int = Field(None, title=\"Number of Elements\")</li> <li>spin_multiplicity: int = Field(None, description=\"Spin multiplicity of the molecule\")</li> <li>symmetry: PointGroupData = Field(None, description=\"Symmetry data for this molecule\")</li> <li>symmetry.eigen_tolerance: float = Field(None, title=\"Interia Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare eigen values of the inertia tensor.\")</li> <li>symmetry.linear: bool = Field(None, title=\"Molecule Linearity\", description=\"Is the molecule linear?\")</li> <li>symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry Operation Matrix Element Tolerance\" description=\"Tolerance used to generate the full set of symmetry operations of the point group.\")</li> <li>symmetry.rotation_number: float = Field(None, title=\"Rotational Symmetry Number\", description=\"Rotational symmetry number for the molecule\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice\")</li> <li>symmetry.tolerance: float = Field(None, title=\"Point Group Analyzer Tolerance\", description=\"Distance tolerance to consider sites as symmetrically equivalent.\")</li> </ul> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/schemas/atoms.py</code> <pre><code>def atoms_to_metadata(\natoms: Atoms,\ncharge_and_multiplicity: tuple[int, int] | None = None,\nget_metadata: bool = True,\nstrip_info: bool = False,\nstore_pmg: bool = True,\nremove_empties: bool = False,\nadditional_fields: dict | None = None,\n) -&gt; AtomsSchema:\n\"\"\"\n    Convert an ASE Atoms object to a dict suitable for storage in MongoDB.\n    Parameters\n    ----------\n    atoms\n        ASE Atoms object to store in {\"atoms\": atoms}\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.\n    get_metadata\n        Whether to store atoms metadata in the returned dict.\n    strip_info\n        Whether to strip the data from atoms.info in the returned {\"atoms\": atoms}.\n        Note that this data will be stored in {\"atoms_info\": atoms.info} regardless\n    store_pmg\n        Whether to store the Pymatgen Structure/Molecule object in {\"structure\": Structure}\n        or {\"molecule\": Molecule}, respectively.\n    remove_empties\n        Whether to remove None values and empty lists/dicts from the TaskDocument.\n    additional_fields\n        Additional fields to add to the document.\n    Returns\n    -------\n    dict\n        Dictionary representation of the atoms object with the following fields:\n        - atoms: Atoms = Field(None, title = \"The Atoms object from the calculation result.\")\n        - atoms_info: dict = Field(None, title = \"The Atoms object info obtained from atoms.info.\")\n        - builder_meta: EmmetMeta = Field(default_factory=EmmetMeta, description=\"Builder metadata.\"):\n            - builder_meta.build_date: str = Field(default_factory=datetime.utcnow, description=\"The build date for this document.\")\n            - builder_meta.database_version: str = Field(None, description=\"The database version for the built data.\")\n            - builder_meta.emmet_version: str = Field(__version__, description=\"The version of emmet this document was built with.\")\n            - builder_meta.pymatgen_version: str = Field(pmg_version, description=\"The version of pymatgen this document was built with.\")\n            - builder_meta.pull_request: int = Field(None, description=\"The pull request number associated with this data build.\")\n        For periodic structures, the task document also has the following fields:\n        - chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the material.\")\n        - composition: Composition = Field(None, description=\"Full composition for the material.\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition.\")\n        - density: float = Field(None, title=\"Density\", description=\"Density in grams per cm^3.\")\n        - density_atomic: float = Field(None, title=\"Packing Density\", description=\"The atomic packing density in atoms per cm^3.\")\n        - elements: List[Element] = Field(None, description=\"List of elements in the material.\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula.\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")\n        - nelements: int = Field(None, description=\"Number of elements.\")\n        - nsites: int = Field(None, description=\"Total number of sites in the structure.\")\n        - structure: Structure = Field(None, title = \"The Pymatgen Structure object from the Atoms object, if periodic and store_pmg is True.\")\n        - symmetry: SymmetryData = Field(None, description=\"Symmetry data for this material.\")\n            - symmetry.crystal_system: CrystalSystem = Field(None, title=\"Crystal System\", description=\"The crystal system for this lattice.\")\n            - symmetry.number: int = Field(None, title=\"Space Group Number\", description=\"The spacegroup number for the lattice.\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice.\")\n            - symmetry.symbol: str = Field(None, title=\"Space Group Symbol\", description=\"The spacegroup symbol for the lattice.\")\n            - symmetry.symprec: float = Field(None, title=\"Symmetry Finding Precision\", description=\"The precision given to spglib to determine the symmetry of this lattice.\")\n        - volume: float = Field(None, title=\"Volume\", description=\"Total volume for this structure in Angstroms^3.\")\n        For molecules that lack periodicity, the task document also has the following fields:\n        - charge: int = Field(None, description=\"Charge of the molecule\")\n        - chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the molecule\")\n        - composition: Composition = Field(None, description=\"Full composition for the molecule\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition\")\n        - elements: List[Element] = Field(None, description=\"List of elements in the molecule\")\n        - formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\", description=\"Alphabetical molecular formula\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")\n        - molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object from the Atoms object, if not periodic and store_pmg is True.\")\n        - natoms: int = Field(None, description=\"Total number of atoms in the molecule\")\n        - nelectrons: int = Field(None, title=\"Number of electrons\", description=\"The total number of electrons for the molecule\")\n        - nelements: int = Field(None, title=\"Number of Elements\")\n        - spin_multiplicity: int = Field(None, description=\"Spin multiplicity of the molecule\")\n        - symmetry: PointGroupData = Field(None, description=\"Symmetry data for this molecule\")\n            - symmetry.eigen_tolerance: float = Field(None, title=\"Interia Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare eigen values of the inertia tensor.\")\n            - symmetry.linear: bool = Field(None, title=\"Molecule Linearity\", description=\"Is the molecule linear?\")\n            - symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry Operation Matrix Element Tolerance\" description=\"Tolerance used to generate the full set of symmetry operations of the point group.\")\n            - symmetry.rotation_number: float = Field(None, title=\"Rotational Symmetry Number\", description=\"Rotational symmetry number for the molecule\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice\")\n            - symmetry.tolerance: float = Field(None, title=\"Point Group Analyzer Tolerance\", description=\"Distance tolerance to consider sites as symmetrically equivalent.\")\n    \"\"\"\nadditional_fields = additional_fields or {}\natoms = copy_atoms(atoms)\nresults = {}\n# Get any charge or multiplicity keys\nif charge_and_multiplicity:\natoms.charge = charge_and_multiplicity[0]\natoms.spin_multiplicity = charge_and_multiplicity[1]\n# Strip the dummy atoms, if present\ndel atoms[[atom.index for atom in atoms if atom.symbol == \"X\"]]\n# Get Atoms metadata, if requested. emmet already has built-in tools for\n# generating pymatgen Structure/Molecule metadata, so we'll just use that.\nif get_metadata:\nif atoms.pbc.any():\nstruct = AseAtomsAdaptor().get_structure(atoms)\nmetadata = StructureMetadata().from_structure(struct).dict()\nif store_pmg:\nresults[\"structure\"] = struct\nelse:\nmol = AseAtomsAdaptor().get_molecule(atoms, charge_spin_check=False)\nmetadata = MoleculeMetadata().from_molecule(mol).dict()\nif store_pmg:\nresults[\"molecule\"] = mol\nmetadata[\"builder_meta\"][\"build_date\"] = str(\nmetadata[\"builder_meta\"][\"build_date\"]\n)\nelse:\nmetadata = {}\n# Copy the info flags as a separate entry in the DB for easy querying\nresults[\"atoms_info\"] = _quacc_sanitize(atoms.info)\n# Strip info if requested\nif strip_info:\natoms_no_info = copy_atoms(atoms)\natoms_no_info.info = {}\nresults[\"atoms\"] = atoms_no_info\nelse:\nresults[\"atoms\"] = atoms\n# Combine the metadata and results dictionaries\natoms_doc = metadata | results | additional_fields\nreturn clean_dict(atoms_doc, remove_empties=remove_empties)\n</code></pre>"},{"location":"reference/quacc/schemas/cclib.html","title":"cclib","text":"<p>Schemas for molecular DFT codes parsed by cclib</p>"},{"location":"reference/quacc/schemas/cclib.html#quacc.schemas.cclib.summarize_run","title":"summarize_run","text":"<pre><code>summarize_run(atoms, logfile_extensions, dir_path=None, pop_analyses=None, check_convergence=True, prep_next_run=True, remove_empties=False, additional_fields=None)\n</code></pre> <p>Get tabulated results from a molecular DFT run and store them in a database-friendly format. This is meant to be a general parser built on top of cclib.</p> <p>This document inherits from the following schemas: atomate2.common.schemas.cclib.TaskDocument, emmet.core.structure.MoleculeMetadata, emmet.core.base.EmmetBaseModel.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>ASE Atoms object following a calculation.</p> </li> <li> logfile_extensions             (<code>str | list[str]</code>)         \u2013          <p>Possible extensions of the log file (e.g. \".log\", \".out\", \".txt\", \".chk\"). Note that only a partial match is needed. For instance, <code>.log</code> will match <code>.log.gz</code> and <code>.log.1.gz</code>. If multiple files with this extension are found, the one with the most recent change time will be used. For an exact match only, put in the full file name.</p> </li> <li> dir_path             (<code>str | None</code>)         \u2013          <p>The path to the folder containing the calculation outputs. A value of None specifies the current working directory.</p> </li> <li> pop_analyses             (<code>list[Literal['cpsa', 'mpa', 'lpa', 'bickelhaupt', 'density', 'mbo', 'bader', 'ddec6', 'hirshfeld']]</code>)         \u2013          <p>The name(s) of any cclib post-processing analysis to run. Note that for bader, ddec6, and hirshfeld, a cube file (.cube, .cub) must reside in dir_path. Supports: \"cpsa\", \"mpa\", \"lpa\", \"bickelhaupt\", \"density\", \"mbo\", \"bader\", \"ddec6\", \"hirshfeld\".</p> </li> <li> check_convergence             (<code>bool</code>)         \u2013          <p>Whether to throw an error if geometry optimization convergence is not reached.</p> </li> <li> prep_next_run             (<code>bool</code>)         \u2013          <p>Whether the Atoms object storeed in {\"atoms\": atoms} should be prepared for the next run. This clears out any attached calculator and moves the final magmoms to the initial magmoms.</p> </li> <li> remove_empties             (<code>bool</code>)         \u2013          <p>Whether to remove None values and empty lists/dicts from the TaskDocument.</p> </li> <li> additional_fields             (<code>dict | None</code>)         \u2013          <p>Additional fields to add to the task document.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary representation of the task document with the following fields:</p> <ul> <li>atoms: Atoms = Field(None, title = \"The Atoms object obtained from atoms.\")</li> <li>atoms_info: dict = Field(None, title = \"The Atoms object info obtained from atoms.info.\")</li> <li>attributes: Dict = Field(None, description=\"Computed properties and calculation outputs. See https://cclib.github.io/data_notes.html\")</li> <li>builder_meta: EmmetMeta = Field(default_factory=EmmetMeta, description=\"Builder metadata.\"):</li> <li>builder_meta.build_date: str = Field(default_factory=datetime.utcnow, description=\"The build date for this document.\")</li> <li>builder_meta.database_version: str = Field(None, description=\"The database version for the built data.\")</li> <li>builder_meta.emmet_version: str = Field(version, description=\"The version of emmet this document was built with.\")</li> <li>builder_meta.pymatgen_version: str = Field(pmg_version, description=\"The version of pymatgen this document was built with.\")</li> <li>builder_meta.pull_request: int = Field(None, description=\"The pull request number associated with this data build.\")</li> <li>charge: int = Field(None, description=\"Charge of the molecule\")</li> <li>chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the molecule\")</li> <li>composition: Composition = Field(None, description=\"Full composition for the molecule\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition\")</li> <li>dir_name: str = Field(None, description=\"Directory where the output is parsed\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in the molecule\")</li> <li>energy: float = Field(None, description=\"Final total energy\")</li> <li>formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\", description=\"Alphabetical molecular formula\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")</li> <li>last_updated: str = Field(default_factory=datetime_str, description=\"Timestamp for this task document was last updated\")</li> <li>logfile: str = Field(None, description=\"Path to the log file used in the post-processing analysis\")</li> <li>metadata: Dict = Field(None, description=\"Calculation metadata, including input parameters and runtime statistics. See https://cclib.github.io/data_notes.html#metadata\")</li> <li>molecule: Molecule = Field(None, description=\"Final output molecule from the task\")</li> <li>natoms: int = Field(None, description=\"Total number of atoms in the molecule\")</li> <li>nid: str = Field(None, title = \"The node ID representing the machine where the calculation was run.\")</li> <li>nelectrons: int = Field(None, title=\"Number of electrons\", description=\"The total number of electrons for the molecule\")</li> <li>nelements: int = Field(None, title=\"Number of Elements\")</li> <li>parameters: dict = Field(None, title = \"The input parameters obtained from atoms.calc.parameters.\")</li> <li>spin_multiplicity: int = Field(None, description=\"Spin multiplicity of the molecule\")</li> <li>symmetry: PointGroupData = Field(None, description=\"Symmetry data for this molecule\")</li> <li>symmetry.eigen_tolerance: float = Field(None, title=\"Interia Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare eigen values of the inertia tensor.\")</li> <li>symmetry.linear: bool = Field(None, title=\"Molecule Linearity\", description=\"Is the molecule linear?\")</li> <li>symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry Operation Matrix Element Tolerance\" description=\"Tolerance used to generate the full set of symmetry operations of the point group.\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice\")</li> <li>symmetry.rotation_number: float = Field(None, title=\"Rotational Symmetry Number\", description=\"Rotational symmetry number for the molecule\")</li> <li>symmetry.tolerance: float = Field(None, title=\"Point Group Analyzer Tolerance\", description=\"Distance tolerance to consider sites as symmetrically equivalent.\")</li> <li>tags: List[str] = Field(None, description=\"Optional tags for this task document\")</li> <li>task_label: str = Field(None, description=\"A description of the task\")</li> </ul> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/schemas/cclib.py</code> <pre><code>def summarize_run(\natoms: Atoms,\nlogfile_extensions: str | list[str],\ndir_path: str | None = None,\npop_analyses: list[\nLiteral[\n\"cpsa\",\n\"mpa\",\n\"lpa\",\n\"bickelhaupt\",\n\"density\",\n\"mbo\",\n\"bader\",\n\"ddec6\",\n\"hirshfeld\",\n]\n] = None,\ncheck_convergence: bool = True,\nprep_next_run: bool = True,\nremove_empties: bool = False,\nadditional_fields: dict | None = None,\n) -&gt; cclibSchema:\n\"\"\"\n    Get tabulated results from a molecular DFT run and store them in a database-friendly format.\n    This is meant to be a general parser built on top of cclib.\n    This document inherits from the following schemas: atomate2.common.schemas.cclib.TaskDocument,\n    emmet.core.structure.MoleculeMetadata, emmet.core.base.EmmetBaseModel.\n    Parameters\n    ----------\n    atoms\n        ASE Atoms object following a calculation.\n    logfile_extensions\n        Possible extensions of the log file (e.g. \".log\", \".out\", \".txt\", \".chk\"). Note that\n        only a partial match is needed. For instance, `.log` will match `.log.gz` and `.log.1.gz`.\n        If multiple files with this extension are found, the one with the most recent change time\n        will be used. For an exact match only, put in the full file name.\n    dir_path\n        The path to the folder containing the calculation outputs. A value of None specifies the\n        current working directory.\n    pop_analyses\n        The name(s) of any cclib post-processing analysis to run. Note that for\n        bader, ddec6, and hirshfeld, a cube file (.cube, .cub) must reside in dir_path.\n        Supports: \"cpsa\", \"mpa\", \"lpa\", \"bickelhaupt\", \"density\", \"mbo\", \"bader\", \"ddec6\",\n        \"hirshfeld\".\n    check_convergence\n         Whether to throw an error if geometry optimization convergence is not reached.\n    prep_next_run\n        Whether the Atoms object storeed in {\"atoms\": atoms} should be prepared for the next run.\n        This clears out any attached calculator and moves the final magmoms to the initial magmoms.\n    remove_empties\n        Whether to remove None values and empty lists/dicts from the TaskDocument.\n    additional_fields\n        Additional fields to add to the task document.\n    Returns\n    -------\n    dict\n        Dictionary representation of the task document with the following fields:\n        - atoms: Atoms = Field(None, title = \"The Atoms object obtained from atoms.\")\n        - atoms_info: dict = Field(None, title = \"The Atoms object info obtained from atoms.info.\")\n        - attributes: Dict = Field(None, description=\"Computed properties and calculation outputs. See https://cclib.github.io/data_notes.html\")\n        - builder_meta: EmmetMeta = Field(default_factory=EmmetMeta, description=\"Builder metadata.\"):\n            - builder_meta.build_date: str = Field(default_factory=datetime.utcnow, description=\"The build date for this document.\")\n            - builder_meta.database_version: str = Field(None, description=\"The database version for the built data.\")\n            - builder_meta.emmet_version: str = Field(__version__, description=\"The version of emmet this document was built with.\")\n            - builder_meta.pymatgen_version: str = Field(pmg_version, description=\"The version of pymatgen this document was built with.\")\n            - builder_meta.pull_request: int = Field(None, description=\"The pull request number associated with this data build.\")\n        - charge: int = Field(None, description=\"Charge of the molecule\")\n        - chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the molecule\")\n        - composition: Composition = Field(None, description=\"Full composition for the molecule\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition\")\n        - dir_name: str = Field(None, description=\"Directory where the output is parsed\")\n        - elements: List[Element] = Field(None, description=\"List of elements in the molecule\")\n        - energy: float = Field(None, description=\"Final total energy\")\n        - formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\", description=\"Alphabetical molecular formula\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")\n        - last_updated: str = Field(default_factory=datetime_str, description=\"Timestamp for this task document was last updated\")\n        - logfile: str = Field(None, description=\"Path to the log file used in the post-processing analysis\")\n        - metadata: Dict = Field(None, description=\"Calculation metadata, including input parameters and runtime statistics. See https://cclib.github.io/data_notes.html#metadata\")\n        - molecule: Molecule = Field(None, description=\"Final output molecule from the task\")\n        - natoms: int = Field(None, description=\"Total number of atoms in the molecule\")\n        - nid: str = Field(None, title = \"The node ID representing the machine where the calculation was run.\")\n        - nelectrons: int = Field(None, title=\"Number of electrons\", description=\"The total number of electrons for the molecule\")\n        - nelements: int = Field(None, title=\"Number of Elements\")\n        - parameters: dict = Field(None, title = \"The input parameters obtained from atoms.calc.parameters.\")\n        - spin_multiplicity: int = Field(None, description=\"Spin multiplicity of the molecule\")\n        - symmetry: PointGroupData = Field(None, description=\"Symmetry data for this molecule\")\n            - symmetry.eigen_tolerance: float = Field(None, title=\"Interia Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare eigen values of the inertia tensor.\")\n            - symmetry.linear: bool = Field(None, title=\"Molecule Linearity\", description=\"Is the molecule linear?\")\n            - symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry Operation Matrix Element Tolerance\" description=\"Tolerance used to generate the full set of symmetry operations of the point group.\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice\")\n            - symmetry.rotation_number: float = Field(None, title=\"Rotational Symmetry Number\", description=\"Rotational symmetry number for the molecule\")\n            - symmetry.tolerance: float = Field(None, title=\"Point Group Analyzer Tolerance\", description=\"Distance tolerance to consider sites as symmetrically equivalent.\")\n        - tags: List[str] = Field(None, description=\"Optional tags for this task document\")\n        - task_label: str = Field(None, description=\"A description of the task\")\n    \"\"\"\n# Make sure there is a calculator with results\nif not atoms.calc:\nraise ValueError(\"ASE Atoms object has no attached calculator.\")\nif not atoms.calc.results:\nraise ValueError(\"ASE Atoms object's calculator has no results.\")\nadditional_fields = additional_fields or {}\ndir_path = dir_path or os.getcwd()\n# Fortunately, there is already a cclib parser in Atomate2\nresults = TaskDocument.from_logfile(\ndir_path, logfile_extensions, analysis=pop_analyses\n).dict()\nuri = results[\"dir_name\"]\nresults[\"nid\"] = uri.split(\":\")[0]\nresults[\"dir_name\"] = \":\".join(uri.split(\":\")[1:])\nresults[\"builder_meta\"][\"build_date\"] = str(results[\"builder_meta\"][\"build_date\"])\nresults[\"logfile\"] = results[\"logfile\"].split(\":\")[-1]\n# Check convergence if requested\nif check_convergence and results[\"attributes\"].get(\"optdone\") is False:\nraise ValueError(\"Optimization not complete.\")\n# Get the calculator inputs\ninputs = {\"parameters\": atoms.calc.parameters}\n# Prepares the Atoms object for the next run by moving the\n# final magmoms to initial, clearing the calculator state,\n# and assigning the resulting Atoms object a unique ID.\nif prep_next_run:\natoms = prep_next_run_(atoms)\n# We use get_metadata=False and store_pmg=False because the TaskDocument already\n# makes the structure metadata for us\natoms_db = atoms_to_metadata(atoms, get_metadata=False, store_pmg=False)\n# Create a dictionary of the inputs/outputs\ntask_doc = atoms_db | inputs | results | additional_fields\nreturn clean_dict(task_doc, remove_empties=remove_empties)\n</code></pre>"},{"location":"reference/quacc/schemas/vasp.html","title":"vasp","text":"<p>Schemas for VASP</p>"},{"location":"reference/quacc/schemas/vasp.html#quacc.schemas.vasp.summarize_run","title":"summarize_run","text":"<pre><code>summarize_run(atoms, dir_path=None, prep_next_run=True, run_bader=None, check_convergence=True, remove_empties=False, additional_fields=None)\n</code></pre> <p>Get tabulated results from a VASP run and store them in a database-friendly format.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>ASE Atoms object following a calculation.</p> </li> <li> dir_path             (<code>str | None</code>)         \u2013          <p>Path to VASP outputs. A value of None specifies the current working directory</p> </li> <li> prep_next_run             (<code>bool</code>)         \u2013          <p>Whether the Atoms object stored in {\"atoms\": atoms} should be prepared for the next run. This clears out any attached calculator and moves the final magmoms to the initial magmoms.</p> </li> <li> run_bader             (<code>bool | None</code>)         \u2013          <p>Whether a Bader analysis should be performed. Will not run if bader executable is not in PATH even if bader is set to True. Defaults to VASP_BADER in settings.</p> </li> <li> check_convergence             (<code>bool</code>)         \u2013          <p>Whether to throw an error if convergence is not reached.</p> </li> <li> remove_empties             (<code>bool</code>)         \u2013          <p>Whether to remove None values and empty lists/dicts from the TaskDocument.</p> </li> <li> additional_fields             (<code>dict | None</code>)         \u2013          <p>Additional fields to add to the task document.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary representation of the task document with the following fields:</p> <ul> <li>analysis: AnalysisDoc = Field(None, title=\"Calculation Analysis\", description=\"Some analysis of calculation data after collection.\")</li> <li>analysis.delta_volume: float = Field(None, title=\"Volume Change\", description=\"Volume change for the calculation.\")</li> <li>analysis.delta_volume_percent: float = Field(None, title=\"Volume Change Percent\", description=\"Percent volume change for the calculation.\")</li> <li>analysis.max_force: float = Field(None, title=\"Max Force\", description=\"Maximum force on any atom at the end of the calculation.\")</li> <li>analysis.warnings: List[str] = Field(None, title=\"Calculation Warnings\",description=\"Warnings issued after analysis.\")</li> <li>analysis.errors: List[str] = Field(None, title=\"Calculation Errors\", description=\"Errors issued after analysis.\")</li> <li>atoms: Atoms = Field(None, title = \"The Atoms object from the calculation result.\")</li> <li>atoms_info: dict = Field(None, title = \"The Atoms object info obtained from atoms.info.\")</li> <li>builder_meta: EmmetMeta = Field(default_factory=EmmetMeta, description=\"Builder metadata.\"):</li> <li>builder_meta.build_date: str = Field(default_factory=datetime.utcnow, description=\"The build date for this document.\")</li> <li>builder_meta.emmet_version: str = Field(version, description=\"The version of emmet this document was built with.\")</li> <li>builder_meta.pymatgen_version: str = Field(pmg_version, description=\"The version of pymatgen this document was built with.\")</li> <li>chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the material.\")</li> <li>composition: Composition = Field(None, description=\"Full composition for the material.\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition.\")</li> <li>custodian: List[CustodianDoc] = Field(None, title=\"Calcs reversed data\", description=\"Detailed custodian data for each VASP calculation contributing to the task document.\")</li> <li>custodian.corrections: List[Any] = Field(None, title=\"Custodian Corrections\", description=\"List of custodian correction data for calculation.\")</li> <li>custodian.job: dict = Field(None, title=\"Cusotodian Job Data\", description=\"Job data logged by custodian.\",)</li> <li>density: float = Field(None, title=\"Density\", description=\"Density in grams per cm^3.\")</li> <li>density_atomic: float = Field(None, title=\"Packing Density\", description=\"The atomic packing density in atoms per cm^3.\")</li> <li>dir_name: str = Field(None, description=\"The directory for this VASP task\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in the material.\")</li> <li>entry: ComputedEntry = Field(None, description=\"The ComputedEntry from the task doc\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula.\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")</li> <li>input: InputDoc = Field(None, description=\"The input structure used to generate the current task document.\")</li> <li>input.incar: Dict[str, Any] = Field(None, description=\"INCAR parameters for the calculation\")</li> <li>input.is_hubbard: bool = Field(False, description=\"Is this a Hubbard +U calculation\")</li> <li>input.kpoints: Union[Dict[str, Any], Kpoints] = Field(None, description=\"KPOINTS for the calculation\")</li> <li>input.hubbards: Dict = Field(None, description=\"The hubbard parameters used\")</li> <li>input.lattice_rec: Lattice = Field(None, description=\"Reciprocal lattice of the structure\")</li> <li>input.nkpoints: int = Field(None, description=\"Total number of k-points\")</li> <li>input.potcar: List[str] = Field(None, description=\"POTCAR symbols in the calculation\")</li> <li>input.potcar_spec: List[PotcarSpec] = Field(None, description=\"Title and hash of POTCAR files used in the calculation\")</li> <li>input.potcar_type: List[str] = Field(None, description=\"List of POTCAR functional types.\")</li> <li>input.parameters: Dict = Field(None, description=\"Parameters from vasprun\")</li> <li>input.structure: Structure = Field(None, description=\"Input structure for the calculation\")</li> <li>nelements: int = Field(None, description=\"Number of elements.\")</li> <li>nid: str = Field(None, title = \"The node ID representing the machine where the calculation was run.\")</li> <li>nsites: int = Field(None, description=\"Total number of sites in the structure.\")</li> <li>orig_inputs: OrigInputs = Field(None, description=\"The exact set of input parameters used to generate the current task document.\")</li> <li>orig_inputs.incar: Union[Incar, Dict] = Field(None, description=\"Pymatgen object representing the INCAR file.\")</li> <li>orig_inputs.poscar: Poscar = Field(None, description=\"Pymatgen object representing the POSCAR file.\")</li> <li>orig_inputs.kpoints: Kpoints = Field(None, description=\"Pymatgen object representing the KPOINTS file.\")</li> <li>orig_inputs.potcar: Union[Potcar, VaspPotcar, List[Any]] = Field(None, description=\"Pymatgen object representing the POTCAR file.\",)</li> <li>output: OutputDoc = Field(None, description=\"The exact set of output parameters used to generate the current task document.\")</li> <li>output.bandgap: float = Field(None, description=\"The DFT bandgap for the last calculation\")</li> <li>output.density: float = Field(..., description=\"Density of in units of g/cc.\")</li> <li>output.direct_gap: float = the direct bandgap (eV)</li> <li>output.dos_properties: DosProperties = Field(None, description=\"DOS properties for the material\")</li> <li>output.efermi: float = the fermi energy</li> <li>output.energy: float = Field(..., description=\"Total Energy in units of eV.\")</li> <li>output.energy_per_atom: float = Field(None, description=\"The final DFT energy per atom for the last calculation\")</li> <li>output.forces: List[List[float]] = Field(None, description=\"The force on each atom in units of eV/A^2.\")</li> <li>output.ionic_steps: float = the number of ionic steps</li> <li>output.is_gap_direct: bool = if the band gap is direct</li> <li>output.mag_density: float = magnetization density</li> <li>output.outcar: Outcar = Field(None, description=\"Pymatgen object representing the OUTCAR file.\")</li> <li>output.run_stats: Dict = Field(None, description=\"Runtime statistics from the calculation.\")</li> <li>output.stress: List[List[float]] = Field(None, description=\"The stress on the cell in units of kB.\")</li> <li>output.structure: Structure = Field(None, title=\"Output Structure\", description=\"Output Structure from the VASP calculation.\")</li> <li>state: TaskState = Field(None, description=\"State of this calculation\")</li> <li>symmetry: SymmetryData = Field(None, description=\"Symmetry data for this material.\")</li> <li>symmetry.crystal_system: CrystalSystem = Field(None, title=\"Crystal System\", description=\"The crystal system for this lattice.\")</li> <li>symmetry.number: int = Field(None, title=\"Space Group Number\", description=\"The spacegroup number for the lattice.\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice.\")</li> <li>symmetry.symbol: str = Field(None, title=\"Space Group Symbol\", description=\"The spacegroup symbol for the lattice.\")</li> <li>symmetry.symprec: float = Field(None, title=\"Symmetry Finding Precision\", description=\"The precision given to spglib to determine the symmetry of this lattice.\")</li> <li>symmetry.version</li> <li>vasp_version: str: the version of VASP</li> <li>volume: float = Field(None, title=\"Volume\", description=\"Total volume for this structure in Angstroms^3.\")</li> </ul> <p>If run_bader is True, the following fields are added:</p> <ul> <li>bader</li> <li>bader.atomic_volume: float = The atomic volume</li> <li>bader.bader_charge: float = The net bader charge</li> <li>bader.bader_spin: float = The net bader spin density</li> <li>bader.bader_version: float = The bader version</li> <li>bader.min_dist: List[float] = The bader min_dist parameter</li> <li>bader.partial_charges: List[float] = The atom-projected bader partial charges</li> <li>bader.spin_moments: List[float] = The atom-projected bader spin moments</li> </ul> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/schemas/vasp.py</code> <pre><code>def summarize_run(\natoms: Atoms,\ndir_path: str | None = None,\nprep_next_run: bool = True,\nrun_bader: bool | None = None,\ncheck_convergence: bool = True,\nremove_empties: bool = False,\nadditional_fields: dict | None = None,\n) -&gt; VaspSchema:\n\"\"\"\n    Get tabulated results from a VASP run and store them in a database-friendly format.\n    Parameters\n    ----------\n    atoms\n        ASE Atoms object following a calculation.\n    dir_path\n        Path to VASP outputs. A value of None specifies the current working directory\n    prep_next_run\n        Whether the Atoms object stored in {\"atoms\": atoms} should be prepared for the next run.\n        This clears out any attached calculator and moves the final magmoms to the initial magmoms.\n    run_bader\n        Whether a Bader analysis should be performed. Will not run if bader executable is not in PATH even if\n        bader is set to True.\n        Defaults to VASP_BADER in settings.\n    check_convergence\n        Whether to throw an error if convergence is not reached.\n    remove_empties\n        Whether to remove None values and empty lists/dicts from the TaskDocument.\n    additional_fields\n        Additional fields to add to the task document.\n    Returns\n    -------\n    dict\n        Dictionary representation of the task document with the following fields:\n        - analysis: AnalysisDoc = Field(None, title=\"Calculation Analysis\", description=\"Some analysis of calculation data after collection.\")\n            - analysis.delta_volume: float = Field(None, title=\"Volume Change\", description=\"Volume change for the calculation.\")\n            - analysis.delta_volume_percent: float = Field(None, title=\"Volume Change Percent\", description=\"Percent volume change for the calculation.\")\n            - analysis.max_force: float = Field(None, title=\"Max Force\", description=\"Maximum force on any atom at the end of the calculation.\")\n            - analysis.warnings: List[str] = Field(None, title=\"Calculation Warnings\",description=\"Warnings issued after analysis.\")\n            - analysis.errors: List[str] = Field(None, title=\"Calculation Errors\", description=\"Errors issued after analysis.\")\n        - atoms: Atoms = Field(None, title = \"The Atoms object from the calculation result.\")\n        - atoms_info: dict = Field(None, title = \"The Atoms object info obtained from atoms.info.\")\n        - builder_meta: EmmetMeta = Field(default_factory=EmmetMeta, description=\"Builder metadata.\"):\n            - builder_meta.build_date: str = Field(default_factory=datetime.utcnow, description=\"The build date for this document.\")\n            - builder_meta.emmet_version: str = Field(__version__, description=\"The version of emmet this document was built with.\")\n            - builder_meta.pymatgen_version: str = Field(pmg_version, description=\"The version of pymatgen this document was built with.\")\n        - chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the material.\")\n        - composition: Composition = Field(None, description=\"Full composition for the material.\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified representation of the composition.\")\n        - custodian: List[CustodianDoc] = Field(None, title=\"Calcs reversed data\", description=\"Detailed custodian data for each VASP calculation contributing to the task document.\")\n            - custodian.corrections: List[Any] = Field(None, title=\"Custodian Corrections\", description=\"List of custodian correction data for calculation.\")\n            - custodian.job: dict = Field(None, title=\"Cusotodian Job Data\", description=\"Job data logged by custodian.\",)\n        - density: float = Field(None, title=\"Density\", description=\"Density in grams per cm^3.\")\n        - density_atomic: float = Field(None, title=\"Packing Density\", description=\"The atomic packing density in atoms per cm^3.\")\n        - dir_name: str = Field(None, description=\"The directory for this VASP task\")\n        - elements: List[Element] = Field(None, description=\"List of elements in the material.\")\n        - entry: ComputedEntry = Field(None, description=\"The ComputedEntry from the task doc\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\", description=\"Anonymized representation of the formula.\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\", description=\"Cleaned representation of the formula.\")\n        - input: InputDoc = Field(None, description=\"The input structure used to generate the current task document.\")\n            - input.incar: Dict[str, Any] = Field(None, description=\"INCAR parameters for the calculation\")\n            - input.is_hubbard: bool = Field(False, description=\"Is this a Hubbard +U calculation\")\n            - input.kpoints: Union[Dict[str, Any], Kpoints] = Field(None, description=\"KPOINTS for the calculation\")\n            - input.hubbards: Dict = Field(None, description=\"The hubbard parameters used\")\n            - input.lattice_rec: Lattice = Field(None, description=\"Reciprocal lattice of the structure\")\n            - input.nkpoints: int = Field(None, description=\"Total number of k-points\")\n            - input.potcar: List[str] = Field(None, description=\"POTCAR symbols in the calculation\")\n            - input.potcar_spec: List[PotcarSpec] = Field(None, description=\"Title and hash of POTCAR files used in the calculation\")\n            - input.potcar_type: List[str] = Field(None, description=\"List of POTCAR functional types.\")\n            - input.parameters: Dict = Field(None, description=\"Parameters from vasprun\")\n            - input.structure: Structure = Field(None, description=\"Input structure for the calculation\")\n        - nelements: int = Field(None, description=\"Number of elements.\")\n        - nid: str = Field(None, title = \"The node ID representing the machine where the calculation was run.\")\n        - nsites: int = Field(None, description=\"Total number of sites in the structure.\")\n        - orig_inputs: OrigInputs = Field(None, description=\"The exact set of input parameters used to generate the current task document.\")\n            - orig_inputs.incar: Union[Incar, Dict] = Field(None, description=\"Pymatgen object representing the INCAR file.\")\n            - orig_inputs.poscar: Poscar = Field(None, description=\"Pymatgen object representing the POSCAR file.\")\n            - orig_inputs.kpoints: Kpoints = Field(None, description=\"Pymatgen object representing the KPOINTS file.\")\n            - orig_inputs.potcar: Union[Potcar, VaspPotcar, List[Any]] = Field(None, description=\"Pymatgen object representing the POTCAR file.\",)\n        - output: OutputDoc = Field(None, description=\"The exact set of output parameters used to generate the current task document.\")\n            - output.bandgap: float = Field(None, description=\"The DFT bandgap for the last calculation\")\n            - output.density: float = Field(..., description=\"Density of in units of g/cc.\")\n            - output.direct_gap: float = the direct bandgap (eV)\n            - output.dos_properties: DosProperties = Field(None, description=\"DOS properties for the material\")\n            - output.efermi: float = the fermi energy\n            - output.energy: float = Field(..., description=\"Total Energy in units of eV.\")\n            - output.energy_per_atom: float = Field(None, description=\"The final DFT energy per atom for the last calculation\")\n            - output.forces: List[List[float]] = Field(None, description=\"The force on each atom in units of eV/A^2.\")\n            - output.ionic_steps: float = the number of ionic steps\n            - output.is_gap_direct: bool = if the band gap is direct\n            - output.mag_density: float = magnetization density\n            - output.outcar: Outcar = Field(None, description=\"Pymatgen object representing the OUTCAR file.\")\n            - output.run_stats: Dict = Field(None, description=\"Runtime statistics from the calculation.\")\n            - output.stress: List[List[float]] = Field(None, description=\"The stress on the cell in units of kB.\")\n            - output.structure: Structure = Field(None, title=\"Output Structure\", description=\"Output Structure from the VASP calculation.\")\n        - state: TaskState = Field(None, description=\"State of this calculation\")\n        - symmetry: SymmetryData = Field(None, description=\"Symmetry data for this material.\")\n            - symmetry.crystal_system: CrystalSystem = Field(None, title=\"Crystal System\", description=\"The crystal system for this lattice.\")\n            - symmetry.number: int = Field(None, title=\"Space Group Number\", description=\"The spacegroup number for the lattice.\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group Symbol\", description=\"The point group for the lattice.\")\n            - symmetry.symbol: str = Field(None, title=\"Space Group Symbol\", description=\"The spacegroup symbol for the lattice.\")\n            - symmetry.symprec: float = Field(None, title=\"Symmetry Finding Precision\", description=\"The precision given to spglib to determine the symmetry of this lattice.\")\n            - symmetry.version\n        - vasp_version: str: the version of VASP\n        - volume: float = Field(None, title=\"Volume\", description=\"Total volume for this structure in Angstroms^3.\")\n        If run_bader is True, the following fields are added:\n        - bader\n            - bader.atomic_volume: float = The atomic volume\n            - bader.bader_charge: float = The net bader charge\n            - bader.bader_spin: float = The net bader spin density\n            - bader.bader_version: float = The bader version\n            - bader.min_dist: List[float] = The bader min_dist parameter\n            - bader.partial_charges: List[float] = The atom-projected bader partial charges\n            - bader.spin_moments: List[float] = The atom-projected bader spin moments\n    \"\"\"\nadditional_fields = additional_fields or {}\nrun_bader = SETTINGS.VASP_BADER if run_bader is None else run_bader\ndir_path = dir_path or os.getcwd()\n# Fetch all tabulated results from VASP outputs files\n# Fortunately, emmet already has a handy function for this\nresults = TaskDoc.from_directory(dir_path).dict()\nuri = results[\"dir_name\"]\nresults[\"nid\"] = uri.split(\":\")[0]\nresults[\"dir_name\"] = \":\".join(uri.split(\":\")[1:])\nresults[\"builder_meta\"][\"build_date\"] = str(results[\"builder_meta\"][\"build_date\"])\n# Check for calculation convergence\nif check_convergence and results[\"state\"] != \"successful\":\nraise RuntimeError(\n\"VASP calculation did not converge. Will not store task data.\"\n)\n# Remove unnecessary fields\nfor k in [\n\"additional_json\",\n\"author\",\n\"calcs_reversed\",\n\"icsd_id\",\n\"last_updated\",\n\"structure\",  # already in output\n\"tags\",\n\"task_id\",\n\"task_label\",\n\"transformations\",\n\"vasp_objects\",\n]:\nresults.pop(k, None)\nif \"output\" in results:\nresults[\"output\"].pop(\"elph_displaced_structures\", None)\nresults[\"output\"].pop(\"frequency_dependent_dielectric\", None)\n# Get Bader analysis\nif run_bader:\ntry:\nbader_stats = bader_runner(dir_path)\nexcept Exception:\nbader_stats = None\nwarnings.warn(\"Bader analysis could not be performed.\", UserWarning)\nif bader_stats:\nresults[\"bader\"] = bader_stats\n# Attach bader charges/spins to structure object\nstruct = results[\"output\"][\"structure\"]\nstruct.add_site_property(\"bader_charge\", bader_stats[\"partial_charges\"])\nif \"spin_moments\" in bader_stats:\nstruct.add_site_property(\"bader_spin\", bader_stats[\"spin_moments\"])\nresults[\"output\"][\"structure\"] = struct\n# Prepares the Atoms object for the next run by moving the\n# final magmoms to initial, clearing the calculator state,\n# and assigning the resulting Atoms object a unique ID.\nif prep_next_run:\natoms = prep_next_run_(atoms)\n# We use get_metadata=False and store_pmg=False because the TaskDocument already\n# makes the structure metadata for us\natoms_db = atoms_to_metadata(atoms, get_metadata=False, store_pmg=False)\ntask_doc = results | atoms_db | additional_fields\nreturn clean_dict(task_doc, remove_empties=remove_empties)\n</code></pre>"},{"location":"reference/quacc/util/atoms.html","title":"atoms","text":"<p>Utility functions for dealing with Atoms</p>"},{"location":"reference/quacc/util/atoms.html#quacc.util.atoms.check_is_metal","title":"check_is_metal","text":"<pre><code>check_is_metal(atoms)\n</code></pre> <p>Checks if a structure is a likely metal.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True if the structure is likely a metal; False otherwise</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/util/atoms.py</code> <pre><code>def check_is_metal(atoms: Atoms) -&gt; bool:\n\"\"\"\n    Checks if a structure is a likely metal.\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    Returns\n    -------\n    bool\n        True if the structure is likely a metal; False otherwise\n    \"\"\"\nif atoms.pbc.any():\nstruct = AseAtomsAdaptor.get_structure(atoms)\nelse:\nstruct = AseAtomsAdaptor.get_molecule(atoms)\nreturn all(k.is_metal for k in struct.composition.keys())\n</code></pre>"},{"location":"reference/quacc/util/atoms.html#quacc.util.atoms.copy_atoms","title":"copy_atoms","text":"<pre><code>copy_atoms(atoms)\n</code></pre> <p>Simple function to copy an atoms object to prevent mutability.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>atoms</code>         \u2013          <p>Atoms object</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/util/atoms.py</code> <pre><code>def copy_atoms(atoms: Atoms) -&gt; Atoms:\n\"\"\"\n    Simple function to copy an atoms object to prevent mutability.\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    Returns\n    -------\n    atoms\n        Atoms object\n    \"\"\"\ntry:\natoms = deepcopy(atoms)\nexcept Exception:\n# Needed because of ASE issue #1084\ncalc = atoms.calc\natoms = atoms.copy()\natoms.calc = calc\nreturn atoms\n</code></pre>"},{"location":"reference/quacc/util/atoms.html#quacc.util.atoms.get_atoms_id","title":"get_atoms_id","text":"<pre><code>get_atoms_id(atoms)\n</code></pre> <p>Returns a unique ID for the Atoms object. Note: The .info dict and calculator is excluded from the hash generation.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>md5hash</code>         \u2013          <p>MD5 hash of the Atoms object</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/util/atoms.py</code> <pre><code>def get_atoms_id(atoms: Atoms) -&gt; str:\n\"\"\"\n    Returns a unique ID for the Atoms object. Note: The .info dict\n    and calculator is excluded from the hash generation.\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    Returns\n    -------\n    md5hash\n        MD5 hash of the Atoms object\n    \"\"\"\natoms = copy_atoms(atoms)\natoms.info = {}\natoms.calc = None\nencoded_atoms = encode(atoms)\n# This is a hack to avoid int32/int64 and float32/float64 differences\n# between machines.\nencoded_atoms = (\nencoded_atoms.replace(\"int64\", \"int\")\n.replace(\"int32\", \"int\")\n.replace(\"float64\", \"float\")\n.replace(\"float32\", \"float\")\n)\nreturn hashlib.md5(encoded_atoms.encode(\"utf-8\")).hexdigest()\n</code></pre>"},{"location":"reference/quacc/util/atoms.html#quacc.util.atoms.get_highest_block","title":"get_highest_block","text":"<pre><code>get_highest_block(atoms)\n</code></pre> <p>Get the highest block (e.g. p-block, d-block f-block) of a structure</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>highest block of the structure</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/util/atoms.py</code> <pre><code>def get_highest_block(atoms: Atoms) -&gt; str:\n\"\"\"\n    Get the highest block (e.g. p-block, d-block f-block) of a structure\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    Returns\n    -------\n    str\n        highest block of the structure\n    \"\"\"\nif atoms.pbc.any():\nstruct = AseAtomsAdaptor.get_structure(atoms)\nelse:\nstruct = AseAtomsAdaptor.get_molecule(atoms)\nblocks = [site.specie.block for site in struct]\nreturn (\n\"f\"\nif \"f\" in blocks\nelse \"d\"\nif \"d\" in blocks\nelse \"p\"\nif \"p\" in blocks\nelse \"s\"\n)\n</code></pre>"},{"location":"reference/quacc/util/atoms.html#quacc.util.atoms.prep_next_run","title":"prep_next_run","text":"<pre><code>prep_next_run(atoms, assign_id=True, move_magmoms=True, store_results=False)\n</code></pre> <p>Prepares the Atoms object for a new run.</p> <p>Depending on the arguments, this function will:     - Move the converged magnetic moments to the initial magnetic moments.     - Assign a unique ID to the Atoms object in atoms.info[\"_id\"]. Any existing IDs will     be moved to atoms.info[\"_old_ids\"].     - Store the calculator results in atoms.info[\"results\"] for later retrieval.     This makes it so the calculator results are not lost between     serialize/deserialize cycles, if desired. Each one will be stored in     atoms.info[\"results\"] = {\"calc0\": {}, \"calc1\": {}, ...} with higher numbers     being the most recent.</p> <p>In all cases, the calculator will be reset so new jobs can be run.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> assign_id             (<code>bool</code>)         \u2013          <p>Whether to assign a unique ID to the Atoms object in atoms.info[\"_id\"]. Any existing IDs will be moved to atoms.info[\"_old_ids\"].</p> </li> <li> move_magmoms             (<code>bool</code>)         \u2013          <p>If True, move atoms.calc.results[\"magmoms\"] to atoms.get_initial_magnetic_moments()</p> </li> <li> store_results             (<code>bool</code>)         \u2013          <p>If True, store calculator results in atoms.info[\"results\"]. This makes it so the calculator results are not lost between serialize/deserialize cycles, if desired. Each one will be stored in atoms.info[\"results\"] = {\"calc0\": {}, \"calc1\": {}, ...} with higher numbers being the most recent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>         \u2013          <p>Atoms object with calculator results attached in atoms.info[\"results\"]</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/util/atoms.py</code> <pre><code>def prep_next_run(\natoms: Atoms,\nassign_id: bool = True,\nmove_magmoms: bool = True,\nstore_results: bool = False,\n) -&gt; Atoms:\n\"\"\"\n    Prepares the Atoms object for a new run.\n    Depending on the arguments, this function will:\n        - Move the converged magnetic moments to the initial magnetic moments.\n        - Assign a unique ID to the Atoms object in atoms.info[\"_id\"]. Any existing IDs will\n        be moved to atoms.info[\"_old_ids\"].\n        - Store the calculator results in atoms.info[\"results\"] for later retrieval.\n        This makes it so the calculator results are not lost between\n        serialize/deserialize cycles, if desired. Each one will be stored in\n        atoms.info[\"results\"] = {\"calc0\": {}, \"calc1\": {}, ...} with higher numbers\n        being the most recent.\n    In all cases, the calculator will be reset so new jobs can be run.\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    assign_id\n        Whether to assign a unique ID to the Atoms object in atoms.info[\"_id\"].\n        Any existing IDs will be moved to atoms.info[\"_old_ids\"].\n    move_magmoms\n        If True, move atoms.calc.results[\"magmoms\"] to atoms.get_initial_magnetic_moments()\n    store_results\n        If True, store calculator results in atoms.info[\"results\"]. This makes it so the calculator results\n        are not lost between serialize/deserialize cycles, if desired. Each one will be stored in\n        atoms.info[\"results\"] = {\"calc0\": {}, \"calc1\": {}, ...} with higher numbers being the most recent.\n    Returns\n    -------\n    Atoms\n        Atoms object with calculator results attached in atoms.info[\"results\"]\n    \"\"\"\natoms = copy_atoms(atoms)\nif hasattr(atoms, \"calc\") and getattr(atoms.calc, \"results\", None) is not None:\nif store_results:\n# Dump calculator results into the .info tag\natoms.calc.results[\"rundir\"] = os.getcwd()\nif atoms.info.get(\"results\", None) is None:\nprior_calcs = 0\natoms.info[\"results\"] = {}\nelse:\nprior_calcs = len(atoms.info[\"results\"])\natoms.info[\"results\"][f\"calc{prior_calcs}\"] = atoms.calc.results\n# Move converged magmoms to initial magmoms\nif move_magmoms:\n# If there are initial magmoms set, then we should see what the final\n# magmoms are. If they are present, move them to initial. If they are not\n# present, it means the calculator doesn't support the \"magmoms\" property\n# so we have to retain the initial magmoms given no futher info.\nif atoms.has(\"initial_magmoms\"):\natoms.set_initial_magnetic_moments(\natoms.calc.results.get(\n\"magmoms\", atoms.get_initial_magnetic_moments()\n)\n)\n# If there are no initial magmoms set, just check the results and set\n# everything to 0.0 if there is nothing there.\nelse:\natoms.set_initial_magnetic_moments(\natoms.calc.results.get(\"magmoms\", [0.0] * len(atoms))\n)\n# Clear off the calculator so we can run a new job. If we don't do this,\n# then something like atoms *= (2,2,2) still has a calculator attached, which\n# is a bit confusing.\natoms.calc = None\n# Give the Atoms object a unique ID. This will be helpful for querying later.\n# Also store any old IDs somewhere else for future reference.\n# Note: Keep this at the end of the function so that the ID is assigned based\n# on the returned Atoms object.\nif assign_id:\nif atoms.info.get(\"_id\", None) is not None:\nif atoms.info.get(\"_old_ids\") is None:\natoms.info[\"_old_ids\"] = []\natoms.info[\"_old_ids\"].append(atoms.info[\"_id\"])\natoms.info[\"_id\"] = get_atoms_id(atoms)\nreturn atoms\n</code></pre>"},{"location":"reference/quacc/util/atoms.html#quacc.util.atoms.set_magmoms","title":"set_magmoms","text":"<pre><code>set_magmoms(atoms, elemental_mags_dict=None, elemental_mags_default=1.0, copy_magmoms=True, mag_cutoff=0.05)\n</code></pre> <p>Sets the initial magnetic moments in the Atoms object.</p> <p>This function deserves particular attention. The following logic is applied: - If there is a converged set of magnetic moments, those are moved to the initial magmoms if copy_magmoms is True. - If there is no converged set of magnetic moments but the user has set initial magmoms, those are simply used as is. - If there are no converged magnetic moments or initial magnetic moments, then the default magnetic moments from the preset elemental_mags_dict (if specified) are set as the initial magnetic moments. - For any of the above scenarios, if mag_cutoff is not None, the newly set initial magnetic moments are checked. If all have a magnitude below mag_cutoff, then they are all set to 0 (no spin polarization).</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> elemental_mags_dict             (<code>dict | None</code>)         \u2013          <p>Dictionary of elemental symbols and their corresponding magnetic moments to set. If None, no default values will be used.</p> </li> <li> elemental_mags_default             (<code>float</code>)         \u2013          <p>Default magnetic moment on an element if no magnetic moment is specified in the elemental_mags_dict. Only used if elemental_mags_dict is not None. This kwarg is mainly a convenience so that you don't need to list every single element in the elemental_mags_dict.</p> </li> <li> copy_magmoms             (<code>bool</code>)         \u2013          <p>Whether to copy the magnetic moments from the converged set of magnetic moments to the initial magnetic moments.</p> </li> <li> mag_cutoff             (<code>float | None</code>)         \u2013          <p>Magnitude below which the magnetic moments are considered to be zero. If None, no cutoff will be applied</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>         \u2013          <p>Atoms object</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/util/atoms.py</code> <pre><code>def set_magmoms(\natoms: Atoms,\nelemental_mags_dict: dict | None = None,\nelemental_mags_default: float = 1.0,\ncopy_magmoms: bool = True,\nmag_cutoff: float | None = 0.05,\n) -&gt; Atoms:\n\"\"\"\n    Sets the initial magnetic moments in the Atoms object.\n    This function deserves particular attention. The following logic is applied:\n    - If there is a converged set of magnetic moments, those are moved to the\n    initial magmoms if copy_magmoms is True.\n    - If there is no converged set of magnetic moments but the user has set initial magmoms,\n    those are simply used as is.\n    - If there are no converged magnetic moments or initial magnetic moments, then\n    the default magnetic moments from the preset elemental_mags_dict (if specified)\n    are set as the initial magnetic moments.\n    - For any of the above scenarios, if mag_cutoff is not None, the newly set\n    initial magnetic moments are checked. If all have a magnitude below mag_cutoff,\n    then they are all set to 0 (no spin polarization).\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    elemental_mags_dict\n        Dictionary of elemental symbols and their corresponding magnetic moments to set.\n        If None, no default values will be used.\n    elemental_mags_default\n        Default magnetic moment on an element if no magnetic moment is specified in the elemental_mags_dict.\n        Only used if elemental_mags_dict is not None. This kwarg is mainly a convenience so that you don't need to\n        list every single element in the elemental_mags_dict.\n    copy_magmoms\n        Whether to copy the magnetic moments from the converged set of magnetic moments to the initial magnetic moments.\n    mag_cutoff\n        Magnitude below which the magnetic moments are considered to be zero. If None, no cutoff will be applied\n    Returns\n    -------\n    Atoms\n        Atoms object\n    \"\"\"\n# Handle the magnetic moments\n# Check if a prior job was run and pull the prior magmoms\nif hasattr(atoms, \"calc\") and getattr(atoms.calc, \"results\", None) is not None:\nmags = atoms.calc.results.get(\"magmoms\", [0.0] * len(atoms))\n# Note: It is important that we set mags to 0.0 here rather than None if the\n# calculator has no magmoms because: 1) ispin=1 might be set, and 2) we do\n# not want the preset magmoms to be used.\nelse:\nmags = None\n# Check if the user has set any initial magmoms\nhas_initial_mags = atoms.has(\"initial_magmoms\")\n# If there are no initial magmoms set and this is not a follow-up job,\n# we may need to add some from the preset yaml.\nif mags is None:\nif not has_initial_mags:\n# If the preset dictionary has default magmoms, set\n# those by element. If the element isn't in the magmoms dict\n# then set it to mag_default.\nif elemental_mags_dict:\ninitial_mags = np.array(\n[\nelemental_mags_dict.get(atom.symbol, elemental_mags_default)\nfor atom in atoms\n]\n)\natoms.set_initial_magnetic_moments(initial_mags)\nelif copy_magmoms:\natoms.set_initial_magnetic_moments(mags)\n# If all the set mags are below mag_cutoff, set them to 0\nif mag_cutoff:\nhas_new_initial_mags = atoms.has(\"initial_magmoms\")\nnew_initial_mags = atoms.get_initial_magnetic_moments()\nif has_new_initial_mags and np.all(np.abs(new_initial_mags) &lt; mag_cutoff):\natoms.set_initial_magnetic_moments([0.0] * len(atoms))\nreturn atoms\n</code></pre>"},{"location":"reference/quacc/util/calc.html","title":"calc","text":"<p>Utility functions for running ASE calculators</p>"},{"location":"reference/quacc/util/calc.html#quacc.util.calc.run_ase_opt","title":"run_ase_opt","text":"<pre><code>run_ase_opt(atoms, fmax=0.01, max_steps=500, optimizer=FIRE, optimizer_kwargs=None, create_unique_workdir=None, scratch_dir=None, gzip=None, copy_files=None)\n</code></pre> <p>Run an ASE-based optimization in a scratch directory and copy the results back to the original directory. This can be useful if file I/O is slow in the working directory, so long as file transfer speeds are reasonable.</p> <p>This is a wrapper around the optimizers in ASE. Note: This function does not modify the atoms object in-place.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>The Atoms object to run the calculation on.</p> </li> <li> fmax             (<code>float</code>)         \u2013          <p>Tolerance for the force convergence (in eV/A).</p> </li> <li> max_steps             (<code>int</code>)         \u2013          <p>Maximum number of steps to take.</p> </li> <li> optimizer             (<code>Optimizer</code>)         \u2013          <p>Optimizer class to use.</p> </li> <li> optimizer_kwargs             (<code>dict | None</code>)         \u2013          <p>Dictionary of kwargs for the optimizer.</p> </li> <li> create_unique_workdir             (<code>bool | None</code>)         \u2013          <p>Whether to automatically create a unique working directory for each calculation. If None, defaults to SETTINGS.CREATE_UNIQUE_WORKDIR.</p> </li> <li> scratch_dir             (<code>str | None</code>)         \u2013          <p>Base path where a tmpdir should be made for running the calculation. If None, defaults to SETTINGS.SCRATCH_DIR.</p> </li> <li> gzip             (<code>bool | None</code>)         \u2013          <p>Whether to gzip the output files. If None, defaults to SETTINGS.GZIP_FILES.</p> </li> <li> copy_files             (<code>list[str] | None</code>)         \u2013          <p>Filenames to copy from source to scratch directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optimizer</code>         \u2013          <p>The ASE Optimizer object.</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/util/calc.py</code> <pre><code>def run_ase_opt(\natoms: Atoms,\nfmax: float = 0.01,\nmax_steps: int = 500,\noptimizer: Optimizer = FIRE,\noptimizer_kwargs: dict | None = None,\ncreate_unique_workdir: bool | None = None,\nscratch_dir: str | None = None,\ngzip: bool | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; Optimizer:\n\"\"\"\n    Run an ASE-based optimization in a scratch directory and copy the results\n    back to the original directory. This can be useful if file I/O is slow in\n    the working directory, so long as file transfer speeds are reasonable.\n    This is a wrapper around the optimizers in ASE. Note: This function does\n    not modify the atoms object in-place.\n    Parameters\n    ----------\n    atoms\n        The Atoms object to run the calculation on.\n    fmax\n        Tolerance for the force convergence (in eV/A).\n    max_steps\n        Maximum number of steps to take.\n    optimizer\n        Optimizer class to use.\n    optimizer_kwargs\n        Dictionary of kwargs for the optimizer.\n    create_unique_workdir\n        Whether to automatically create a unique working directory for each calculation.\n        If None, defaults to SETTINGS.CREATE_UNIQUE_WORKDIR.\n    scratch_dir\n        Base path where a tmpdir should be made for running the calculation.\n        If None, defaults to SETTINGS.SCRATCH_DIR.\n    gzip\n        Whether to gzip the output files.\n        If None, defaults to SETTINGS.GZIP_FILES.\n    copy_files\n        Filenames to copy from source to scratch directory.\n    Returns\n    -------\n    Optimizer\n        The ASE Optimizer object.\n    \"\"\"\n# Set defaults\noptimizer_kwargs = optimizer_kwargs or {}\ncreate_unique_workdir = (\nSETTINGS.CREATE_UNIQUE_WORKDIR\nif create_unique_workdir is None\nelse create_unique_workdir\n)\nscratch_dir = SETTINGS.SCRATCH_DIR if scratch_dir is None else scratch_dir\ngzip = SETTINGS.GZIP_FILES if gzip is None else gzip\nstart_dir = os.getcwd()\n# Perform staging operations\natoms, tmpdir, results_dir = _calc_setup(\natoms,\ncreate_unique_workdir=create_unique_workdir,\ncopy_files=copy_files,\nscratch_dir=scratch_dir,\n)\n# Set Sella kwargs\nif (\noptimizer.__name__ == \"Sella\"\nand not atoms.pbc.any()\nand \"internal\" not in optimizer_kwargs\n):\noptimizer_kwargs[\"internal\"] = True\n# Set up trajectory\nif \"trajectory\" in optimizer_kwargs:\nraise ValueError(\"Quacc does not support setting the `trajectory` kwarg.\")\ntraj_filename = \"opt.traj\"\noptimizer_kwargs[\"trajectory\"] = Trajectory(traj_filename, \"w\", atoms=atoms)\n# Define optimizer class\ndyn = optimizer(atoms, **optimizer_kwargs)\n# Run calculation\ndyn.run(fmax=fmax, steps=max_steps)\n# Store the trajectory atoms\ndyn.traj_atoms = read(traj_filename, index=\":\")\n# Perform cleanup operations\n_calc_cleanup(start_dir, tmpdir, results_dir, gzip=gzip)\nreturn dyn\n</code></pre>"},{"location":"reference/quacc/util/calc.html#quacc.util.calc.run_ase_vib","title":"run_ase_vib","text":"<pre><code>run_ase_vib(atoms, vib_kwargs=None, create_unique_workdir=None, scratch_dir=None, gzip=None, copy_files=None)\n</code></pre> <p>Run an ASE-based vibration analysis in a scratch directory and copy the results back to the original directory. This can be useful if file I/O is slow in the working directory, so long as file transfer speeds are reasonable.</p> <p>This is a wrapper around the vibrations module in ASE. Note: This function does not modify the atoms object in-place.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>The Atoms object to run the calculation on.</p> </li> <li> vib_kwargs             (<code>dict | None</code>)         \u2013          <p>Dictionary of kwargs for the vibration analysis.</p> </li> <li> create_unique_workdir             (<code>bool | None</code>)         \u2013          <p>Whether to automatically create a unique working directory for each calculation. If None, defaults to SETTINGS.CREATE_UNIQUE_WORKDIR.</p> </li> <li> scratch_dir             (<code>str | None</code>)         \u2013          <p>Base path where a tmpdir should be made for running the calculation. If None, defaults to SETTINGS.SCRATCH_DIR.</p> </li> <li> gzip             (<code>bool | None</code>)         \u2013          <p>Whether to gzip the output files. If None, defaults to SETTINGS.GZIP_FILES.</p> </li> <li> copy_files             (<code>list[str] | None</code>)         \u2013          <p>Filenames to copy from source to scratch directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Vibrations</code>         \u2013          <p>The updated Vibrations module</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/util/calc.py</code> <pre><code>def run_ase_vib(\natoms: Atoms,\nvib_kwargs: dict | None = None,\ncreate_unique_workdir: bool | None = None,\nscratch_dir: str | None = None,\ngzip: bool | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; Vibrations:\n\"\"\"\n    Run an ASE-based vibration analysis in a scratch directory and copy the results\n    back to the original directory. This can be useful if file I/O is slow in\n    the working directory, so long as file transfer speeds are reasonable.\n    This is a wrapper around the vibrations module in ASE. Note: This function does\n    not modify the atoms object in-place.\n    Parameters\n    ----------\n    atoms\n        The Atoms object to run the calculation on.\n    vib_kwargs\n        Dictionary of kwargs for the vibration analysis.\n    create_unique_workdir\n        Whether to automatically create a unique working directory for each calculation.\n        If None, defaults to SETTINGS.CREATE_UNIQUE_WORKDIR.\n    scratch_dir\n        Base path where a tmpdir should be made for running the calculation.\n        If None, defaults to SETTINGS.SCRATCH_DIR.\n    gzip\n        Whether to gzip the output files.\n        If None, defaults to SETTINGS.GZIP_FILES.\n    copy_files\n        Filenames to copy from source to scratch directory.\n    Returns\n    -------\n    Vibrations\n        The updated Vibrations module\n    \"\"\"\n# Set defaults\nvib_kwargs = vib_kwargs or {}\ncreate_unique_workdir = (\nSETTINGS.CREATE_UNIQUE_WORKDIR\nif create_unique_workdir is None\nelse create_unique_workdir\n)\nscratch_dir = SETTINGS.SCRATCH_DIR if scratch_dir is None else scratch_dir\ngzip = SETTINGS.GZIP_FILES if gzip is None else gzip\nstart_dir = os.getcwd()\n# Perform staging operations\natoms, tmpdir, results_dir = _calc_setup(\natoms,\ncreate_unique_workdir=create_unique_workdir,\ncopy_files=copy_files,\nscratch_dir=scratch_dir,\n)\n# Run calculation\nvib = Vibrations(atoms, name=\"vib\", **vib_kwargs)\nvib.run()\nvib.summary(log=\"vib_summary.log\")\n# Perform cleanup operations\n_calc_cleanup(start_dir, tmpdir, results_dir, gzip=gzip)\nreturn vib\n</code></pre>"},{"location":"reference/quacc/util/calc.html#quacc.util.calc.run_calc","title":"run_calc","text":"<pre><code>run_calc(atoms, geom_file=None, create_unique_workdir=None, scratch_dir=None, gzip=None, copy_files=None)\n</code></pre> <p>Run a calculation in a scratch directory and copy the results back to the original directory. This can be useful if file I/O is slow in the working directory, so long as file transfer speeds are reasonable.</p> <p>This is a wrapper around atoms.get_potential_energy(). Note: This function does not modify the atoms object in-place.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>The Atoms object to run the calculation on.</p> </li> <li> geom_file             (<code>str | None</code>)         \u2013          <p>The filename of the log file that contains the output geometry, used to update the atoms object's positions and cell after a job. It is better to specify this rather than relying on ASE's atoms.get_potential_energy() function to update the positions, as this varies between codes.</p> </li> <li> create_unique_workdir             (<code>bool | None</code>)         \u2013          <p>Whether to automatically create a unique working directory for each calculation. If None, defaults to SETTINGS.CREATE_UNIQUE_WORKDIR.</p> </li> <li> scratch_dir             (<code>str | None</code>)         \u2013          <p>Base path where a tmpdir should be made for running the calculation. If None, defaults to SETTINGS.SCRATCH_DIR.</p> </li> <li> gzip             (<code>bool | None</code>)         \u2013          <p>Whether to gzip the output files. If None, defaults to SETTINGS.GZIP_FILES.</p> </li> <li> copy_files             (<code>list[str] | None</code>)         \u2013          <p>Filenames to copy from source to scratch directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>         \u2013          <p>The updated Atoms object.</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/util/calc.py</code> <pre><code>def run_calc(\natoms: Atoms,\ngeom_file: str | None = None,\ncreate_unique_workdir: bool | None = None,\nscratch_dir: str | None = None,\ngzip: bool | None = None,\ncopy_files: list[str] | None = None,\n) -&gt; Atoms:\n\"\"\"\n    Run a calculation in a scratch directory and copy the results back to the\n    original directory. This can be useful if file I/O is slow in the working\n    directory, so long as file transfer speeds are reasonable.\n    This is a wrapper around atoms.get_potential_energy(). Note: This\n    function does not modify the atoms object in-place.\n    Parameters\n    ----------\n    atoms\n        The Atoms object to run the calculation on.\n    geom_file\n        The filename of the log file that contains the output geometry, used\n        to update the atoms object's positions and cell after a job. It is better\n        to specify this rather than relying on ASE's atoms.get_potential_energy()\n        function to update the positions, as this varies between codes.\n    create_unique_workdir\n        Whether to automatically create a unique working directory for each calculation.\n        If None, defaults to SETTINGS.CREATE_UNIQUE_WORKDIR.\n    scratch_dir\n        Base path where a tmpdir should be made for running the calculation.\n        If None, defaults to SETTINGS.SCRATCH_DIR.\n    gzip\n        Whether to gzip the output files.\n        If None, defaults to SETTINGS.GZIP_FILES.\n    copy_files\n        Filenames to copy from source to scratch directory.\n    Returns\n    -------\n    Atoms\n        The updated Atoms object.\n    \"\"\"\n# Set defaults\ncreate_unique_workdir = (\nSETTINGS.CREATE_UNIQUE_WORKDIR\nif create_unique_workdir is None\nelse create_unique_workdir\n)\nscratch_dir = SETTINGS.SCRATCH_DIR if scratch_dir is None else scratch_dir\ngzip = SETTINGS.GZIP_FILES if gzip is None else gzip\n# Perform staging operations\nstart_dir = os.getcwd()\natoms, tmpdir, results_dir = _calc_setup(\natoms,\ncreate_unique_workdir=create_unique_workdir,\ncopy_files=copy_files,\nscratch_dir=scratch_dir,\n)\n# Run calculation via get_potential_energy()\natoms.get_potential_energy()\n# Perform cleanup operations\n_calc_cleanup(start_dir, tmpdir, results_dir, gzip=gzip)\n# Most ASE calculators do not update the atoms object in-place with\n# a call to .get_potential_energy(), which is important if an internal\n# optimizer is used. This section is done to ensure that the atoms object\n# is updated with the correct positions and cell if a `geom_file` is provided.\nif geom_file:\n# Note: We have to be careful to make sure we don't lose the\n# converged magnetic moments, if present. That's why we simply\n# update the positions and cell in-place.\natoms_new = read(os.path.join(results_dir, zpath(geom_file)))\nif isinstance(atoms_new, list):\natoms_new = atoms_new[-1]\n# Make sure the atom indices didn't get updated somehow (sanity check). If this\n# happens, there is a serious problem.\nif (\nnp.array_equal(atoms_new.get_atomic_numbers(), atoms.get_atomic_numbers())\nis False\n):\nraise ValueError(\"Atomic numbers do not match between atoms and geom_file.\")\natoms.positions = atoms_new.positions\natoms.cell = atoms_new.cell\nreturn atoms\n</code></pre>"},{"location":"reference/quacc/util/db.html","title":"db","text":"<p>Utility functions for interfacing with databases</p>"},{"location":"reference/quacc/util/db.html#quacc.util.db.covalent_to_db","title":"covalent_to_db","text":"<pre><code>covalent_to_db(store, dispatch_ids=None, results_dir=None)\n</code></pre> <p>Store the results of a Covalent database in a user-specified Maggma Store</p> <p>Parameters:</p> <ul> <li> store             (<code>Store</code>)         \u2013          <p>The Maggma Store object to store the results in</p> </li> <li> dispatch_ids             (<code>list[str] | None</code>)         \u2013          <p>Dispatch ID to store. If None, all dispatch IDs in the results_dir will be stored</p> </li> <li> results_dir             (<code>str | None</code>)         \u2013          <p>The Covalent results_dir to pull if dispatch_ID is None. If None, the results_dir from ct.get_config() will be used</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/util/db.py</code> <pre><code>def covalent_to_db(\nstore: Store, dispatch_ids: list[str] | None = None, results_dir: str | None = None\n) -&gt; None:\n\"\"\"\n    Store the results of a Covalent database in a user-specified Maggma Store\n    Parameters\n    ----------\n    store\n        The Maggma Store object to store the results in\n    dispatch_ids\n        Dispatch ID to store. If None, all dispatch IDs in the results_dir will be stored\n    results_dir\n        The Covalent results_dir to pull if dispatch_ID is None. If None, the results_dir from ct.get_config() will be used\n    Returns\n    -------\n    None\n    \"\"\"\nif dispatch_ids and results_dir:\nraise ValueError(\"Cannot specify both dispatch_id and results_dir\")\ndispatch_ids = dispatch_ids or []\n# Get the dispatch IDs\nif not dispatch_ids:\nif results_dir:\ndispatch_ids = os.listdir(results_dir)\nelse:\nconfig_results_dir = ct.get_config()[\"dispatcher\"][\"results_dir\"]\ndispatch_ids = os.listdir(config_results_dir)\n# Populate the docs\ndocs = []\nfor d_id in dispatch_ids:\ntry:\nresult_obj = ct.get_result(d_id)\nexcept MissingLatticeRecordError:\nwarnings.warn(f\"Could not find dispatch_id: {d_id}\", UserWarning)\ncontinue\nif result_obj and result_obj.status == \"COMPLETED\":\ndocs.append({\"dispatch_id\": d_id, \"result\": result_obj.result})\n# Store the results\nif docs:\nstore.connect()\nwith store:\nstore.update(docs, key=\"dispatch_id\")\nprint(f\"Stored {len(docs)} results in your database.\")\nstore.close()\n</code></pre>"},{"location":"reference/quacc/util/db.html#quacc.util.db.results_to_db","title":"results_to_db","text":"<pre><code>results_to_db(store, results)\n</code></pre> <p>Store the results of a quacc recipe in a user-specified Maggma Store. A UUID will be generated for each entry.</p> <p>Parameters:</p> <ul> <li> results             (<code>dict | list[dict]</code>)         \u2013          <p>The output summary dictionary or list of dictionaries from a quacc recipe</p> </li> <li> store             (<code>Store</code>)         \u2013          <p>The Maggma Store object to store the results in</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/util/db.py</code> <pre><code>def results_to_db(store: Store, results: dict | list[dict]) -&gt; None:\n\"\"\"\n    Store the results of a quacc recipe in a user-specified Maggma Store.\n    A UUID will be generated for each entry.\n    Parameters\n    ----------\n    results\n        The output summary dictionary or list of dictionaries from a quacc recipe\n    store\n        The Maggma Store object to store the results in\n    Returns\n    -------\n    None\n    \"\"\"\nif isinstance(results, dict):\nresults = [results]\nfor result in results:\nresult[\"uuid\"] = str(uuid.uuid4())\nstore.connect()\nwith store:\nstore.update(results, key=\"uuid\")\nprint(f\"Stored {len(results)} results in your database.\")\nstore.close()\n</code></pre>"},{"location":"reference/quacc/util/dicts.html","title":"dicts","text":"<p>Utility functions for dealing with dictionaries</p>"},{"location":"reference/quacc/util/dicts.html#quacc.util.dicts.clean_dict","title":"clean_dict","text":"<pre><code>clean_dict(start_dict, remove_empties=False)\n</code></pre> <p>For a given dictionary, recursively remove all items that are None or are empty lists/dicts, and then sort all entries alphabetically by key.</p> <p>Parameters:</p> <ul> <li> start_dict             (<code>dict</code>)         \u2013          <p>Dictionary to clean</p> </li> <li> remove_empties             (<code>bool</code>)         \u2013          <p>If True, remove empty lists and dictionaries</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Cleaned and sorted dictionary</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/util/dicts.py</code> <pre><code>def clean_dict(start_dict: dict, remove_empties: bool = False) -&gt; dict:\n\"\"\"\n    For a given dictionary, recursively remove all items that are None\n    or are empty lists/dicts, and then sort all entries alphabetically by key.\n    Parameters\n    ----------\n    start_dict\n        Dictionary to clean\n    remove_empties\n        If True, remove empty lists and dictionaries\n    Returns\n    -------\n    dict\n        Cleaned and sorted dictionary\n    \"\"\"\nif remove_empties:\nstart_dict = remove_dict_empties(start_dict)\nreturn sort_dict(start_dict)\n</code></pre>"},{"location":"reference/quacc/util/dicts.html#quacc.util.dicts.remove_dict_empties","title":"remove_dict_empties","text":"<pre><code>remove_dict_empties(start_dict)\n</code></pre> <p>For a given dictionary, recursively remove all items that are None or are empty lists/dicts.</p> <p>Parameters:</p> <ul> <li> start_dict             (<code>dict</code>)         \u2013          <p>Dictionary to clean</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Cleaned dictionary</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/util/dicts.py</code> <pre><code>def remove_dict_empties(start_dict: dict) -&gt; dict:\n\"\"\"\n    For a given dictionary, recursively remove all items that are None\n    or are empty lists/dicts.\n    Parameters\n    ----------\n    start_dict\n        Dictionary to clean\n    Returns\n    -------\n    dict\n        Cleaned dictionary\n    \"\"\"\nif isinstance(start_dict, dict):\nreturn {\nk: remove_dict_empties(v)\nfor k, v in start_dict.items()\nif v is not None and (not isinstance(v, (dict, list)) or len(v) != 0)\n}\nreturn (\n[remove_dict_empties(v) for v in start_dict]\nif isinstance(start_dict, list)\nelse start_dict\n)\n</code></pre>"},{"location":"reference/quacc/util/dicts.html#quacc.util.dicts.sort_dict","title":"sort_dict","text":"<pre><code>sort_dict(start_dict)\n</code></pre> <p>For a given dictionary, recursively sort all entries alphabetically by key.</p> <p>Parameters:</p> <ul> <li> start_dict             (<code>dict</code>)         \u2013          <p>Dictionary to sort</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Sorted dictionary</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/util/dicts.py</code> <pre><code>def sort_dict(start_dict: dict) -&gt; dict:\n\"\"\"\n    For a given dictionary, recursively sort all entries alphabetically by key.\n    Parameters\n    ----------\n    start_dict\n        Dictionary to sort\n    Returns\n    -------\n    dict\n        Sorted dictionary\n    \"\"\"\nreturn {\nk: sort_dict(v) if isinstance(v, dict) else v\nfor k, v in sorted(start_dict.items())\n}\n</code></pre>"},{"location":"reference/quacc/util/files.html","title":"files","text":"<p>Utility functions for file and path handling</p>"},{"location":"reference/quacc/util/files.html#quacc.util.files.check_logfile","title":"check_logfile","text":"<pre><code>check_logfile(logfile, check_str)\n</code></pre> <p>Check if a logfile has a given string (case-insensitive).</p> <p>Parameters:</p> <ul> <li> logfile             (<code>str</code>)         \u2013          <p>Path to the logfile.</p> </li> <li> check_str             (<code>str</code>)         \u2013          <p>String to check for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True if the string is found in the logfile, False otherwise.</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/util/files.py</code> <pre><code>def check_logfile(logfile: str, check_str: str) -&gt; bool:\n\"\"\"\n    Check if a logfile has a given string (case-insensitive).\n    Parameters\n    ----------\n    logfile : str\n        Path to the logfile.\n    check_str : str\n        String to check for.\n    Returns\n    -------\n    bool\n        True if the string is found in the logfile, False otherwise.\n    \"\"\"\nzlog = zpath(logfile)\nwith zopen(zlog, \"r\") as f:\nfor line in f:\nif not isinstance(line, str):\nline = line.decode(\"utf-8\")\nif check_str.lower() in line.lower():\nreturn True\nreturn False\n</code></pre>"},{"location":"reference/quacc/util/files.html#quacc.util.files.copy_decompress","title":"copy_decompress","text":"<pre><code>copy_decompress(source_files, destination)\n</code></pre> <p>Copy and decompress files from source to destination.</p> <p>Parameters:</p> <ul> <li> source_files             (<code>list[str]</code>)         \u2013          <p>List of files to copy and decompress.</p> </li> <li> destination             (<code>str</code>)         \u2013          <p>Destination directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/util/files.py</code> <pre><code>def copy_decompress(source_files: list[str], destination: str) -&gt; None:\n\"\"\"\n    Copy and decompress files from source to destination.\n    Parameters\n    ----------\n    source_files\n        List of files to copy and decompress.\n    destination\n        Destination directory.\n    Returns\n    -------\n    None\n    \"\"\"\nfor f in source_files:\nz_path = zpath(f)\nif os.path.exists(z_path):\nz_file = os.path.basename(z_path)\ncopy(z_path, os.path.join(destination, z_file))\ndecompress_file(os.path.join(destination, z_file))\n</code></pre>"},{"location":"reference/quacc/util/files.html#quacc.util.files.load_yaml_calc","title":"load_yaml_calc","text":"<pre><code>load_yaml_calc(yaml_path)\n</code></pre> <p>Loads a YAML file containing ASE VASP calcultor settings.</p> <p>Parameters:</p> <ul> <li> yaml_path             (<code>str</code>)         \u2013          <p>Path to the YAML file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>The calculator configuration (i.e. settings).</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/util/files.py</code> <pre><code>def load_yaml_calc(yaml_path: str) -&gt; dict:\n\"\"\"\n    Loads a YAML file containing ASE VASP calcultor settings.\n    Parameters\n    ----------\n    yaml_path\n        Path to the YAML file.\n    Returns\n    -------\n    dict\n        The calculator configuration (i.e. settings).\n    \"\"\"\n_, ext = os.path.splitext(yaml_path)\nif not ext:\nyaml_path += \".yaml\"\nif not os.path.exists(yaml_path):\nraise ValueError(f\"Cannot find {yaml_path}.\")\n# Load YAML file\nwith open(yaml_path, \"r\") as stream:\nconfig = yaml.safe_load(stream)\n# Inherit arguments from any parent YAML files\n# but do not overwrite those in the child file.\nfor config_arg in config.copy():\nif \"parent\" in config_arg:\nparent_config = load_yaml_calc(\nos.path.join(os.path.dirname(yaml_path), config[config_arg])\n)\nfor k, v in parent_config.items():\nif k not in config:\nconfig[k] = v\nelse:\nv_new = parent_config.get(k, {})\nfor kk, vv in v_new.items():\nif kk not in config[k]:\nconfig[k][kk] = vv\n# Allow for either \"Cu_pv\" and \"_pv\" style setups\nfor k, v in config[\"inputs\"].get(\"setups\", {}).items():\nif k in v:\nconfig[\"inputs\"][\"setups\"][k] = v.split(k)[-1]\nreturn config\n</code></pre>"},{"location":"reference/quacc/util/files.html#quacc.util.files.make_unique_dir","title":"make_unique_dir","text":"<pre><code>make_unique_dir(base_path=None)\n</code></pre> <p>Make a directory with a unique name. Uses the same format as Jobflow.</p> <p>Parameters:</p> <ul> <li> base_path             (<code>str | None</code>)         \u2013          <p>Path to the base directory. If None, the current working directory is used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>Path to the job directory.</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/util/files.py</code> <pre><code>def make_unique_dir(base_path: str | None = None) -&gt; str:\n\"\"\"\n    Make a directory with a unique name. Uses the same format as Jobflow.\n    Parameters\n    ----------\n    base_path\n        Path to the base directory. If None, the current working directory is used.\n    Returns\n    -------\n    str\n        Path to the job directory.\n    \"\"\"\nif base_path is None:\nbase_path = os.getcwd()\nif not os.path.exists(base_path):\nos.mkdir(base_path)\ntime_now = datetime.utcnow().strftime(\"%Y-%m-%d-%H-%M-%S-%f\")\njob_dir = os.path.join(base_path, f\"quacc_{time_now}-{randint(10000, 99999)}\")\nos.mkdir(job_dir)\nreturn job_dir\n</code></pre>"},{"location":"reference/quacc/util/pop_analysis.html","title":"pop_analysis","text":"<p>Utility functions for population analyses</p>"},{"location":"reference/quacc/util/pop_analysis.html#quacc.util.pop_analysis.bader_runner","title":"bader_runner","text":"<pre><code>bader_runner(path=None, scratch_dir=None)\n</code></pre> <p>Runs a Bader partial charge and spin moment analysis using the VASP output files in the given path. This function requires that <code>bader</code> is located in your PATH environment variable. See http://theory.cm.utexas.edu/henkelman/code/bader for the bader code. Note: If you want to use Bader on a code other than VASP, this function will need to be slightly modified.</p> <p>Parameters:</p> <ul> <li> path             (<code>str | None</code>)         \u2013          <p>The path where the VASP output files are located. Must include CHGCAR, AECCAR0, AECCAR2, and POTCAR files. These files can be gzip'd or not -- it doesn't matter. If None, the current working directory is used.</p> </li> <li> scratch_dir             (<code>str | None</code>)         \u2013          <p>The path where the Bader analysis will be run. Defaults to SETTINGS.SCRATCH_DIR.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary containing the Bader analysis summary: { \"min_dist\": List[float], \"atomic_volume\": List[float], \"vacuum_charge\": float, \"vacuum_volume\": float, \"bader_version\": float, \"partial_charges\": List[float], \"spin_moments\": List[float], }</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/util/pop_analysis.py</code> <pre><code>def bader_runner(path: str | None = None, scratch_dir: str | None = None) -&gt; dict:\n\"\"\"\n    Runs a Bader partial charge and spin moment analysis using the VASP\n    output files in the given path. This function requires that `bader`\n    is located in your PATH environment variable. See\n    http://theory.cm.utexas.edu/henkelman/code/bader for the bader code.\n    Note: If you want to use Bader on a code other than VASP, this function\n    will need to be slightly modified.\n    Parameters\n    ----------\n    path\n        The path where the VASP output files are located.\n        Must include CHGCAR, AECCAR0, AECCAR2, and POTCAR files. These\n        files can be gzip'd or not -- it doesn't matter.\n        If None, the current working directory is used.\n    scratch_dir\n        The path where the Bader analysis will be run.\n        Defaults to SETTINGS.SCRATCH_DIR.\n    Returns\n    -------\n    dict\n        Dictionary containing the Bader analysis summary:\n            {\n                \"min_dist\": List[float],\n                \"atomic_volume\": List[float],\n                \"vacuum_charge\": float,\n                \"vacuum_volume\": float,\n                \"bader_version\": float,\n                \"partial_charges\": List[float],\n                \"spin_moments\": List[float],\n            }\n    \"\"\"\nscratch_dir = SETTINGS.SCRATCH_DIR if scratch_dir is None else scratch_dir\npath = path or os.getcwd()\nscratch_dir = scratch_dir or os.getcwd()\n# Make sure files are present\nrelevant_files = [\"AECCAR0\", \"AECCAR2\", \"CHGCAR\", \"POTCAR\"]\nfor f in relevant_files:\nif not os.path.exists(os.path.join(path, f)) and not os.path.exists(\nos.path.join(path, f\"{f}.gz\")\n):\nraise FileNotFoundError(f\"Could not find {f} in {path}.\")\n# Run Bader analysis\nwith TemporaryDirectory(dir=scratch_dir) as tmpdir:\ncopy_decompress(relevant_files, tmpdir)\nbader_stats = bader_analysis_from_path(path)\n# Store the partial charge, which is much more useful than the\n# raw charge and is more intuitive than the charge transferred.\n# An atom with a positive partial charge is cationic, whereas\n# an atom with a negative partial charge is anionic.\nbader_stats[\"partial_charges\"] = [-c for c in bader_stats[\"charge_transfer\"]]\n# Some cleanup of the returned dictionary\nif \"magmom\" in bader_stats:\nbader_stats[\"spin_moments\"] = bader_stats[\"magmom\"]\nbader_stats.pop(\"charge\", None)\nbader_stats.pop(\"charge_transfer\", None)\nbader_stats.pop(\"reference_used\", None)\nbader_stats.pop(\"magmom\", None)\nreturn bader_stats\n</code></pre>"},{"location":"reference/quacc/util/pop_analysis.html#quacc.util.pop_analysis.chargemol_runner","title":"chargemol_runner","text":"<pre><code>chargemol_runner(path=None, atomic_densities_path=None, scratch_dir=SETTINGS.SCRATCH_DIR)\n</code></pre> <p>Runs a Chargemol (i.e. DDEC6 + CM5) analysis using the VASP output files in the given path. This function requires that the chargemol executable, given by the name <code>Chargemol_09_26_2017_linux_parallel</code>, <code>Chargemol_09_26_2017_linux_serial</code>, or <code>chargemol</code> is in the system PATH environment variable. See https://sourceforge.net/projects/ddec/files for the Chargemol code. Note: If you want to use Chargemol on a code other than VASP, this function will need to be slightly modified.</p> <p>Parameters:</p> <ul> <li> path             (<code>str | None</code>)         \u2013          <p>The path where the VASP output files are located. Must include CHGCAR, AECCAR0, AECCAR2, and POTCAR files. These files can be gzip'd or not -- it doesn't matter. If None, the current working directory is used.</p> </li> <li> atomic_densities_path             (<code>str | None</code>)         \u2013          <p>The path where the reference atomic densities are located for Chargemol. If None, we assume that this directory is defined in an environment variable named DDEC6_ATOMIC_DENSITIES_DIR. See the Chargemol documentation for more information.</p> </li> <li> scratch_dir             (<code>str</code>)         \u2013          <p>The path where the Chargemol analysis will be run.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary containing the Chargemol analysis summary: { \"ddec\": { \"partial_charges\": List[float], \"spin_moments\": List[float], \"dipoles\": List[float], \"bond_order_sums\": List[float], \"bond_order_dict\": Dict }, \"cm5\": { \"partial_charges\": List[float], } }</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/util/pop_analysis.py</code> <pre><code>def chargemol_runner(\npath: str | None = None,\natomic_densities_path: str | None = None,\nscratch_dir: str = SETTINGS.SCRATCH_DIR,\n) -&gt; dict:\n\"\"\"\n    Runs a Chargemol (i.e. DDEC6 + CM5) analysis using the VASP output files\n    in the given path. This function requires that the chargemol executable,\n    given by the name `Chargemol_09_26_2017_linux_parallel`,\n    `Chargemol_09_26_2017_linux_serial`, or `chargemol` is in the system PATH\n    environment variable. See https://sourceforge.net/projects/ddec/files for\n    the Chargemol code. Note: If you want to use Chargemol on a code other\n    than VASP, this function will need to be slightly modified.\n    Parameters\n    ----------\n    path\n        The path where the VASP output files are located.\n        Must include CHGCAR, AECCAR0, AECCAR2, and POTCAR files. These\n        files can be gzip'd or not -- it doesn't matter.\n        If None, the current working directory is used.\n    atomic_densities_path\n        The path where the reference atomic densities are located for Chargemol.\n        If None, we assume that this directory is defined in an environment variable\n        named DDEC6_ATOMIC_DENSITIES_DIR.\n        See the Chargemol documentation for more information.\n    scratch_dir\n        The path where the Chargemol analysis will be run.\n    Returns\n    -------\n    dict\n        Dictionary containing the Chargemol analysis summary:\n            {\n                \"ddec\": {\n                            \"partial_charges\": List[float],\n                            \"spin_moments\": List[float],\n                            \"dipoles\": List[float],\n                            \"bond_order_sums\": List[float],\n                            \"bond_order_dict\": Dict\n                        },\n                \"cm5\": {\n                            \"partial_charges\": List[float],\n                        }\n            }\n    \"\"\"\npath = path or os.getcwd()\nscratch_dir = scratch_dir or path\n# Make sure files are present\nrelevant_files = [\"AECCAR0\", \"AECCAR2\", \"CHGCAR\", \"POTCAR\"]\nfor f in relevant_files:\nif not os.path.exists(os.path.join(path, f)) and not os.path.exists(\nos.path.join(path, f\"{f}.gz\")\n):\nraise FileNotFoundError(f\"Could not find {f} in {path}.\")\n# Check environment variable\nif atomic_densities_path is None and \"DDEC6_ATOMIC_DENSITIES_DIR\" not in os.environ:\nraise ValueError(\"DDEC6_ATOMIC_DENSITIES_DIR environment variable not defined.\")\n# Run Chargemol analysis\nwith TemporaryDirectory(dir=scratch_dir) as tmpdir:\ncopy_decompress(relevant_files, tmpdir)\nchargemol_stats = ChargemolAnalysis(\npath=path,\natomic_densities_path=atomic_densities_path,\n)\n# Some cleanup of the returned dictionary\nchargemol_stats.pop(\"rsquared_moments\", None)\nchargemol_stats.pop(\"rcubed_moments\", None)\nchargemol_stats.pop(\"rfourth_moments\", None)\nreturn chargemol_stats\n</code></pre>"},{"location":"reference/quacc/util/slabs.html","title":"slabs","text":"<p>Utility functions for dealing with slabs</p>"},{"location":"reference/quacc/util/slabs.html#quacc.util.slabs.flip_atoms","title":"flip_atoms","text":"<pre><code>flip_atoms(atoms, return_struct=False)\n</code></pre> <p>Convenience function for vertically flipping periodic atoms or structures</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms | Structure | Slab</code>)         \u2013          <p>Atoms/.Structure to flip</p> </li> <li> return_struct             (<code>bool</code>)         \u2013          <p>True if a Pymatgen structure object should be returned. False if an ASE atoms object should be returned</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms | Structure | Slab</code>         \u2013          <p>Inverted slab</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/util/slabs.py</code> <pre><code>def flip_atoms(\natoms: Atoms | Structure | Slab, return_struct: bool = False\n) -&gt; Atoms | Structure | Slab:\n\"\"\"\n    Convenience function for vertically flipping periodic atoms or structures\n    Parameters\n    ----------\n    atoms\n        Atoms/.Structure to flip\n    return_struct\n        True if a Pymatgen structure object should be returned.\n        False if an ASE atoms object should be returned\n    Returns\n    -------\n    Atoms | Structure | Slab\n        Inverted slab\n    \"\"\"\nif isinstance(atoms, Atoms):\nnew_atoms = copy_atoms(atoms)\natoms_info = atoms.info.copy()\nelse:\nnew_atoms = AseAtomsAdaptor.get_atoms(atoms)\natoms_info = {}\nnew_atoms.rotate(180, \"x\")\nnew_atoms.wrap()\nnew_atoms.info = atoms_info\nif return_struct:\nnew_atoms = AseAtomsAdaptor.get_structure(new_atoms)\nreturn new_atoms\n</code></pre>"},{"location":"reference/quacc/util/slabs.html#quacc.util.slabs.get_surface_energy","title":"get_surface_energy","text":"<pre><code>get_surface_energy(bulk, slab, bulk_energy, slab_energy)\n</code></pre> <p>Calculate the surface energy to form a given surface slab from a bulk structure. For asymmetric slabs, this is better thought of as the cleavage energy.</p> <p>Parameters:</p> <ul> <li> bulk             (<code>Atoms</code>)         \u2013          <p>The bulk structure.</p> </li> <li> slab             (<code>Atoms</code>)         \u2013          <p>The slab structure.</p> </li> <li> bulk_energy             (<code>float</code>)         \u2013          <p>The total energy of the bulk structure.</p> </li> <li> slab_energy             (<code>float</code>)         \u2013          <p>The total energy of the slab structure.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>         \u2013          <p>The surface energy in eV/A^2.</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/util/slabs.py</code> <pre><code>def get_surface_energy(\nbulk: Atoms, slab: Atoms, bulk_energy: float, slab_energy: float\n) -&gt; float:\n\"\"\"\n    Calculate the surface energy to form a given surface slab from a bulk structure.\n    For asymmetric slabs, this is better thought of as the cleavage energy.\n    Parameters\n    -----------\n    bulk\n        The bulk structure.\n    slab\n        The slab structure.\n    bulk_energy\n        The total energy of the bulk structure.\n    slab_energy\n        The total energy of the slab structure.\n    Returns\n    -------\n    float\n        The surface energy in eV/A^2.\n    \"\"\"\nalpha = len(slab) / len(bulk)\ncell = slab.get_cell()\nA = np.linalg.norm(np.cross(cell[0], cell[1]))\nreturn (slab_energy - alpha * bulk_energy) / (2 * A)\n</code></pre>"},{"location":"reference/quacc/util/slabs.html#quacc.util.slabs.make_adsorbate_structures","title":"make_adsorbate_structures","text":"<pre><code>make_adsorbate_structures(atoms, adsorbate, min_distance=2.0, modes=None, allowed_surface_symbols=None, allowed_surface_indices=None, ads_site_finder_kwargs=None, find_ads_sites_kwargs=None)\n</code></pre> <p>Add a single adsorbate to a structure for every requested adsorption mode</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>The atoms to add adsorbates to.</p> </li> <li> adsorbate             (<code>Atoms</code>)         \u2013          <p>The adsorbate to add. Note: It will be placed on the surface in the exact input orientation provided by the user (the adsorption mode is along the c axis and the coordinating atom is the one in the -z direction).</p> </li> <li> min_distance             (<code>float</code>)         \u2013          <p>The (minimum) distance to set between the adsorbate and the surface site.</p> </li> <li> modes             (<code>list[str] | None</code>)         \u2013          <p>The adsorption mode(s) to consider. Options include: \"ontop\", \"bridge\", \"hollow\", \"subsurface\".</p> </li> <li> allowed_surface_symbols             (<code>list[str] | None</code>)         \u2013          <p>The symbols of surface atoms to consider. If None, will use all surface atoms. Note: This method could be improved for bridge/hollow sites.</p> </li> <li> allowed_surface_indices             (<code>list[int] | None</code>)         \u2013          <p>The indices of surface atoms to consider. If None, will use all surface atoms. Generally used if a specific site is to be excluded from the set. Note: This method could be improved for bridge/hollow sites.</p> </li> <li> ads_site_finder_kwargs             (<code>dict | None</code>)         \u2013          <p>The keyword arguments to pass to the AdsorbateSiteFinder().</p> </li> <li> find_ads_sites_kwargs             (<code>dict | None</code>)         \u2013          <p>The keyword arguments to pass to AdsorbateSiteFinder.find_adsorption_sites().</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Atoms]</code>         \u2013          <p>The structures with adsorbates</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/util/slabs.py</code> <pre><code>def make_adsorbate_structures(\natoms: Atoms,\nadsorbate: Atoms,\nmin_distance: float = 2.0,\nmodes: list[str] | None = None,\nallowed_surface_symbols: list[str] | None = None,\nallowed_surface_indices: list[int] | None = None,\nads_site_finder_kwargs: dict | None = None,\nfind_ads_sites_kwargs: dict | None = None,\n) -&gt; list[Atoms]:\n\"\"\"\n    Add a single adsorbate to a structure for every requested adsorption mode\n    Parameters\n    ----------\n    atoms\n        The atoms to add adsorbates to.\n    adsorbate\n        The adsorbate to add.\n        Note: It will be placed on the surface in the exact input orientation provided by the user (the adsorption mode is\n        along the c axis and the coordinating atom is the one in the -z direction).\n    min_distance\n        The (minimum) distance to set between the adsorbate and the surface site.\n    modes\n        The adsorption mode(s) to consider. Options include: \"ontop\", \"bridge\", \"hollow\", \"subsurface\".\n    allowed_surface_symbols\n        The symbols of surface atoms to consider. If None, will use all surface atoms.\n        Note: This method could be improved for bridge/hollow sites.\n    allowed_surface_indices\n        The indices of surface atoms to consider. If None, will use all surface atoms. Generally used if a specific site is to be excluded from the set.\n        Note: This method could be improved for bridge/hollow sites.\n    ads_site_finder_kwargs\n        The keyword arguments to pass to the AdsorbateSiteFinder().\n    find_ads_sites_kwargs\n        The keyword arguments to pass to AdsorbateSiteFinder.find_adsorption_sites().\n    Returns\n    --------\n    list[Atoms]\n        The structures with adsorbates\n    \"\"\"\natoms = copy_atoms(atoms)\nif modes is None:\nmodes = [\"ontop\", \"bridge\", \"hollow\"]\nads_site_finder_kwargs = ads_site_finder_kwargs or {}\nfind_ads_sites_kwargs = find_ads_sites_kwargs or {}\n# Check for double-used parameters\nif min_distance and \"distance\" in find_ads_sites_kwargs:\nraise ValueError(\n\"Cannot specify both min_distance and find_ads_sites_kwargs['distance']\",\n)\nif modes and \"positions\" in find_ads_sites_kwargs:\nraise ValueError(\n\"Cannot specify both modes and find_ads_sites_kwargs['positions']\",\n)\nfind_ads_sites_kwargs[\"distance\"] = min_distance\nfind_ads_sites_kwargs[\"positions\"] = [mode.lower() for mode in modes]\n# Check the provided surface indices are reasonable\natom_indices = [atom.index for atom in atoms]\nif allowed_surface_indices and any(\nidx not in atom_indices for idx in allowed_surface_indices\n):\nraise ValueError(\n\"All indices in allowed_surface_indices must be in atoms.\",\nallowed_surface_indices,\natom_indices,\n)\n# Add 0.0 initial magmoms to atoms/adsorbate if needed\nif atoms.has(\"initial_magmoms\") and not adsorbate.has(\"initial_magmoms\"):\nadsorbate.set_initial_magnetic_moments([0.0] * len(adsorbate))\nif adsorbate.has(\"initial_magmoms\") and not atoms.has(\"initial_magmoms\"):\natoms.set_initial_magnetic_moments([0.0] * len(atoms))\n# Make a Pymatgen structure and molecule\nstruct = AseAtomsAdaptor.get_structure(atoms)\nmol = AseAtomsAdaptor.get_molecule(adsorbate, charge_spin_check=False)\n# Get the adsorption sites\nads_finder = AdsorbateSiteFinder(struct, **ads_site_finder_kwargs)\nads_sites = ads_finder.find_adsorption_sites(**find_ads_sites_kwargs)\n# Find and add the adsorbates\nnew_atoms = []\nfor mode, ads_coords in ads_sites.items():\n# Check if mode is in desired list\nif mode not in modes:\ncontinue\nfor ads_coord in ads_coords:\n# Place adsorbate\nstruct_with_adsorbate = ads_finder.add_adsorbate(mol, ads_coord)\n# Convert back to Atoms object\natoms_with_adsorbate = AseAtomsAdaptor.get_atoms(struct_with_adsorbate)\n# Get distance matrix between adsorbate binding atom and surface\nd = atoms_with_adsorbate.get_all_distances(mic=True)[\n0 : len(atoms), len(atoms) :\n]\n# Find closest surface atoms\nmin_d = np.min(d)\nsurface_atom_indices = np.where(\n(d &gt;= min_d - min_d * 0.1) &amp; (d &lt;= min_d + min_d * 0.1)\n)[0]\nsurface_atom_symbols = atoms_with_adsorbate[\nsurface_atom_indices\n].get_chemical_symbols()\n# Check if surface binding site is not in the specified\n# user list. If so, skip this one\nif allowed_surface_symbols and all(\nsurface_atom_symbol not in allowed_surface_symbols\nfor surface_atom_symbol in surface_atom_symbols\n):\ncontinue\nif allowed_surface_indices and all(\nsurface_atom_idx not in allowed_surface_indices\nfor surface_atom_idx in surface_atom_indices\n):\ncontinue\n# Store adsorbate info\natoms_with_adsorbate.info = atoms.info.copy()\nads_stats = {\n\"adsorbate\": adsorbate,\n\"initial_mode\": mode,\n\"surface_atoms_symbols\": surface_atom_symbols,\n\"surface_atoms_indices\": surface_atom_indices,\n}\nif atoms_with_adsorbate.info.get(\"adsorbates\", None) is None:\natoms_with_adsorbate.info[\"adsorbates\"] = [ads_stats]\nelse:\natoms_with_adsorbate.info[\"adsorbates\"].extend([ads_stats])\n# Add slab+adsorbate to list\nnew_atoms.append(atoms_with_adsorbate)\nreturn new_atoms\n</code></pre>"},{"location":"reference/quacc/util/slabs.html#quacc.util.slabs.make_max_slabs_from_bulk","title":"make_max_slabs_from_bulk","text":"<pre><code>make_max_slabs_from_bulk(atoms, max_slabs=None, max_index=1, randomize=False, min_slab_size=10.0, min_length_width=8.0, min_vacuum_size=20.0, z_fix=2.0, flip_asymmetric=True, allowed_surface_symbols=None, **slabgen_kwargs)\n</code></pre> <p>Generate no more than max_slabs number of slabs from a bulk structure. The procedure is as follows: 1. Generate all slabs 2. If number of slabs is greater than max_slabs, tune ftol from 0.1 to 0.8 in increments of 0.1. This reduces the number of vertical shifts to consider. 3. If number of slabs is still greater than max_slabs, only return the slabs with the fewest number of atoms per cell such that the returned amount is less than or equal to max_slabs.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>Bulk structure to generate slabs from</p> </li> <li> max_slabs             (<code>int | None</code>)         \u2013          <p>Maximum number of slabs to generate</p> </li> <li> randomize             (<code>bool</code>)         \u2013          <p>If True, return a random selection of max_slabs number of slabs. Otherwise, follow the procedure outlined above.</p> </li> <li> max_index             (<code>int</code>)         \u2013          <p>Maximum Miller index for slab generation</p> </li> <li> min_slab_size             (<code>float</code>)         \u2013          <p>Minimum slab size (depth) in angstroms</p> </li> <li> min_length_width             (<code>float</code>)         \u2013          <p>Minimum length and width of the slab in angstroms</p> </li> <li> min_vacuum_size             (<code>float</code>)         \u2013          <p>Minimum vacuum size in angstroms</p> </li> <li> z_fix             (<code>float | None</code>)         \u2013          <p>Distance (in angstroms) from top of slab for which atoms should be fixed</p> </li> <li> flip_asymmetric             (<code>bool</code>)         \u2013          <p>If an asymmetric surface should be flipped and added to the list</p> </li> <li> allowed_surface_symbols             (<code>list[str] | None</code>)         \u2013          <p>List of chemical symbols that must be present on the surface of the slab otherwise the slab will be discarded, e.g. [\"Cu\", \"Ni\"]</p> </li> <li> **slabgen_kwargs         \u2013          </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Atoms]</code>         \u2013          <p>List of slabs</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/util/slabs.py</code> <pre><code>def make_max_slabs_from_bulk(\natoms: Atoms,\nmax_slabs: int | None = None,\nmax_index: int = 1,\nrandomize: bool = False,\nmin_slab_size: float = 10.0,\nmin_length_width: float = 8.0,\nmin_vacuum_size: float = 20.0,\nz_fix: float | None = 2.0,\nflip_asymmetric: bool = True,\nallowed_surface_symbols: list[str] | None = None,\n**slabgen_kwargs,\n) -&gt; list[Atoms]:\n\"\"\"\n    Generate no more than max_slabs number of slabs from a bulk structure.\n    The procedure is as follows:\n    1. Generate all slabs\n    2. If number of slabs is greater than max_slabs, tune ftol from 0.1 to 0.8\n    in increments of 0.1. This reduces the number of vertical shifts to consider.\n    3. If number of slabs is still greater than max_slabs, only return the slabs\n    with the fewest number of atoms per cell such that the returned amount is\n    less than or equal to max_slabs.\n    Parameters\n    ----------\n    atoms\n        Bulk structure to generate slabs from\n    max_slabs\n        Maximum number of slabs to generate\n    randomize\n        If True, return a random selection of max_slabs number of slabs. Otherwise,\n        follow the procedure outlined above.\n    max_index\n        Maximum Miller index for slab generation\n    min_slab_size\n        Minimum slab size (depth) in angstroms\n    min_length_width\n        Minimum length and width of the slab in angstroms\n    min_vacuum_size\n        Minimum vacuum size in angstroms\n    z_fix\n        Distance (in angstroms) from top of slab for which atoms should be fixed\n    flip_asymmetric\n        If an asymmetric surface should be flipped and added to the list\n    allowed_surface_symbols\n        List of chemical symbols that must be present on the surface of the slab otherwise\n        the slab will be discarded, e.g. [\"Cu\", \"Ni\"]\n    **slabgen_kwargs: keyword arguments to pass to the pymatgen generate_all_slabs() function\n    Returns\n    --------\n    List[Atoms]\n        List of slabs\n    \"\"\"\nslabs = make_slabs_from_bulk(\natoms,\nmax_index=max_index,\nmin_slab_size=min_slab_size,\nmin_length_width=min_length_width,\nmin_vacuum_size=min_vacuum_size,\nz_fix=z_fix,\nflip_asymmetric=flip_asymmetric,\nallowed_surface_symbols=allowed_surface_symbols,\n**slabgen_kwargs,\n)\nif randomize:\nsubsample = max_slabs or len(slabs)\nslabs = random.sample(slabs, subsample)\nreturn slabs\n# Try to reduce the number of slabs if the user really wants it...\n# (desperate times call for desperate measures)\nif max_slabs and slabs is not None and len(slabs) &gt; max_slabs:\nwarnings.warn(\nf\"You requested {max_slabs} slabs, but {len(slabs)} were generated. Tuning ftol in generate_all_slabs() to try to reduce the number of slabs, at the expense of sampling fewer surface configurations.\",\nUserWarning,\n)\nfor ftol in np.arange(0.1, 0.9, 0.1):\nslabgen_kwargs[\"ftol\"] = ftol\nslabs_ftol = make_slabs_from_bulk(\natoms,\nmax_index=max_index,\nmin_slab_size=min_slab_size,\nmin_length_width=min_length_width,\nmin_vacuum_size=min_vacuum_size,\nz_fix=z_fix,\nflip_asymmetric=flip_asymmetric,\nallowed_surface_symbols=allowed_surface_symbols,\n**slabgen_kwargs,\n)\nif len(slabs_ftol) &lt; len(slabs):\nslabs = slabs_ftol\nif len(slabs) &lt;= max_slabs:\nbreak\nif len(slabs) &gt; max_slabs:\nwarnings.warn(\nf\"You requested {max_slabs} slabs, but {len(slabs)} were generated. Could not reduce further. Picking the smallest slabs by number of atoms.\",\nUserWarning,\n)\nslabs.sort(key=len)\nslabs = slabs[:max_slabs]\nreturn slabs\n</code></pre>"},{"location":"reference/quacc/util/slabs.html#quacc.util.slabs.make_slabs_from_bulk","title":"make_slabs_from_bulk","text":"<pre><code>make_slabs_from_bulk(atoms, max_index=1, min_slab_size=10.0, min_length_width=8.0, min_vacuum_size=20.0, z_fix=2.0, flip_asymmetric=True, allowed_surface_symbols=None, **slabgen_kwargs)\n</code></pre> <p>Function to make slabs from a bulk atoms object.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>bulk atoms</p> </li> <li> max_index             (<code>int</code>)         \u2013          <p>Maximum Miller index for slab generation</p> </li> <li> min_slab_size             (<code>float</code>)         \u2013          <p>Minimum slab size (depth) in angstroms</p> </li> <li> min_length_width             (<code>float</code>)         \u2013          <p>Minimum length and width of the slab in angstroms</p> </li> <li> min_vacuum_size             (<code>float</code>)         \u2013          <p>Minimum vacuum size in angstroms</p> </li> <li> z_fix             (<code>float | None</code>)         \u2013          <p>Distance (in angstroms) from top of slab for which atoms should be fixed</p> </li> <li> flip_asymmetric             (<code>bool</code>)         \u2013          <p>If an asymmetric surface should be flipped and added to the list</p> </li> <li> allowed_surface_symbols             (<code>list[str] | None</code>)         \u2013          <p>List of chemical symbols that must be present on the surface of the slab otherwise the slab will be discarded, e.g. [\"Cu\", \"Ni\"]</p> </li> <li> **slabgen_kwargs         \u2013          </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Atoms]</code>         \u2013          <p>All generated slabs</p> </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/util/slabs.py</code> <pre><code>def make_slabs_from_bulk(\natoms: Atoms,\nmax_index: int = 1,\nmin_slab_size: float = 10.0,\nmin_length_width: float = 8.0,\nmin_vacuum_size: float = 20.0,\nz_fix: float | None = 2.0,\nflip_asymmetric: bool = True,\nallowed_surface_symbols: list[str] | None = None,\n**slabgen_kwargs,\n) -&gt; list[Atoms]:\n\"\"\"\n    Function to make slabs from a bulk atoms object.\n    Parameters\n    ----------\n    atoms\n        bulk atoms\n    max_index\n        Maximum Miller index for slab generation\n    min_slab_size\n        Minimum slab size (depth) in angstroms\n    min_length_width\n        Minimum length and width of the slab in angstroms\n    min_vacuum_size\n        Minimum vacuum size in angstroms\n    z_fix\n        Distance (in angstroms) from top of slab for which atoms should be fixed\n    flip_asymmetric\n        If an asymmetric surface should be flipped and added to the list\n    allowed_surface_symbols\n        List of chemical symbols that must be present on the surface of the slab otherwise the slab will be discarded, e.g. [\"Cu\", \"Ni\"]\n    **slabgen_kwargs: keyword arguments to pass to the pymatgen generate_all_slabs() function\n    Returns\n    -------\n    list[Atoms]\n        All generated slabs\n    \"\"\"\n# Note: This will not work properly for 2D structures. See Oxana/Martin's code\n# for adjustments for 2D: https://github.com/oxana-a/atomate/blob/ads_wf/atomate/vasp/firetasks/adsorption_tasks.py\n# Use pymatgen to generate slabs\nstruct = AseAtomsAdaptor.get_structure(atoms)\natoms_info = atoms.info.copy()\n# Make all the slabs\nslabs = generate_all_slabs(\nstruct,\nmax_index,\nmin_slab_size,\nmin_vacuum_size,\ncenter_slab=True,\n**slabgen_kwargs,\n)\n# If the two terminations are not equivalent, make new slab\n# by inverting the original slab and add it to the list\nif flip_asymmetric:\nnew_slabs = []\nfor slab in slabs:\nif not slab.is_symmetric():\n# Flip the slab and its oriented unit cell\nnew_slab = flip_atoms(slab, return_struct=True)\nnew_oriented_unit_cell = flip_atoms(\nslab.oriented_unit_cell, return_struct=True\n)\n# Reconstruct the full slab object, noting the new\n# shift and oriented unit cell\nnew_slab = Slab(\nnew_slab.lattice,\nnew_slab.species,\ncoords=new_slab.frac_coords,\nmiller_index=slab.miller_index,\noriented_unit_cell=new_oriented_unit_cell,\nshift=-slab.shift,\nscale_factor=slab.scale_factor,\nsite_properties=new_slab.site_properties,\n)\n# It looks better to center the inverted slab so we do\n# that here.\nnew_slab = center_slab(new_slab)\n# Add the new slab to the list\nnew_slabs.append(new_slab)\nslabs.extend(new_slabs)\n# For each slab, make sure the lengths and widths are large enough\n# and fix atoms z_fix away from the top of the slab.\nslabs_with_props = []\nfor slab in slabs:\n# Make sure desired atoms are on surface\nif allowed_surface_symbols:\n# Find atoms at surface\nsurf_sites = AdsorbateSiteFinder(slab.copy()).surface_sites\nsurface_species = [s.specie.symbol for s in surf_sites]\nif allowed_surface_symbols and all(\nallowed_surface_atom not in surface_species\nfor allowed_surface_atom in allowed_surface_symbols\n):\ncontinue\n# Supercell creation (if necessary)\na_factor = int(np.ceil(min_length_width / slab.lattice.abc[0]))\nb_factor = int(np.ceil(min_length_width / slab.lattice.abc[1]))\nslab.make_supercell([a_factor, b_factor, 1])\n# Add constraints. Note: This does not actually add an adsorbate\nif z_fix:\nsel_dyn = AdsorbateSiteFinder(\nslab.copy(), selective_dynamics=True, height=z_fix\n).slab.site_properties[\"selective_dynamics\"]\nslab.add_site_property(\"selective_dynamics\", sel_dyn)\n# Add slab to list\nslabs_with_props.append(slab)\nfinal_slabs = []\nif not slabs_with_props:\nreturn final_slabs\n# Make atoms objects and store slab stats\nfor slab_with_props in slabs_with_props:\nfinal_slab = AseAtomsAdaptor.get_atoms(slab_with_props)\nslab_stats = {\n\"bulk\": atoms,\n\"miller_index\": slab_with_props.miller_index,\n\"shift\": round(slab_with_props.shift, 3),\n\"scale_factor\": slab_with_props.scale_factor,\n}\nfinal_slab.info = atoms_info.copy()\nfinal_slab.info[\"slab_stats\"] = slab_stats\nfinal_slabs.append(final_slab)\nreturn final_slabs\n</code></pre>"},{"location":"reference/quacc/util/thermo.html","title":"thermo","text":"<p>Utility functions for thermochemistry</p>"},{"location":"reference/quacc/util/thermo.html#quacc.util.thermo.ideal_gas","title":"ideal_gas","text":"<pre><code>ideal_gas(atoms, vib_freqs, energy=0.0, spin_multiplicity=None)\n</code></pre> <p>Calculate thermodynamic properties for a molecule from a given vibrational analysis. This is for free gases only and will not be valid for solids or adsorbates on surfaces. Any imaginary vibrational modes after the 3N-5/3N-6 cut will simply be ignored.</p> <p>Parameters:</p> <ul> <li> atoms             (<code>Atoms</code>)         \u2013          <p>The Atoms object associated with the vibrational analysis.</p> </li> <li> vib_freqs             (<code>list[float | complex]</code>)         \u2013          <p>The list of vibrations to use in cm^-1, typically obtained from Vibrations.get_frequencies().</p> </li> <li> energy             (<code>float</code>)         \u2013          <p>Potential energy in eV. If 0 eV, then the thermochemical correction is computed.</p> </li> <li> spin_multiplicity             (<code>int | None</code>)         \u2013          <p>The spin multiplicity (2S+1). If None, this will be determined automatically from the attached magnetic moments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>IdealGasThermo object</code>         \u2013          </li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/quacc/util/thermo.py</code> <pre><code>def ideal_gas(\natoms: Atoms,\nvib_freqs: list[float | complex],\nenergy: float = 0.0,\nspin_multiplicity: int | None = None,\n) -&gt; IdealGasThermo:\n\"\"\"\n    Calculate thermodynamic properties for a molecule from a given vibrational analysis.\n    This is for free gases only and will not be valid for solids or adsorbates on surfaces.\n    Any imaginary vibrational modes after the 3N-5/3N-6 cut will simply be ignored.\n    Parameters\n    ----------\n    atoms\n        The Atoms object associated with the vibrational analysis.\n    vib_freqs\n        The list of vibrations to use in cm^-1, typically obtained from Vibrations.get_frequencies().\n    energy\n        Potential energy in eV. If 0 eV, then the thermochemical correction is computed.\n    spin_multiplicity\n        The spin multiplicity (2S+1). If None, this will be determined automatically from the\n        attached magnetic moments.\n    Returns\n    -------\n    IdealGasThermo object\n    \"\"\"\n# Switch off PBC since this is only for molecules\natoms.set_pbc(False)\n# Ensure all negative modes are made complex\nfor i, f in enumerate(vib_freqs):\nif not isinstance(f, complex) and f &lt; 0:\nvib_freqs[i] = complex(0 - f * 1j)\n# Convert vibrational frequencies to energies\nvib_energies = [f * units.invcm for f in vib_freqs]\n# Get the spin from the Atoms object.\nif spin_multiplicity:\nspin = (spin_multiplicity - 1) / 2\nelif (\ngetattr(atoms, \"calc\", None) is not None\nand getattr(atoms.calc, \"results\", None) is not None\nand atoms.calc.results.get(\"magmom\", None) is not None\n):\nspin = round(atoms.calc.results[\"magmom\"]) / 2\nelif (\ngetattr(atoms, \"calc\", None) is not None\nand getattr(atoms.calc, \"results\", None) is not None\nand atoms.calc.results.get(\"magmoms\", None) is not None\n):\nspin = round(np.sum(atoms.calc.results[\"magmoms\"])) / 2\nelif atoms.has(\"initial_magmoms\"):\nspin = round(np.sum(atoms.get_initial_magnetic_moments())) / 2\nelse:\nspin = 0\n# Get symmetry for later use\nnatoms = len(atoms)\nmetadata = atoms_to_metadata(atoms)\n# Get the geometry\nif natoms == 1:\ngeometry = \"monatomic\"\nelif metadata[\"symmetry\"][\"linear\"]:\ngeometry = \"linear\"\nelse:\ngeometry = \"nonlinear\"\nreturn IdealGasThermo(\nvib_energies,\ngeometry,\npotentialenergy=energy,\natoms=atoms,\nsymmetrynumber=metadata[\"symmetry\"][\"rotation_number\"],\nspin=spin,\nignore_imag_modes=True,\n)\n</code></pre>"},{"location":"start/demo.html","title":"Quick Start","text":"<p>Want to get up and running with quacc as fast possible? Here we go!</p>"},{"location":"start/demo.html#installation","title":"Installation","text":"<p>Run the following commands in the terminal:</p> <pre><code>pip install git+https://github.com/quantum-accelerators/quacc.git\nquacc config\ncovalent start\n</code></pre> <p>Then open the URL printed in the terminal and run a sample workflow below!</p>"},{"location":"start/demo.html#demo-workflow-1-a-simple-one","title":"Demo Workflow 1: A Simple One","text":"<p>This demo workflow will relax a bulk Cu structure using the EMT calculator.</p> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\n# Define the workflow\nworkflow = ct.lattice(relax_job)\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n# Dispatch the workflow to the Covalent server\n# with the bulk Cu Atoms object as the input\ndispatch_id = ct.dispatch(workflow)(atoms)\n# Fetch the result from the server\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <p></p>"},{"location":"start/demo.html#demo-workflow-2-a-more-complex-one","title":"Demo Workflow 2: A More Complex One","text":"<p>This demo workflow will relax a bulk Cu structure using the EMT calculator, use the relaxed structure to generate a set of surface slabs, and then run a relaxation and static calculation on each generated slab.</p> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n# Define the workflow and set how to execute\n@ct.lattice(executor=\"local\")\ndef workflow(atoms):\n# Relax a bulk structure\nrelaxed_bulk = relax_job(atoms)\n# With the relaxed bulk as input, generate and relax slabs\nrelaxed_slabs = bulk_to_slabs_flow(relaxed_bulk)\nreturn relaxed_slabs\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n# Dispatch the workflow to the Covalent server\n# with the bulk Cu Atoms object as the input\ndispatch_id = ct.dispatch(workflow)(atoms)\n# Fetch the result from the server\nresult = ct.get_result(dispatch_id)\nprint(result)\n</code></pre> <p></p>"},{"location":"start/demo.html#what-next","title":"What Next?","text":"<p>Read through the User Guide to learn more about using quacc! And of course, feel free to explore the calculations you just ran in the Covalent UI.</p> <p></p>"},{"location":"user/basics.html","title":"Quacc Basics","text":"<p>In quacc, each code comes with pre-packaged jobs and workflows, which we call recipes for short. This tutorial walks you through how to use these provided recipes to run simple calculations that can be tested out on your local machine.</p> <p>Once you understand the basics, you should move on to the \"Going High-Throughput\" guide to learn how to use quacc with a workflow manager, which allows you to stich together and run complex quacc workflows across distributed computing resources.</p>"},{"location":"user/basics.html#pre-requisites","title":"Pre-Requisites","text":"<p>If you are not yet familiar with the ASE <code>Atoms</code> object, you should read the ASE tutorial, as this is the main object used to represent molecules and structures within quacc. Additionally, it is worthwhile to be familiar with the basics of an ASE Calculator.</p> <p>Hint</p> <p>If you are coming from the Pymatgen ecosystem, you can use the <code>pymatgen.io.ase.AseAtomsAdaptor</code> class to convert between Pymatgen <code>Structure</code>/<code>Molecule</code> objects and the ASE <code>Atoms</code> object.</p>"},{"location":"user/basics.html#a-simple-calculation-with-emt","title":"A Simple Calculation with EMT","text":"<p>Let's start with a simple example. Here, we will use a cheap calculator based on effective medium theory (EMT) to run a structure relaxation on a bulk structure of copper, as shown below.</p> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n# Run a structure relaxation on the Atoms object\nresult = relax_job(atoms)\nprint(result)\n</code></pre> <p>Walking through step-by-step, we first defined an <code>Atoms</code> object representation of the material we wish to run the calculation on. In this example, we have imported the bulk Cu structure from ASE's predefined library of bulk structures.</p> <p>With the <code>Atoms</code> object defined, we then imported a desired recipe and instantiated it. In this case, since we want to use EMT, we can look in <code>quacc.recipes.emt</code> to see all the available recipes. We are interested in doing a structure relaxation, so we imported the <code>quacc.recipes.emt.core.relax_job</code> recipe. We then instantiated and ran the recipe by passing in the <code>Atoms</code> object we defined earlier.</p> <p>The recipe output (<code>result</code>) is a bit too large to print here; nonetheless, for context, it is a dictionary that has the following primary keys:</p> <pre><code>['atoms', 'atoms_info', 'builder_meta', 'chemsys', 'composition', 'composition_reduced', 'density', 'density_atomic', 'dir_name', 'elements', 'formula_anonymous', 'formula_pretty', 'input_structure', 'name', 'nelements', 'nid', 'nsites', 'parameters', 'parameters_opt', 'results', 'structure', 'symmetry', 'trajectory', 'trajectory_results', 'volume']\n</code></pre> <p>The <code>\"atoms\"</code> key contains a copy of the output <code>Atoms</code> object, the <code>\"results\"</code> key contains a dictionary of the results of the calculation, and the <code>\"parameters\"</code> key contains a dictionary of the parameters used in the calculation.</p> <p>Hint</p> <p>You can make an <code>Atoms</code> object from common files like a CIF, XYZ, or POSCAR by using the <code>ase.io.read</code> function. For instance, <code>from ase.io import read</code> followed by <code>atoms = read(\"&lt;/path/to/file&gt;\")</code>.</p>"},{"location":"user/basics.html#a-simple-mixed-code-workflow","title":"A Simple Mixed-Code Workflow","text":"<p>Now let's return to our bulk Cu example from above and start adding on some complexity. Here, we will use EMT to run a relaxation on the bulk Cu structure and then use the output of this calculation as the input to a static calculation with the semi-empirical quantum mechanics method GFN2-xTB as implemented in <code>quacc.recipes.tblite.core.static_job</code>. This example highlights how there are no restrictions in terms of how many codes you can use in a single workflow.</p> <p>Note</p> <p>Some recipes require additional setup. Refer to the Calculator Setup section for details. Note that <code>tblite</code> is currently available via <code>pip install</code> on Linux only.</p> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\nfrom quacc.recipes.tblite.core import static_job\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n# Run a structure relaxation with EMT\nresult1 = relax_job(atoms)\n# Run a static calculation with GFN2-xTB\nresult2 = static_job(result1, method=\"GFN2-xTB\")\nprint(result2)\n</code></pre> <p>Hint</p> <p>The output of most compute jobs is a dictionary summarizing the results of the calculation. It always has a key <code>\"atoms\"</code> that contains a copy of the output <code>Atoms</code> object. The first argument to all recipes accepts either the <code>Atoms</code> object directly or a dictionary containing it.</p> <p>What happens if the first job fails, you might ask? Then the code will crash, no results will be stored, and you'd have to start from scratch. That'd be sad, but thankfully this is where using a workflow manager can save the day.</p> <p>Read on to learn how to define workflows with complex connectivity and how to dispatch them across distributed computing resources.</p>"},{"location":"user/database.html","title":"Using a Database","text":"<p>Oftentimes, it is beneficial to store the results in a database for easy querying (like the example below). This is quite simple to do in quacc regardless of the workflow manager you are using by taking advantage of the numerous data store options in maggma.</p> <p></p> General PurposeCovalentJobflow <p>For a given recipe, you can store the final output summary in your desired using the <code>quacc.util.db.results_to_db</code> function, as shown in the example below.</p> MontyDBMongoDB <pre><code>from maggma.stores import MontyStore\nfrom quacc.util.db import results_to_db\n# Let `results` be an output (or list of outputs) from quacc recipes\n# Define your database credentials\nstore = MontyStore(\n\"quacc_results\",\ndatabase_path=\".\",\ndatabase_name=\"quacc_db\"\n)\n# Store the results\nresults_to_db(store, results)\n</code></pre> <pre><code>from maggma.stores import MongoStore\nfrom quacc.util.db import results_to_db\n# Let `results` be an output (or list of outputs) from quacc recipes\n# Define your database credentials\nstore = MongoStore(\n\"my_db_name\",\n\"my_collection_name\",\nusername=\"my_username\",\npassword=\"my_password\",\nhost=\"localhost\",\nport=27017\n)\n# Store the results\nresults_to_db(store, results)\n</code></pre> <p>Covalent automatically stores all the inputs and outputs in an SQLite database, which you can find at the <code>\"db_path\"</code> when you run <code>covalent config</code>, and the results can be queried using the <code>ct.get_result(&lt;dispatch ID&gt;)</code> syntax. However, if you want to store the results in a different database of your choosing, you can do so quite easily.</p> <p>An example is shown below for storing the results in your custom database via the <code>quacc.util.db.covalent_to_db</code> function.</p> MontyDBMongoDB <pre><code>from maggma.stores import MontyStore\nfrom quacc.util.db import covavlent_to_db\n# Define your database credentials\nstore = MontyStore(\n\"quacc_results\",\ndatabase_path=\".\",\ndatabase_name=\"quacc_db\"\n)\n# Store the results\ncovalent_to_db(store)\n</code></pre> <pre><code>from maggma.stores import MongoStore\nfrom quacc.util.db import covavlent_to_db\n# Define your database credentials\nstore = MongoStore(\n\"my_db_name\",\n\"my_collection_name\",\nusername=\"my_username\",\npassword=\"my_password\",\nhost=\"localhost\",\nport=27017\n)\n# Store the results\ncovalent_to_db(store)\n</code></pre> <p>If you are using Jobflow to construct your workflows, it will automatically store the results in the database you defined during the setup process. No additional steps are needed.</p>"},{"location":"user/settings.html","title":"Quacc Settings","text":""},{"location":"user/settings.html#modifying-quacc-settings","title":"Modifying Quacc Settings","text":"<p>By default, the global quacc settings can be found in the <code>settings.py</code> file. If you wish to modify any of the global quacc settings, there are two ways to do so.</p>"},{"location":"user/settings.html#method-1","title":"Method 1","text":"<p>The easiest way is to create a custom YAML file with custom settings. For instance, it might look something like the following if you wanted to modify the <code>SCRATCH_DIR</code> and <code>GZIP_FILES</code> settings.</p> quacc.yaml<pre><code>SCRATCH_DIR: /tmp\nGZIP_FILES: false\n</code></pre> <p>By default, quacc looks for this YAML file at <code>~/quacc.yaml</code>. If you wish to store the <code>quacc.yaml</code> file somewhere else, you can define the environment variable <code>QUACC_CONFIG_FILE</code> and point it to the <code>quacc.yaml</code> path of your choosing.</p>"},{"location":"user/settings.html#method-2","title":"Method 2","text":"<p>If you want to define quacc settings on-the-fly without writing them to a YAML file, you can instead modify the desired settings by defining individual environment variables with <code>QUACC</code> as the prefix. For instance, to modify the <code>SCRATCH_DIR</code> setting to be <code>/tmp</code>, simply define <code>QUACC_SCRATCH_DIR=/tmp</code> as a new environment variable.</p>"},{"location":"user/wflow_engines.html","title":"Going High-Throughput","text":"<p>Here, we will show how to use quacc with one of a variety of workflow engines to construct, dispatch, and monitor your calculations.</p> <p>Tip</p> <p>If you are just getting started with workflow engines, we recommend first trying Covalent.</p>"},{"location":"user/wflow_engines.html#pre-requisites","title":"Pre-Requisites","text":"CovalentParslJobflow <p>Take a moment to learn about the main Covalent Concepts, namely the <code>Electron</code> and <code>Lattice</code> objects, which describe individual compute tasks and workflows, respectively.</p> <p>In Covalent, the <code>@ct.lattice</code> decorator indicates that the function is a workflow, and the <code>@ct.electron</code> decorator indicates that the function is a job (i.e. an individual compute task). If you plan to use a job scheduling system like Slurm, you can think of each <code>Electron</code> as an individual Slurm job.</p> <p>All <code>Electron</code> and <code>Lattice</code> objects behave as normal Python functions when the necessary arguments are supplied. However, if the <code>ct.dispatch</code> command is used, the workflow will be dispatched to the Covalent server for execution and monitoring.</p> <p>Info</p> <p>For a more detailed tutorial on how to use Covalent, refer to the \"Covalent Quick Start\".</p> <p>Take a moment to read Parsl documentation's \"Quick Start\" to get a sense of how Parsl works. Namely, you should understand the concept of a <code>@python_app</code> and <code>@join_app</code>, which describe individual compute tasks and dynamic job tasks, respectively.</p> <p>Info</p> <p>For a more detailed tutorial on how to use Parsl, refer to the \"Parsl Tutorial\" and the even more detailed \"Parsl User Guide\".</p> <p>Take a moment to read the Jobflow documentation's Quick Start to get a sense of how Jobflow works. Namely, you should understand the <code>Job</code> and <code>Flow</code> definitions, which describe individual compute tasks and workflows, respectively.</p> <p>Info</p> <p>For a more detailed tutorial on how to use Jobflow, refer to the Jobflow Tutorials and this helpful guide written by Dr. Janine George.</p>"},{"location":"user/wflow_engines.html#examples","title":"Examples","text":""},{"location":"user/wflow_engines.html#running-a-simple-serial-workflow","title":"Running a Simple Serial Workflow","text":"<p>We will now try running a simple workflow where we relax a bulk Cu structure using EMT and take the output of that calculation as the input to a follow-up static calculation with EMT.</p> <pre><code>graph LR\n  A[Input] --&gt; B(Relax) --&gt; C(Static) --&gt; D[Output];</code></pre> CovalentParslJobflow <p>Hint</p> <p>If you haven't done so yet, make sure you started the Covalent server with <code>covalent start</code> in the command-line.</p> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job, static_job\n# Define the workflow\n@ct.lattice\ndef workflow(atoms):\n# Define Job 1\nresult1 = relax_job(atoms)\n# Define Job 2, which takes the output of Job 1 as input\nresult2 = static_job(result1)\nreturn result2\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n# Dispatch the workflow to the Covalent server\n# with the bulk Cu Atoms object as the input\ndispatch_id = ct.dispatch(workflow)(atoms)\n# Fetch the result from the server\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <p>You can see that it is quite trivial to set up a workflow using the recipes within quacc. We define the full workflow as a <code>Lattice</code> object that stitches together the individual workflow steps. The <code>quacc.recipes.emt.core.relax_job</code> and <code>quacc.recipes.emt.core.static_job</code> were both already defined with a <code>@ct.electron</code> decorator, so they will be interpreted by Covalent as <code>Electron</code> objects.</p> <p>Covalent will also automatically construct a directed acyclic graph of the inputs and outputs for each calculation to determine which jobs are dependent on one another and the order the jobs should be run. In this example, Covalent will know not to run <code>job2</code> until <code>job1</code> has completed successfully.</p> <p>The job will be dispatched to the Covalent server with the <code>ct.dispatch</code> command, which takes in the workflow function and the input arguments to the workflow. The <code>ct.get_result</code> command is used to fetch the results from the server.</p> <p>Note</p> <p>Because the workflow is only sent to the server with <code>ct.dispatch</code>, calling <code>workflow(atoms)</code> would run the workflow as if Covalent were not being used at all.</p> <p></p> <p>Hint</p> <p>If you haven't done so yet, make sure you have loaded a Parsl configuration in your Python script. An example for running on your local machine is included below. Note that dynamic workflow recipes may fail if multi-threading is enabled, which is why we don't use the default <code>parsl.load()</code> configuration.</p> <pre><code>from parsl import Config\nfrom parsl.executors.threads import ThreadPoolExecutor\nparsl.load(config=Config(executors=[ThreadPoolExecutor(max_threads=1)]))\n</code></pre> <pre><code>from parsl import python_app\nfrom ase.build import bulk\n# Define the Python apps\n@python_app\ndef relax_app(atoms):\nfrom quacc.recipes.emt.core import relax_job\nreturn relax_job(atoms)\n@python_app\ndef static_app(atoms):\nfrom quacc.recipes.emt.core import static_job\nreturn static_job(atoms)\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n# Call App 1\nfuture1 = relax_app(atoms)\n# Call App 2, which takes the output of App 1 as input\nfuture2 = static_app(future1.result())\n# Print result\nprint(future2.result())\n</code></pre> <p>You can see that it is quite trivial to set up a Parsl workflow using the recipes within quacc. We define the full workflow as a function that stitches together the individual <code>@python_app</code> workflow steps.</p> <p>The use of <code>.result()</code> serves to block any further calculations from running until it is resolved. Calling <code>.result()</code> also returns the function output as opposed to the <code>AppFuture</code> object. Technically, we did not need to call <code>future1.result()</code> because Parsl will automatically know that it cannot run <code>static_app</code> until <code>future1</code> is resolved. Nonetheless, we have included it here for clarity.</p> <p>Note</p> <p>It is not considered good practice to include a <code>.result()</code> call in a <code>@python_app</code> or <code>@join_app</code> definition, which is why we didn't do so here.</p> <pre><code>from jobflow import Flow, job, run_locally\nfrom ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job, static_job\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n# Define Job 1\njob1 = job(relax_job)(atoms)\n# Define Job 2, which takes the output of Job 1 as input\njob2 = job(static_job)(job1.output)\n# Define the workflow\nworkflow = Flow([job1, job2])\n# Run the workflow locally\nresponses = run_locally(workflow, create_folders=True)\n# Get the result\nresult = responses[job2.uuid][1].output\nprint(result)\n</code></pre> <p>The key thing to note is that we need to transform the quacc recipe, which is a normal function, into a <code>Job</code> object. This can be done using the <code>@job</code> decorator and a new function definition or, more compactly, via <code>job(&lt;function&gt;)</code>.</p> <p>We also must stitch the individual <code>Job</code> objects together into a <code>Flow</code>, which can be easily achieved by passing them to the <code>Flow()</code> constructor. The <code>Flow</code> object will automatically determine the order in which the jobs should be run based on the inputs and outputs of each job. In this case, it will know not to run <code>job2</code> until <code>job1</code> has completed.</p> <p>We chose to run the job locally, but other workflow managers supported by Jobflow can be imported and used.</p>"},{"location":"user/wflow_engines.html#running-a-simple-parallel-workflow","title":"Running a Simple Parallel Workflow","text":"<p>Now let's consider a similar but nonetheless distinct example. Here, we will define a workflow where we will carry out two EMT structure relaxations, but the two jobs are not dependent on one another. In this example, Covalent will know that it can run the two jobs separately, and even if Job 1 were to fail, Job 2 would still progress.</p> <pre><code>graph LR\n  A[Input] --&gt; B(Relax) --&gt; D[Output]\n  A[Input] --&gt; C(Relax) --&gt; D[Output];</code></pre> CovalentParslJobflow <pre><code>import covalent as ct\nfrom ase.build import bulk, molecule\nfrom quacc.recipes.emt.core import relax_job\n# Define workflow\n@ct.lattice\ndef workflow(atoms1, atoms2):\n# Define two independent relaxation jobs\nresult1 = relax_job(atoms1)\nresult2 = relax_job(atoms2)\nreturn {\"result1\": result1, \"result2\": result2}\n# Define two Atoms objects\natoms1 = bulk(\"Cu\")\natoms2 = molecule(\"N2\")\n# Dispatch the workflow to the Covalent server\ndispatch_id = ct.dispatch(workflow)(atoms1, atoms2)\n# Fetch the results from the server\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <p></p> <pre><code>from parsl import python_app\nfrom ase.build import bulk, molecule\n# Define the Python app\n@python_app\ndef relax_app(atoms):\nfrom quacc.recipes.emt.core import relax_job\nreturn relax_job(atoms)\n# Define two Atoms objects\natoms1 = bulk(\"Cu\")\natoms2 = molecule(\"N2\")\n# Define two independent relaxation jobs\nfuture1 = relax_app(atoms1)\nfuture2 = relax_app(atoms2)\n# Print the results\nprint(future1.result(), future2.result())\n</code></pre> <p>Note</p> <p>If you find defining a new function for each <code>PythonApp</code> a bit annoying, you can use the following shorthand: <code>relax_app=python_app(relax_job.electron_object.function)</code>.</p> <pre><code>from jobflow import job, Flow, run_locally\nfrom ase.build import bulk, molecule\nfrom quacc.recipes.emt.core import relax_job\n# Define two Atoms objects\natoms1 = bulk(\"Cu\")\natoms2 = molecule(\"N2\")\n# Define two independent relaxation jobs\njob1 = job(relax_job)(atoms1)\njob2 = job(relax_job)(atoms2)\n# Define the workflow\nworkflow = Flow([job1, job2])\n# Run the workflow locally\nresponses = run_locally(workflow, create_folders=True)\n# Get the result\nresult = responses[job2.uuid][1].output\nprint(result)\n</code></pre>"},{"location":"user/wflow_engines.html#running-workflows-with-complex-connectivity","title":"Running Workflows with Complex Connectivity","text":"<p>For this example, let's consider a toy scenario where we wish to relax a bulk Cu structure, carve all possible slabs, and then run a new relaxation calculation on each slab (with no static calculation at the end). This is an example of a dynamic workflow.</p> <pre><code>graph LR\n  A[Input] --&gt; B(Relax) --&gt; C(Make Slabs)\n  C(Make Slabs) --&gt; D(Slab Relax) --&gt; H[Output]\n  C(Make Slabs) --&gt; E(Slab Relax) --&gt; H[Output]\n  C(Make Slabs) --&gt; F(Slab Relax) --&gt; H[Output]\n  C(Make Slabs) --&gt; G(Slab Relax) --&gt; H[Output];</code></pre> <p>In quacc, there are two types of recipes: individual compute tasks with the suffix <code>_job</code> and pre-made multi-step workflows with the suffix <code>_flow</code>. Here, we are interested in importing a pre-made workflow. Refer to the example below:</p> CovalentParslJobflow <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n@ct.lattice\ndef workflow(atoms):\nrelaxed_bulk = relax_job(atoms)\nrelaxed_slabs = bulk_to_slabs_flow(relaxed_bulk, slab_static_electron=None)\nreturn relaxed_slabs\natoms = bulk(\"Cu\")\ndispatch_id = ct.dispatch(workflow)(atoms)\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <p>We have imported the <code>quacc.recipes.emt.slabs.bulk_to_slabs_flow</code> function, which takes an <code>Atoms</code> object along with several optional parameters. For demonstration purposes, we specify the <code>slab_static_electron=None</code> option to do a relaxation but disable the static calculation on each slab. All we have to do to define the workflow is wrap it inside a <code>@ct.lattice</code> decorator.</p> <p>Due to the dynamic nature of <code>bulk_to_slabs_flow</code>, the number of returned slabs will be dependent on the input <code>Atoms</code> object. The pattern for creating a dynamic workflow in Covalent is called a \"sublattice\". The sublattice, which is really just a fancy name for a sub-workflow within a larger workflow, and its individual compute tasks can also be viewed in the Covalent UI.</p> <p>Hint</p> <p>You don't need to set <code>wait=True</code> in practice. Once you call <code>ct.dispatch</code>, the workflow will begin running. The <code>ct.get_result</code> function is used to fetch the workflow status and results from the server.</p> <p></p> <p>The Inefficient Way</p> <pre><code>from parsl import python_app\nfrom ase.build import bulk\n@python_app\ndef relax_app(atoms):\nfrom quacc.recipes.emt.core import relax_job\nreturn relax_job(atoms)\n@python_app\ndef bulk_to_slabs_app(atoms):\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\nreturn bulk_to_slabs_flow(atoms, slab_static_electron=None)\n# Define the Atoms object\natoms = bulk(\"Cu\")\n# Define the workflow\nfuture1 = relax_app(atoms)\nfuture2 = bulk_to_slabs_app(future1.result())\n# Print the results\nprint(future2.result())\n</code></pre> <p>When running a Covalent-based workflow like <code>.emt.slabs.bulk_to_slabs_flow</code> above, the entire function will run as a single compute task even though it is composed of several individual sub-tasks. If these sub-tasks are compute-intensive, this might not be the most efficient use of resources.</p> <p>The Efficient Way</p> <p>Quacc fully supports Parsl-based workflows to resolve this limitation. For example, the workflow above can be equivalently run as follows using the Parsl-specific <code>.emt.parsl.slabs.bulk_to_slabs_flow</code> workflow:</p> <pre><code>from parsl import python_app\nfrom ase.build import bulk\nfrom quacc.recipes.emt.parsl.slabs import bulk_to_slabs_flow\n# Define the Python App\n@python_app\ndef relax_app(atoms):\nfrom quacc.recipes.emt.core import relax_job\nreturn relax_job(atoms)\n# Define the Atoms object\natoms = bulk(\"Cu\")\n# Define the workflow\nfuture1 = relax_app(atoms)\nfuture2 = bulk_to_slabs_flow(future1.result(), slab_static_app=None)\n# Print the results\nprint(future2.result())\n</code></pre> <p>In this example, all the individual tasks and sub-tasks are run as separate jobs, which is more efficient. By comparing <code>.emt.parsl.slabs.bulk_to_slabs_flow</code> with its Covalent counterpart <code>.emt.slabs.bulk_to_slabs_flow</code>, you can see that the two are extremely similar such that it is often straightforward to interconvert between the two.</p> <p>Note</p> <p>We didn't need to wrap <code>bulk_to_slabs_flow</code> with a <code>@python_app</code> decorator because it is simply a collection of <code>PythonApp</code> objects and is already returning an <code>AppFuture</code>.</p> <p>The Inefficient Way</p> <pre><code>from jobflow immport job, Flow, run_locally\nfrom ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n# Define the Atoms object\natoms = bulk(\"Cu\")\n# Construct the Flow\njob1 = job(relax_job)(atoms)\njob2 = job(bulk_to_slabs_flow)(job1.output, slab_static_electron=None)\nworkflow = Flow([job1, job2])\n# Run the workflow locally\nresponses = run_locally(workflow, create_folders=True)\n# Get the result\nresult = responses[job2.uuid][1].output\nprint(result)\n</code></pre> <p>We have imported the <code>.emt.slabs.bulk_to_slabs_flow</code> function, which takes an <code>Atoms</code> object along with several optional parameters. For demonstration purposes, we specify the <code>slab_static_electron=None</code> option to do a relaxation but disable the static calculation on each slab. All we have to do to define the workflow is stitch together the individual <code>@job</code> steps into a single <code>Flow</code> object.</p> <p>The Efficient Way</p> <p>Quacc fully supports Jobflow-based workflows to resolve this limitation. For example, the workflow above can be equivalently run as follows using the Jobflow-specific <code>.emt.jobflow.slabs.bulk_to_slabs_flow</code> workflow:</p> <pre><code>from jobflow import job, Flow, run_locally\nfrom ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\nfrom quacc.recipes.emt.jobflow.slabs import bulk_to_slabs_flow\n# Define the Atoms object\natoms = bulk(\"Cu\")\n# Construct the Flow\njob1 = job(relax_job)(atoms)\njob2 = job(bulk_to_slabs_flow)(job1.output, slab_static_job=None)\nworkflow = Flow([job1, job2])\n# Run the workflow locally\nrun_locally(workflow, create_folders=True)\n</code></pre> <p>In this example, all the individual tasks and sub-tasks are run as separate jobs, which is more efficient. By comparing <code>.emt.jobflow.slabs.bulk_to_slabs_flow</code> with its Covalent counterpart <code>.emt.slabs.bulk_to_slabs_flow</code>, you can see that the two are extremely similar such that it is often straightforward to interconvert between the two. In the case of <code>bulk_to_slabs_flow</code>, it actually returns a <code>Response(replace)</code> object that dynamically replaces the <code>Flow</code> with several downstream jobs.</p>"},{"location":"user/wflow_engines.html#deploying-calculations","title":"Deploying Calculations","text":"CovalentParslJobflow <p>By default, Covalent will run all <code>Electron</code> tasks on your local machine using the <code>DaskExecutor</code>. This is a parameter that you can control. For instance, you may want to define the executor to be based on Slurm using the <code>SlurmExecutor</code> to submit a job to an HPC cluster. The example below highlights how one can change the executor.</p> <p>Setting Executors via the Lattice Object</p> <p>If you want to use the same executor for all the <code>Electron</code> objects in a <code>Lattice</code>, you can pass the <code>executor</code> keyword argument to the <code>@ct.lattice</code> decorator, as shown below.</p> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job, static_job\n@ct.lattice(executor=\"local\")\ndef workflow(atoms):\nresult1 = relax_job(atoms)\nresult2 = static_job(result1)\nreturn result2\natoms = bulk(\"Cu\")\ndispatch_id = ct.dispatch(workflow)(atoms)\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <p>Setting Executors via the Electron Objects</p> <p>The individual <code>Electron</code> executor options can be modified after they are imported as follows:</p> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job, static_job\n@ct.lattice\ndef workflow(atoms):\njob1 = relax_job\njob1.electron_object.executor = \"dask\"\njob2 = static_job\njob2.electron_object.executor = \"local\"\noutput1 = job1(atoms)\noutput2 = job2(output1)\nreturn output2\natoms = bulk(\"Cu\")\ndispatch_id = ct.dispatch(workflow)(atoms)\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <p>Hint</p> <p>If you are defining your own workflow functions to use, you can also set the executor for individual <code>Electron</code> objects by passing the <code>executor</code> keyword argument to the <code>@ct.electron</code> decorator.</p> <p>Configuring Executors</p> <p>Refer to the executor documentation for instructions on how to configure Covalent for your desired machines.</p> <p>By default, the <code>workdir</code> for the <code>Dask</code> (default) and <code>local</code> executors is set to <code>~/.cache/covalent/workdir</code>. This is where any files generated at runtime will be stored. You can change both of these parameters to the directories of your choosing by editing the Covalent configuration file directly or via the <code>ct.set_config()</code> command.</p> <p>For submitting jobs to Perlmutter at NERSC from your local machine, an example <code>SlurmExecutor</code> configuration with support for an <code>sshproxy</code>-based multi-factor authentication certificate might look like the following:</p> <pre><code>n_nodes = 1\nn_cores_per_node = 48\nexecutor = ct.executor.SlurmExecutor(\nusername=\"YourUserName\",\naddress=\"perlmutter-p1.nersc.gov\",\nssh_key_file=\"~/.ssh/nersc\",\ncert_file=\"~/.ssh/nersc-cert.pub\",\nremote_workdir=\"$SCRATCH\",\nconda_env=\"quacc\",\noptions={\nf\"nodes\": {n_nodes},\n\"qos\": \"debug\",\n\"constraint\": \"cpu\",\n\"account\": \"YourAccountName\",\n\"job-name\": \"quacc\",\n\"time\": \"00:10:00\",\n},\nprerun_commands=[\n\"export COVALENT_CONFIG_DIR=$SCRATCH\",\nf\"export QUACC_VASP_PARALLEL_CMD='srun -N {n_nodes} --ntasks-per-node={n_cores_per_node} --cpu_bind=cores'\",\n],\nuse_srun=False,\n)\n</code></pre> <p>Important</p> <p>The <code>SlurmExecutor</code> must have <code>use_srun=False</code> in order for ASE-based calculators to be launched appropriately.</p> <p>Out-of-the-box, Parsl will run on your local machine. However, in practice you will probably want to run your Parsl workflows on HPC machines.</p> <p>Note</p> <p>If you are just starting out, try running some test calculations locally first. Then come back and set up the relevant configuration files for your desired machines.</p> <p>Configuring Executors</p> <p>To configure Parsl for the high-performance computing environment of your choice, refer to the executor Configuration page in the Parsl documentation.</p> <p>For Perlmutter at NERSC, example <code>HighThroughputExecutor</code> configurations can be found in the NERSC Documentation. A simple one is reproduced below that allows for job submission from the login node. This example will create a single Slurm job that will run one <code>PythonApp</code> at a time on a single node and is good for testing out some of the examples above.</p> <pre><code>from parsl.config import Config\nfrom parsl.executors import HighThroughputExecutor\nfrom parsl.launchers import SimpleLauncher\nfrom parsl.providers import SlurmProvider\nconfig = Config(\nmax_idletime=120,\nexecutors=[\nHighThroughputExecutor(\nlabel=\"quacc_HTEX\",\nmax_workers=1,\nprovider=SlurmProvider(\naccount=\"MyAccountName\",\nnodes_per_block=1,\nscheduler_options=\"#SBATCH -q debug -C cpu\",\nworker_init=\"source activate quacc\",\nwalltime=\"00:10:00\",\ncmd_timeout=120,\nlauncher = SimpleLauncher(),\n),\n)\n],\n)\n</code></pre> <p>The individual arguments are as follows:</p> <ul> <li><code>max_idletime</code>: The maximum amount of time (in seconds) to allow the executor to be idle before the Slurm job is cancelled.</li> <li><code>label</code>: A label for the executor instance, used during file I/O.</li> <li><code>max_workers</code>: Maximum number of workers to allow on a node.</li> <li><code>SlurmProvider()</code>: The provider to use for job submission. This can be changed to <code>LocalProvider()</code> if you wish to have the Parsl process run on a compute node rather than the login node.</li> <li><code>account</code>: Your NERSC account name.</li> <li><code>nodes_per_block</code>: The number of nodes to request per job. By default, all cores on the node will be requested (seetting <code>cores_per_node</code> will override this).</li> <li><code>scheduler_options</code>: Any additional <code>#SBATCH</code> options can be included here.</li> <li><code>worker_init</code>: Commands to run before the job starts, typically used for activating a given Python environment.</li> <li><code>walltime</code>: The maximum amount of time to allow the job to run in <code>HH:MM:SS</code> format.</li> <li><code>cmd_timeout</code>: The maximum time to wait (in seconds) for the job scheduler info to be retrieved/sent.</li> <li><code>launcher</code>: The type of Launcher to use. Note that <code>SimpleLauncher()</code> must be used instead of the commonly used <code>SrunLauncher()</code> to allow quacc subprocesses to launch their own <code>srun</code> commands.</li> </ul> <p>Unlike some other workflow engines, Parsl (by default) is built for \"jobpacking\" where the allocated nodes continually pull in new workers (until the walltime is reached). This makes it possible to request a large number of nodes that continually pull in new jobs rather than submitting a large number of small jobs to the scheduler, which can be more efficient. In other words, don't be surprised if the Slurm job continues to run even when your submitted task has completed.</p> <p>Scaling Up</p> <p>Now let's consider a more realistic scenario. Suppose we want to have a single Slurm job that reserves 8 nodes, and each <code>PythonApp</code> (e.g. VASP calculation) will run on 2 nodes (let's assume each node has 48 cores total, so that's a total of 96 cores for each calculation). Parsl will act as an orchestrator in the background of one of the nodes. Our config will now look like the following.</p> <pre><code>n_parallel_calcs = 4 # Number of quacc calculations to run in parallel\nn_nodes_per_calc = 2 # Number of nodes to reserve for each calculation\nn_cores_per_node = 48 # Number of CPU cores per node\nvasp_parallel_cmd = f\"srun -N {n_nodes_per_calc} --ntasks-per-node={n_cores_per_node} --cpu_bind=cores\"\nconfig = Config(\nmax_idletime=300,\nexecutors=[\nHighThroughputExecutor(\nlabel=\"quacc_HTEX\",\nmax_workers=n_parallel_calcs,\ncores_per_worker=1e-6,\nprovider=SlurmProvider(\naccount=\"MyAccountName\",\nnodes_per_block=n_nodes_per_calc*n_parallel_calcs,\nscheduler_options=\"#SBATCH -q debug -C cpu\",\nworker_init=f\"source activate quacc &amp;&amp; module load vasp &amp;&amp; export QUACC_VASP_PARALLEL_CMD={vasp_parallel_cmd}\",\nwalltime=\"00:10:00\",\nlauncher = SimpleLauncher(),\ncmd_timeout=120,\ninit_blocks=0,\nmin_blocks=1,\nmax_blocks=1,\n),\n)\n],\n)\n</code></pre> <p>In addition to some modified parameters, there are some new ones here too. The most notable is the definition of <code>init_blocks</code>, <code>min_blocks</code>, and <code>max_blocks</code>, which set the number of active blocks (e.g. Slurm jobs) and can be modified to enable elastic resource management. We also set <code>cores_per_worker</code> to a small value so that the pilot job (e.g. the Parsl orchestrator) is allowed to be oversubscribed with scheduling processes.</p> <p>Tip</p> <p>Dr. Logan Ward has a nice example on YouTube describing a very similar example here.</p> <p>Warning</p> <p>By default, the <code>ThreadPoolExecutor</code> (which is used when calling <code>parsl.load()</code>) is run in a multi-threaded mode, which may cause I/O errors when running multiple calculations simultaneously. We do not recommend using Parsl-based multi-threading at this time if there is any file I/O in your workflow.</p> <p>Out-of-the box, Jobflow can be used to run on your local machine. You will, however, need a \"manager\" to run your workflows on HPC machines. The currently recommended manager for Jobflow is FireWorks, which is described here.</p> <p>Converting Between Jobflow and FireWorks</p> <p>The <code>jobflow.managers.fireworks</code> module has all the tools you need to convert your Jobflow workflows to a format that is suitable for FireWorks.</p> <p>Converting a Job to a Firework</p> <p>To convert a <code>Job</code> to a <code>firework</code> and add it to your launch pad:</p> <pre><code>from fireworks import LaunchPad\nfrom jobflow.managers.fireworks import job_to_firework\nfw = job_to_firework(job)\nlpad = LaunchPad.auto_load()\nlpad.add_wf(fw)\n</code></pre> <p>Converting a Flow to a Workflow</p> <p>To convert a <code>Flow</code> to a <code>workflow</code> and add it to your launch pad:</p> <pre><code>from fireworks import LaunchPad\nfrom jobflow.managers.fireworks import flow_to_workflow\nwf = flow_to_workflow(flow)\nlpad = LaunchPad.auto_load()\nlpad.add_wf(wf)\n</code></pre> <p>Dispatching Calculations</p> <p>With a workflow added to your launch pad, on the desired machine of choice, you can run <code>qlaunch rapidfire --nlaunches &lt;N&gt;</code> (where <code>&lt;N&gt;</code> is the number of jobs to submit) in the command line to submit your workflows to the job scheduler. Running <code>qlaunch rapidfire -m &lt;N&gt;</code> will ensure that <code>&lt;N&gt;</code> jobs are always in the queue or running. To modify the order in which jobs are run, a priority can be set via <code>lpad set_priority &lt;priority&gt; -i &lt;FWID&gt;</code> where <code>&lt;priority&gt;</code> is a number.</p> <p>By default, <code>qlaunch</code> will launch Slurm jobs that then poll for work. This means that more Slurm jobs may be submitted than there are jobs to run. To modify the behavior of <code>qlaunch</code> to only submit a Slurm job for each \"READY\" FireWork in the launchpad, use the <code>-r</code> (\"reserved\") flag.</p> <p>Monitoring the Launchpad</p> <p>The easiest way to monitor the state of your launched FireWorks and workflows is through the GUI, which can be viewed with <code>lpad webgui</code>. To get the status of running fireworks from the command line, you can run <code>lpad get_fws -s RUNNING</code>. Other statuses can also be provided as well as individual FireWorks IDs.</p> <p>To rerun a specific FireWork, one can use the <code>rerun_fws</code> command like so: <code>lpad rerun_fws -i &lt;FWID&gt;</code> where <code>&lt;FWID&gt;</code> is the FireWork ID. Similarly, one can rerun all fizzled jobs via <code>lpad rerun_fws -s FIZZLED</code>. More complicated Mongo-style queries can also be carried out. Cancelling a workflow can be done with <code>lpad delete_wflows -i &lt;FWID&gt;</code>.</p> <p>Refer to the <code>lpad -h</code> help menu for more details.</p> <p>Continuous Job Submission</p> <p>To ensure that jobs are continually submitted to the queue you can use <code>tmux</code> to preserve the job submission process even when the SSH session is terminated. For example, running <code>tmux new -s launcher</code> will create a new <code>tmux</code> session named <code>launcher</code>. To exit the <code>tmux</code> session while still preserving any running tasks on the login node, press <code>ctrl+b</code> followed by <code>d</code>. To re-enter the tmux session, run <code>tmux attach -t launcher</code>. Additional <code>tmux</code> commands can be found on the tmux cheatsheet.</p>"},{"location":"user/wflow_engines.html#learn-more","title":"Learn More","text":"CovalentParslJobflow <p>That ends the Covalent section of the documentation. If you want to learn more about Covalent, you can read the Covalent Documentation. Please refer to the Covalent Discussion Board for any Covalent-specific questions.</p> <p>That ends the Parsl section of the documentation. If you want to learn more about Parsl, you can read the Parsl Documentation. Please refer to the Parsl Slack Channel for any Parsl-specific questions.</p> <p>That ends the Jobflow section of the documentation. If you want to learn more about Jobflow, you can read the Jobflow Documentation. Please refer to the Jobflow Discussions Board for Jobflow-specific questions.</p>"},{"location":"user/wflow_overview.html","title":"Workflow Engines Overview","text":"<p>Everyone's computing needs are different, so we ensured that quacc is interoperable with a variety of modern workflow management tools. There are over 300+ workflow management tools out there, so we can't possibly cover them all. Instead, we have focused on the most popular tools that we have tested and found to be compatible with quacc with minimal additional coding required. The recommended solutions below each use a decorator-based approach to defining workflows, and the basic syntax is very similar across all of them.</p>"},{"location":"user/wflow_overview.html#pros-and-cons","title":"Pros and Cons","text":"CovalentParslJobflow <p>The default suggested workflow management solution is Covalent due to its ease of use and helpful dashboard. If you are new to workflow management tools or primarily care about computing across distributed resources, this will likely be the best option for you.</p> <p>Pros:</p> <ul> <li>Extremely simple to setup and use, even for complex workflows</li> <li>Best-in-class visual dashboard for job monitoring</li> <li>Designed with HPC environments in mind but also supports cloud compute</li> <li>Excellent documentation</li> <li>Automatic and simple database integration</li> </ul> <p>Cons:</p> <ul> <li>Still actively in development</li> <li>Not as widely used as other workflow management solutions</li> <li>For HPC, it currently only supports the Slurm job scheduler out-of-the-box, although custom plugins can be defined</li> <li>High-security HPC environments may be difficult to access with the centralized server approach</li> </ul> <p>Parsl is a workflow management solution out of Argonne National Laboratory, the University of Chicago, and the University of Illinois. It is well-adapted for running on HPC environments with a job scheduler. Parsl is especially useful for \"jobpacking,\" where instead of each task being an individual (e.g. Slurm) job, a long-running worker will continually pull in and distribute tasks within a single Slurm job until the walltime is reached. This can be useful because it is often easier to move through the queue by requesting a single large job rather than many small jobs.</p> <p>Pros:</p> <ul> <li>Extremely configurable for virtually any HPC environment</li> <li>Relatively simple to define the workflows</li> <li>Active community, particularly across academia</li> <li>Ideal for jobpacking and has near-ideal scaling performance</li> <li>Thorough documentation</li> </ul> <p>Cons:</p> <ul> <li>Defining the right configuration options for your desired HPC setup can be a challenge</li> <li>The visual dashboard is not as user friendly as some other solutions</li> <li>Challenging to orchestrate workflows with steps running across heterogeneous resources</li> <li>The concept of always returning a \"future\" object can be confusing for new users</li> </ul> <p>If you are affiliated with the Materials Project team at Lawrence Berkeley National Laboratory, we recommend using Jobflow to define the workflows coupled with FireWorks to dispatch them since it widely used there.</p> <p>Jobflow</p> <p>Pros:</p> <ul> <li>Simple interface for defining individual jobs and workflows</li> <li>Native support for databases</li> <li>Directly compatible with Atomate2</li> </ul> <p>Cons:</p> <ul> <li>Parsing the output of a workflow is not as intuitive as other solutions</li> <li>Defining dynamic workflows with Jobflow's <code>Response</code> object is slightly more complex than other solutions</li> </ul> <p>FireWorks:</p> <p>Pros:</p> <ul> <li>FireWorks is well-suited for a variety of job management approaches</li> <li>Helpful dashboard for monitoring job progress</li> </ul> <p>Cons:</p> <ul> <li>FireWorks documentation can be difficult to navigate without prior experience</li> <li>FireWorks can have a steep learning curve due to its many configuration options</li> <li>The need for a connection to a database can be a challenge in certain HPC environments</li> </ul>"},{"location":"user/wflow_syntax.html","title":"Workflow Syntax","text":""},{"location":"user/wflow_syntax.html#introduction","title":"Introduction","text":"<p>Here, we provide code snippets for several decorator-based workflow engines. For a comparison of the pros and cons of each approach, refer to the Workflow Engines Overview page.</p> <p>You can run the examples below as-is, with the following notes:</p> <ul> <li>For Covalent, run <code>covalent start</code> in the terminal to have the results show up in the GUI.</li> <li>For Parsl, do <code>import parsl</code> followed by <code>parsl.load()</code> in Python before running the scripts in order to load a default Parsl configuration.</li> </ul>"},{"location":"user/wflow_syntax.html#simple-workflow","title":"Simple Workflow","text":"<p>Let's do the following:</p> <ol> <li>Add two numbers (e.g. <code>1 + 2</code>)</li> <li>Multiply the output of Step 1 by a third number (e.g. <code>3 * 3</code>)</li> </ol> <p>In practice, we would want each of the two tasks to be their own compute job.</p> <pre><code>graph LR\n  A[Input] --&gt; B(add) --&gt; C(mult) --&gt; D[Output];</code></pre> No Workflow EngineCovalentParslJobflow <pre><code>def add(a, b):\nreturn a + b\ndef mult(a, b):\nreturn a * b\ndef workflow(a, b, c):\nreturn mult(add(a, b), c)\nresult = workflow(1, 2, 3) # 9\n</code></pre> <pre><code>import covalent as ct\n@ct.electron\ndef add(a, b):\nreturn a + b\n@ct.electron\ndef mult(a, b):\nreturn a * b\n@ct.lattice\ndef workflow(a, b, c):\nreturn mult(add(a, b), c)\n# Locally\nresult = workflow(1, 2, 3) # 9\n# Dispatched\ndispatch_id = ct.dispatch(workflow)(1, 2, 3)\nresult = ct.get_result(dispatch_id, wait=True) # 9\n</code></pre> <pre><code>from parsl import python_app\n@python_app\ndef add(a, b):\nreturn a + b\n@python_app\ndef mult(a, b):\nreturn a * b\ndef workflow(a, b, c):\nreturn mult(add(a, b), c)\nresult = workflow(1, 2, 3).result() # 9\n</code></pre> <pre><code>from jobflow import job, Flow, run_locally\n@job\ndef add(a, b):\nreturn a + b\n@job\ndef mult(a, b):\nreturn a * b\njob1 = add(1, 2)\njob2 = mult(job1.output, 3)\nflow = Flow([job1, job2])\nresponses = run_locally(flow)\nresult = responses[job2.uuid][1].output # 9\n</code></pre>"},{"location":"user/wflow_syntax.html#dynamic-workflow","title":"Dynamic Workflow","text":"<p>Let's do the following:</p> <ol> <li>Add two numbers (e.g. <code>1 + 2</code>)</li> <li>Make a list of copies of the output from Step 1 (e.g. <code>[3, 3, 3]</code>) where the size of the list is not known until runtime</li> <li>Add a third number to each element of the list from Step 2 (e.g. <code>[3 + 3, 3 + 3, 3 + 3]</code>)</li> </ol> <p>We will treat this as a dynamic workflow where the number of elements in the list from Step 2 may not necessarily be known until runtime. In practice, we would want each of the individual addition tasks to be their own compute job.</p> <pre><code>graph LR\n  A[Input] --&gt; B(add) --&gt; C(make_more)\n  C --&gt; D(add) --&gt; G[Output];\n  C --&gt; E(add) --&gt; G[Output];\n  C --&gt; F(add) --&gt; G[Output];</code></pre> No Workflow EngineCovalentParslJobflow <pre><code>import random\ndef add(a, b):\nreturn a + b\ndef make_more(val):\nreturn [val] * random.randint(2, 5)\ndef workflow(a, b, c):\nresult1 = add(a, b)\nresult2 = make_more(result1)\nreturn [add(val, c) for val in result2]\nresult = workflow(1, 2, 3) # e.g. [6, 6, 6]\n</code></pre> <pre><code>import random\nimport covalent as ct\n@ct.electron\ndef add(a, b):\nreturn a + b\n@ct.electron\ndef make_more(val):\nreturn [val] * random.randint(2, 5)\n@ct.electron\n@ct.lattice\ndef add_distributed(vals, c):\nreturn [add(val, c) for val in vals]\n@ct.lattice\ndef workflow(a, b, c):\nresult1 = add(a, b)\nresult2 = make_more(result1)\nreturn add_distributed(result2, c)\n# Locally\nresult = workflow(1, 2, 3) # e.g. [6, 6, 6]\n# Dispatched\ndispatch_id = ct.dispatch(workflow)(1, 2, 3)\nresult = ct.get_result(dispatch_id, wait=True) # e.g. [6, 6, 6]\n</code></pre> <pre><code>from parsl import join_app, python_app\n@python_app\ndef add(a, b):\nreturn a + b\n@python_app\ndef make_more(val):\nimport random\nreturn [val] * random.randint(2, 5)\n@join_app\ndef add_distributed(vals, c):\nreturn [add(val, c) for val in vals]\ndef workflow(a, b, c):\nfuture1 = add(a, b)\nfuture2 = make_more(future1)\nreturn add_distributed(future2, c)\nresult = workflow(1, 2, 3).result() # e.g. [6, 6, 6]\n</code></pre> <pre><code>import random\nfrom jobflow import job, Flow, Response, run_locally\n@job\ndef add(a, b):\nreturn a + b\n@job\ndef make_more(val):\nreturn [val] * random.randint(2, 5)\n@job\ndef add_distributed(vals, c):\njobs = []\nfor val in vals:\njobs.append(add(val, c))\nreturn Response(replace=Flow(jobs))\njob1 = add(1, 2)\njob2 = make_more(job1.output)\njob3 = add_distributed(job2.output, 3)\nflow = Flow([job1, job2, job3])\nresponses = run_locally(flow) # e.g. [6, 6, 6] (job3.output)\n</code></pre>"}]}